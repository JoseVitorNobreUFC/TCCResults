CODE,LABEL,TEXT_LABEL
"function serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.has_session)
        writer.writeMessage(1, this.session, () => this.session.serialize(writer));
    if (this.jid.length)
        writer.writeString(2, this.jid);
    if (this.text.length)
        writer.writeString(3, this.text);
    if (this.has_media)
        writer.writeMessage(4, this.media, () => this.media.serialize(writer));
    if (this.has_backgroundColor)
        writer.writeMessage(5, this.backgroundColor, () => this.backgroundColor.serialize(writer));
    if (this.has_font)
        writer.writeMessage(6, this.font, () => this.font.serialize(writer));
    if (this.linkPreview != false)
        writer.writeBool(7, this.linkPreview);
    if (this.linkPreviewHighQuality != false)
        writer.writeBool(8, this.linkPreviewHighQuality);
    if (this.replyTo.length)
        writer.writeString(9, this.replyTo);
    if (this.id.length)
        writer.writeString(10, this.id);
    if (this.participants.length)
        writer.writeRepeatedString(11, this.participants);
    if (this.has_preview)
        writer.writeMessage(12, this.preview, () => this.preview.serialize(writer));
    if (this.contacts.length)
        writer.writeRepeatedMessage(13, this.contacts, (item: vCardContact) => item.serialize(writer));
    if (this.has_event)
        writer.writeMessage(14, this.event, () => this.event.serialize(writer));
    if (this.has_poll)
        writer.writeMessage(15, this.poll, () => this.poll.serialize(writer));
    if (!w)
        return writer.getResultBuffer();
}",0,Clean Code
"function run(value: (LegacyHostRule & HostRule)[]): void {
  const newHostRules: HostRule[] = [];
  for (const hostRule of value) {
    validateHostRule(hostRule);
    const newRule: any = {};
    for (const [key, value] of Object.entries(hostRule)) {
      if (key === 'platform') {
        if (isString(value)) {
          newRule.hostType ??= value;
        }
        continue;
      }
      if (key === 'matchHost') {
        if (isString(value)) {
          newRule.matchHost ??= massageHostUrl(value);
        }
        continue;
      }
      if (key === 'hostType') {
        if (isString(value)) {
          newRule.hostType ??= migrateDatasource(value);
        }
        continue;
      }
      if (
        key === 'endpoint' ||
        key === 'host' ||
        key === 'baseUrl' ||
        key === 'hostName' ||
        key === 'domainName'
      ) {
        if (isString(value)) {
          newRule.matchHost ??= massageHostUrl(value);
        }
        continue;
      }
      newRule[key] = value;
    }
    newHostRules.push(newRule);
  }
  this.rewrite(newHostRules);
}",0,Clean Code
"function tokenCmp(left: Token | null, right: Token | null): number {
  if (left === null) {
    if (right?.type === TokenType.String) {
      return 1;
    }
    return -1;
  }
  if (right === null) {
    if (left.type === TokenType.String) {
      return -1;
    }
    return 1;
  }
  if (left.type === TokenType.Number && right.type === TokenType.Number) {
    if (left.val < right.val) {
      return -1;
    }
    if (left.val > right.val) {
      return 1;
    }
  } else if (typeof left.val === 'string' && typeof right.val === 'string') {
    return stringTokenCmp(left.val, right.val);
  } else if (right.type === TokenType.Number) {
    return -1;
  } else if (left.type === TokenType.Number) {
    return 1;
  }
  return 0;
}",0,Clean Code
"export function getServiceIdFromScopes(provider: OAuthProvider, scopes: string[]): string {
  const providerConfig = OAUTH_PROVIDERS[provider]
  if (!providerConfig) {
    return provider
  }
  if (provider === 'google') {
    if (scopes.some((scope) => scope.includes('gmail') || scope.includes('mail'))) {
      return 'gmail'
    }
    if (scopes.some((scope) => scope.includes('drive'))) {
      return 'google-drive'
    }
    if (scopes.some((scope) => scope.includes('docs'))) {
      return 'google-docs'
    }
    if (scopes.some((scope) => scope.includes('sheets'))) {
      return 'google-sheets'
    }
    if (scopes.some((scope) => scope.includes('calendar'))) {
      return 'google-calendar'
    }
  } else if (provider === 'microsoft-teams') {
    return 'microsoft-teams'
  } else if (provider === 'outlook') {
    return 'outlook'
  } else if (provider === 'github') {
    return 'github'
  } else if (provider === 'supabase') {
    return 'supabase'
  } else if (provider === 'x') {
    return 'x'
  } else if (provider === 'confluence') {
    return 'confluence'
  } else if (provider === 'jira') {
    return 'jira'
  } else if (provider === 'airtable') {
    return 'airtable'
  } else if (provider === 'notion') {
    return 'notion'
  } else if (provider === 'discord') {
    return 'discord'
  } else if (provider === 'linear') {
    return 'linear'
  } else if (provider === 'slack') {
    return 'slack'
  } else if (provider === 'reddit') {
    return 'reddit'
  } else if (provider === 'wealthbox') {
    return 'wealthbox'
  }
  return providerConfig.defaultService
}",0,Clean Code
"export const extractErrorMessage = (error: unknown): string => {
  if (!error) return '';
  if (typeof error === 'string') {
    return error;
  }
  if (error instanceof Error && error.message.trim()) {
    return error.message;
  }
  if (typeof error === 'object') {
    const errObject = error as Record<string, unknown>;
    const candidate = errObject.message ?? errObject.error ?? errObject.detail;
    if (typeof candidate === 'string' && candidate.trim()) {
      return candidate;
    }
    const payload = errObject.payload;
    if (typeof payload === 'string' && payload.trim()) {
      return payload;
    }
    if (payload && typeof payload === 'object') {
      const payloadObj = payload as Record<string, unknown>;
      const payloadCandidate =
        payloadObj.message ?? payloadObj.error ?? payloadObj.detail;
      if (typeof payloadCandidate === 'string' && payloadCandidate.trim()) {
        return payloadCandidate;
      }
    }
  }
  return '';
};",0,Clean Code
"window.addEventListener('keydown', (e) => {
  if (!drawingEnabled.value || isInputting.value)
    return
  const noModifier = !e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey
  let handled = true
  if (e.code === 'KeyZ' && (e.ctrlKey || e.metaKey)) {
    if (e.shiftKey)
      drauu.redo()
    else
      drauu.undo()
  }
  else if (e.code === 'Escape') {
    drawingEnabled.value = false
  }
  else if (e.code === 'KeyL' && noModifier) {
    drawingMode.value = 'line'
  }
  else if (e.code === 'KeyA' && noModifier) {
    drawingMode.value = 'arrow'
  }
  else if (e.code === 'KeyS' && noModifier) {
    drawingMode.value = 'stylus'
  }
  else if (e.code === 'KeyR' && noModifier) {
    drawingMode.value = 'rectangle'
  }
  else if (e.code === 'KeyE' && noModifier) {
    drawingMode.value = 'ellipse'
  }
  else if (e.code === 'KeyC' && noModifier) {
    clearDrauu()
  }
  else if (e.code.startsWith('Digit') && noModifier && +e.code[5] <= brushColors.length) {
    brush.color = brushColors[+e.code[5] - 1]
  }
  else {
    handled = false
  }
  if (handled) {
    e.preventDefault()
    e.stopPropagation()
  }
}, false)",0,Clean Code
"export function mergeProviderMeta(
  initialMeta: ProviderMeta | undefined,
  customEndpoints: Record<string, CustomEndpoint> | null | undefined,
): ProviderMeta | undefined {
  const hasCustomEndpoints =
    !!customEndpoints && Object.keys(customEndpoints).length > 0;
  const isExplicitClear =
    customEndpoints !== null &&
    customEndpoints !== undefined &&
    Object.keys(customEndpoints).length === 0;
  if (hasCustomEndpoints) {
    return {
      ...(initialMeta ? { ...initialMeta } : {}),
      custom_endpoints: customEndpoints!,
    };
  }
  if (isExplicitClear) {
    if (!initialMeta) {
      return undefined;
    }
    if ('custom_endpoints' in initialMeta) {
      const { custom_endpoints, ...rest } = initialMeta;
      return Object.keys(rest).length > 0 ? rest : {};
    }

    return { ...initialMeta };
  }
  if (!initialMeta) {
    return undefined;
  }
  if ('custom_endpoints' in initialMeta) {
    const { custom_endpoints, ...rest } = initialMeta;
    return Object.keys(rest).length > 0 ? rest : undefined;
  }
  return { ...initialMeta };
}",0,Clean Code
"(ev, handler) => {
  switch (handler.keys?.join('')) {
    case Hotkeys.ARROW_UP:
    case Hotkeys.ARROW_DOWN: {
      if (filteredItems.length > 0) {
        const direction = handler.keys?.join('') === Hotkeys.ARROW_UP ? -1 : 1
        const newIndex = (selectedIndex + direction + filteredItems.length) % filteredItems.length
        setSelectedIndex(newIndex)
      }
      break
    }
    case Hotkeys.TAB: {
      if (dropdownOpen && filteredItems.length > 0) {
        ev.preventDefault()
        const selected = filteredItems[selectedIndex]
        if (selected) {
          setSearchValue(selected.path)
        }
        setDropdownOpen(false)
      }
      break
    }
    case Hotkeys.ENTER: {
      ev.preventDefault()
      let finalValue = searchValue

      if (dropdownOpen && filteredItems.length > 0 && selectedIndex >= 0) {
        const selected = filteredItems[selectedIndex]
        if (selected) {
          finalValue = selected.path
        }
      }
      setSearchValue(finalValue)
      setDropdownOpen(false)
      if (onSubmit) {
        onSubmit(finalValue)
      }
      break
    }
    case Hotkeys.ESCAPE: {
      ev.stopPropagation()
      setDropdownOpen(false)
      inputRef.current?.blur()
      break
    }
  }
}",0,Clean Code
"function validateVariable(variable: Variable): string | undefined {
  try {
    switch (variable.type) {
      case 'number':
        if (Number.isNaN(Number(variable.value))) {
          return 'Not a valid number'
        }
        break
      case 'boolean':
        if (!/^(true|false)$/i.test(String(variable.value).trim())) {
          return 'Expected `true` or `false`'
        }
        break
      case 'object':
        try {
          const valueToEvaluate = String(variable.value).trim()
          if (!valueToEvaluate.startsWith('{') || !valueToEvaluate.endsWith('}')) {
            return 'Not a valid object format'
          }
          const parsed = new Function(`return ${valueToEvaluate}`)()
          if (parsed === null || typeof parsed !== 'object' || Array.isArray(parsed)) {
            return 'Not a valid object'
          }
          return undefined
        } catch (e) {
          logger.error('Object parsing error:', e)
          return 'Invalid object syntax'
        }
      case 'array':
        try {
          const parsed = JSON.parse(String(variable.value))
          if (!Array.isArray(parsed)) {
            return 'Not a valid JSON array'
          }
        } catch {
          return 'Invalid JSON array syntax'
        }
        break
    }
    return undefined
  } catch (e) {
    return e instanceof Error ? e.message : 'Invalid format'
  }
}",0,Clean Code
"function buildContextInfo(currentValue?: string, generationType?: string): string {
  if (!currentValue || currentValue.trim() === '') {
    return 'no current content'
  }
  const contentLength = currentValue.length
  const lineCount = currentValue.split('\n').length
  let contextInfo = `Current content (${contentLength} characters, ${lineCount} lines):\n${currentValue}`
  if (generationType) {
    switch (generationType) {
      case 'javascript-function-body':
      case 'typescript-function-body': {
        const hasFunction = /function\s+\w+/.test(currentValue)
        const hasArrowFunction = /=>\s*{/.test(currentValue)
        const hasReturn = /return\s+/.test(currentValue)
        contextInfo += `\n\nCode analysis: ${hasFunction ? 'Contains function declaration. ' : ''}${hasArrowFunction ? 'Contains arrow function. ' : ''}${hasReturn ? 'Has return statement.' : 'No return statement.'}`
        break
      }
      case 'json-schema':
      case 'json-object':
        try {
          const parsed = JSON.parse(currentValue)
          const keys = Object.keys(parsed)
          contextInfo += `\n\nJSON analysis: Valid JSON with ${keys.length} top-level keys: ${keys.join(', ')}`
        } catch {
          contextInfo += `\n\nJSON analysis: Invalid JSON - needs fixing`
        }
        break
    }
  }
  return contextInfo
}",0,Clean Code
"inputListener = (key: KeyEvent) => {
  if (key.name === 'g' && currentGenerator) {
    console.log('Generating 100 particles (burst)...')
    currentGenerator.spawnParticles(100).then(() => {
      console.log('Particle burst spawn call completed.')
    })
  }
  if (key.name === 'a' && currentGenerator) {
    console.log('Starting auto-spawn (30 particles/sec)...')
    currentGenerator.setAutoSpawn(AUTO_SPAWN_RATE)
    const configName = configs[currentGeneratorKey as keyof typeof configs].name
    if (configInfoText) {
      configInfoText.content = `Mode: ${configName} | Auto-spawning`
    }
  }
  if (key.name === 's' && currentGenerator) {
    console.log('Stopping auto-spawn...')
    currentGenerator.stopAutoSpawn()
    const configName = configs[currentGeneratorKey as keyof typeof configs].name
    if (configInfoText) {
      configInfoText.content = `Mode: ${configName} | Idle`
    }
  }
  if (key.name === 'x' && currentGenerator) {
    console.log('Clearing all particles...')
    currentGenerator.dispose()
  }
  if (key.name === '1') {
    switchToGenerator('3d-static')
  }
  if (key.name === '2') {
    switchToGenerator('2d-static')
  }
  if (key.name === '3') {
    switchToGenerator('3d-animated')
  }
  if (key.name === '4') {
    configs.custom.params.gravity = new THREE.Vector3(
      0,
      THREE.MathUtils.randFloat(-9.8, 9.8),
      THREE.MathUtils.randFloat(-2.0, 2.0),
    )
    console.log(
      `Custom gravity: Y=${configs.custom.params.gravity.y.toFixed(1)}, Z=${configs.custom.params.gravity.z.toFixed(1)}`,
    )
    switchToGenerator('custom')
  }
  if (key.name === '5') {
    switchToGenerator('2d-animated')
  }
}",0,Clean Code
"useEffect(() => {
  if (isPreview && previewValue !== undefined) {
    const value = previewValue
    if (value && typeof value === 'string') {
      if (isJira) {
        setSelectedIssueId(value)
      } else if (isDiscord) {
        setSelectedChannelId(value)
      } else if (isMicrosoftTeams) {
        setSelectedMessageId(value)
      } else if (isGoogleCalendar) {
        setSelectedCalendarId(value)
      } else if (isWealthbox) {
        setSelectedWealthboxItemId(value)
      } else {
        setSelectedFileId(value)
      }
    }
  } else {
    const value = getValue(blockId, subBlock.id)
    if (value && typeof value === 'string') {
      if (isJira) {
        setSelectedIssueId(value)
      } else if (isDiscord) {
        setSelectedChannelId(value)
      } else if (isMicrosoftTeams) {
        setSelectedMessageId(value)
      } else if (isGoogleCalendar) {
        setSelectedCalendarId(value)
      } else if (isWealthbox) {
        setSelectedWealthboxItemId(value)
      } else {
        setSelectedFileId(value)
      }
    }
  }
}, [isPreview, previewValue])",0,Clean Code
"export function getLabel(block: ComputerToolUseContentBlock) {
  if (isScreenshotToolUseBlock(block)) {
    return 'Screenshot';
  }

  if (isWaitToolUseBlock(block)) {
    return 'Wait';
  }

  if (isTypeKeysToolUseBlock(block)) {
    return 'Keys';
  }

  if (isTypeTextToolUseBlock(block)) {
    return 'Type';
  }

  if (isPasteTextToolUseBlock(block)) {
    return 'Paste';
  }

  if (isPressKeysToolUseBlock(block)) {
    return 'Press Keys';
  }

  if (isMoveMouseToolUseBlock(block)) {
    return 'Move Mouse';
  }

  if (isScrollToolUseBlock(block)) {
    return 'Scroll';
  }

  if (isCursorPositionToolUseBlock(block)) {
    return 'Cursor Position';
  }

  if (isClickMouseToolUseBlock(block)) {
    const button = block.input.button;
    if (button === 'left') {
      if (block.input.clickCount === 2) {
        return 'Double Click';
      }

      if (block.input.clickCount === 3) {
        return 'Triple Click';
      }

      return 'Click';
    }

    return `${block.input.button?.charAt(0).toUpperCase() + block.input.button?.slice(1)} Click`;
  }

  if (isDragMouseToolUseBlock(block)) {
    return 'Drag';
  }

  if (isPressMouseToolUseBlock(block)) {
    return 'Press Mouse';
  }

  if (isTraceMouseToolUseBlock(block)) {
    return 'Trace Mouse';
  }

  if (isApplicationToolUseBlock(block)) {
    return 'Open Application';
  }

  if (isReadFileToolUseBlock(block)) {
    return 'Read File';
  }

  return 'Unknown';
}",0,Clean Code
"function formatValueForCodeContext(
  value: any,
  block: SerializedBlock,
  isInTemplateLiteral = false
): string {
  if (block.metadata?.id === 'function') {
    if (isInTemplateLiteral) {
      if (typeof value === 'string') {
        return value
      }
      if (typeof value === 'object' && value !== null) {
        return JSON.stringify(value)
      }
      return String(value)
    }
    if (typeof value === 'string') {
      return JSON.stringify(value)
    }
    if (typeof value === 'object' && value !== null) {
      return JSON.stringify(value)
    }
    if (value === undefined) {
      return 'undefined'
    }
    if (value === null) {
      return 'null'
    }
    return String(value)
  }
  return typeof value === 'object' && value !== null ? JSON.stringify(value) : String(value)
}",0,Clean Code
"export function matches(v: NugetVersion, r: NugetRange): boolean {
  if (r.type === 'nuget-exact-range') {
    return compare(v, r.version) === 0;
  }
  if (r.type === 'nuget-floating-range') {
    if (!r.prerelease && v.prerelease) {
      return false;
    }
    const lowerBound = getFloatingRangeLowerBound(r);
    return compare(v, lowerBound) >= 0;
  }
  let minBoundMatches = false;
  let maxBoundMatches = false;
  const { min, minInclusive, max, maxInclusive } = r;
  if (min) {
    const minBound =
      min.type === 'nuget-version' ? min : getFloatingRangeLowerBound(min);
    const cmp = compare(v, minBound);
    minBoundMatches = minInclusive ? cmp >= 0 : cmp > 0;
  } else {
    minBoundMatches = true;
  }
  if (max) {
    if (!(v.prerelease && !max.prerelease)) {
      const cmp = compare(v, max);
      maxBoundMatches = maxInclusive ? cmp <= 0 : cmp < 0;
    }
  } else {
    maxBoundMatches = true;
  }
  return minBoundMatches && maxBoundMatches;
}",0,Clean Code
"export function sanitizeValue(
  value: unknown,
  seen = new WeakMap<NestedValue, unknown>(),
): any {
  if (isString(value)) {
    return sanitize(sanitizeUrls(value));
  }
  if (isDate(value)) {
    return value;
  }
  if (isFunction(value)) {
    return '[function]';
  }
  if (isBuffer(value)) {
    return '[content]';
  }
  if (isError(value)) {
    const err = prepareError(value);
    return sanitizeValue(err, seen);
  }
  if (isArray(value)) {
    const length = value.length;
    const arrayResult = Array(length);
    seen.set(value, arrayResult);
    for (let idx = 0; idx < length; idx += 1) {
      const val = value[idx];
      arrayResult[idx] =
        isNested(val) && seen.has(val)
          ? seen.get(val)
          : sanitizeValue(val, seen);
    }
    return arrayResult;
  }
  if (isObject(value)) {
    const objectResult: Record<string, any> = {};
    seen.set(value, objectResult);
    for (const [key, val] of Object.entries<any>(value)) {
      let curValue: any;
      if (!val) {
        curValue = val;
      } else if (redactedFields.includes(key)) {
        if (isString(val) && regEx(/^{{\s*secrets\..*}}$/).test(val)) {
          curValue = val;
        } else {
          curValue = '***********';
        }
      } else if (contentFields.includes(key)) {
        curValue = '[content]';
      } else if (key === 'secrets') {
        curValue = {};
        Object.keys(val).forEach((secretKey) => {
          curValue[secretKey] = '***********';
        });
      } else {
        curValue = seen.has(val) ? seen.get(val) : sanitizeValue(val, seen);
      }

      const sanitizedKey = sanitizeValue(key, seen);
      objectResult[sanitizedKey] = curValue;
    }

    return objectResult;
  }

  return value;
}",0,Clean Code
"function replaceUseId(node: any) {
  const attributesToReplace = ['id', 'for', 'aria-describedby', 'aria-labelledby', 'aria-controls'];
  if (node.nodeType === Node.ELEMENT_NODE) {
    for (const attr of node.attributes) {
      if (attributesToReplace.includes(attr.name)) {
        if (attr.value.includes(':')) {
          node.setAttribute(attr.name, ':mock-test-id:');
        } else if (attr.name === 'id' && attr.value.includes('recharts')) {
          node.setAttribute(attr.name, 'recharts-id');
        }
      }
    }
    if (node.className && typeof node.className === 'string') {
      node.className = node.className.replace(
        /xterm-dom-renderer-owner-\d+/g,
        'xterm-dom-renderer-owner'
      );
    }
  }
  for (const child of node.childNodes) {
    replaceUseId(child);
  }
}",0,Clean Code
"const updatedEntries = state.entries.map((entry) => {
  const isMatch = entry.blockId === blockId && entry.executionId === executionId
  if (isMatch) {
    if (typeof update === 'string') {
      const newOutput = updateBlockOutput(entry.output, update)
      return { ...entry, output: newOutput }
    }
    const updatedEntry = { ...entry }
    if (update.content !== undefined) {
      const newOutput = updateBlockOutput(entry.output, update.content)
      updatedEntry.output = newOutput
    }
    if (update.replaceOutput !== undefined) {
      updatedEntry.output = update.replaceOutput
    } else if (update.output !== undefined) {
      const existingOutput = entry.output || {}
      updatedEntry.output = {
        ...existingOutput,
        ...update.output,
      }
    }
    if (update.error !== undefined) {
      updatedEntry.error = update.error
    }
    if (update.warning !== undefined) {
      updatedEntry.warning = update.warning
    }
    if (update.success !== undefined) {
      updatedEntry.success = update.success
    }
    if (update.endedAt !== undefined) {
      updatedEntry.endedAt = update.endedAt
    }
    if (update.durationMs !== undefined) {
      updatedEntry.durationMs = update.durationMs
    }
    if (update.input !== undefined) {
      updatedEntry.input = update.input
    }
    return updatedEntry
  }
  return entry
})",0,Clean Code
"function parseNoticeExtras(extras: NoticeExtra[]): ParsedNoticeExtras {
  let params: Record<string, unknown> | undefined;
  let raw: unknown;
  let duration: number | undefined;
  for (const extra of extras) {
    if (extra === undefined) continue;
    if (typeof extra === 'number' && duration === undefined) {
      duration = extra;
      continue;
    }
    if (isPlainRecord(extra)) {
      if (!params) {
        params = extra;
        continue;
      }
      if (!raw) {
        raw = extra;
        continue;
      }
    }
    if (!raw) {
      raw = extra;
      continue;
    }
    if (!params && isPlainRecord(extra)) {
      params = extra;
      continue;
    }
    if (duration === undefined && typeof extra === 'number') {
      duration = extra;
    }
  }
  return { params, raw, duration };
}",0,Clean Code
"export function extractPackageFile(
  content: string,
  packageFile: string,
  config: ExtractConfig,
): PackageFileContent | null {
  logger.trace(`vendir.extractPackageFile(${packageFile})`);
  const deps: PackageDependency[] = [];
  const pkg = parseVendir(content, packageFile);
  if (!pkg) {
    return null;
  }
  const contents = pkg.directories.flatMap((directory) => directory.contents);
  for (const content of contents) {
    if ('helmChart' in content && content.helmChart) {
      const dep = extractHelmChart(content.helmChart, config.registryAliases);
      if (dep) {
        deps.push(dep);
      }
    } else if ('git' in content && content.git) {
      const dep = extractGitSource(content.git);
      if (dep) {
        deps.push(dep);
      }
    } else if ('githubRelease' in content && content.githubRelease) {
      const dep = extractGithubReleaseSource(content.githubRelease);
      if (dep) {
        deps.push(dep);
      }
    }
  }
  if (!deps.length) {
    return null;
  }
  return { deps };
}",0,Clean Code
"useEffect(() => {
  if (isEditMode) {
    setCategory(initialCategory);
    return;
  }
  if (selectedPresetId === 'custom') {
    setCategory('custom');
    return;
  }
  if (!selectedPresetId) return;
  const match = selectedPresetId.match(/^(claude|codex|gemini)-(\d+)$/);
  if (!match) return;
  const [, type, indexStr] = match;
  const index = parseInt(indexStr, 10);
  if (type === 'codex' && appId === 'codex') {
    const preset = codexProviderPresets[index];
    if (preset) {
      setCategory(
        preset.category || (preset.isOfficial ? 'official' : undefined),
      );
    }
  } else if (type === 'claude' && appId === 'claude') {
    const preset = providerPresets[index];
    if (preset) {
      setCategory(
        preset.category || (preset.isOfficial ? 'official' : undefined),
      );
    }
  } else if (type === 'gemini' && appId === 'gemini') {
    const preset = geminiProviderPresets[index];
    if (preset) {
      setCategory(preset.category || undefined);
    }
  }
}, [appId, selectedPresetId, isEditMode, initialCategory]);",0,Clean Code
"const handleKeyDown = (event: KeyboardEvent) => {
  if (event.key === 'ArrowUp') {
    event.preventDefault()
    setSelectedIndex(prev => (prev - 1 + results.length) % results.length || 0)
    return true
  }
  if (event.key === 'ArrowDown') {
    event.preventDefault()
    setSelectedIndex(prev => (prev + 1) % results.length)
    return true
  }
  if (event.key === 'Tab' && !event.shiftKey) {
    event.preventDefault()
    setSelectedIndex(prev => (prev + 1) % results.length)
    return true
  }
  if (event.key === 'Tab' && event.shiftKey) {
    event.preventDefault()
    setSelectedIndex(prev => (prev - 1 + results.length) % results.length || 0)
    return true
  }
  if (event.key === 'Enter') {
    event.preventDefault()
    const selected = results[selectedIndex]
    if (selected) {
      handleItemSelection(selected)
    }
    return true
  }
  if (event.key === 'Escape') {
    event.preventDefault()
    return false
  }
  if (event.key === 'Backspace' && query.endsWith('/') && query.length > 0) {
    event.preventDefault()
    const withoutTrailingSlash = query.slice(0, -1)
    const lastSlashIndex = withoutTrailingSlash.lastIndexOf('/')
    const newPath = lastSlashIndex >= 0 ? withoutTrailingSlash.substring(0, lastSlashIndex + 1) : ''
    if (editor) {
      const { state, dispatch } = editor.view
      const { $from } = state.selection
      const mentionStart = $from.pos - query.length - 1
      const mentionEnd = $from.pos
      const tr = state.tr.replaceRangeWith(
        mentionStart,
        mentionEnd,
        state.schema.text(`@${newPath}`),
      )
      dispatch(tr)
    }
    return true
  }
  return false
}",0,Clean Code
"keyListener = (key: KeyEvent) => {
  if (key.name === `p` && engine) {
    engine.saveToFile(`screenshot-${Date.now()}.png`)
  }
  if (key.name === `w`) {
    cameraNode.translateY(0.5)
  } else if (key.name === `s`) {
    cameraNode.translateY(-0.5)
  } else if (key.name === `a`) {
    cameraNode.translateX(-0.5)
  } else if (key.name === `d`) {
    cameraNode.translateX(0.5)
  }
  if (key.name === `q`) {
    cameraNode.rotateY(0.1)
  } else if (key.name === `e`) {
    cameraNode.rotateY(-0.1)
  }
  if (key.name === `z`) {
    cameraNode.translateZ(0.1)
  } else if (key.name === `x`) {
    cameraNode.translateZ(-0.1)
  }
  if (key.name === `r`) {
    cameraNode.position.set(0, 0, 2)
    cameraNode.rotation.set(0, 0, 0)
    cameraNode.quaternion.set(0, 0, 0, 1)
    cameraNode.up.set(0, 1, 0)
    cameraNode.lookAt(0, 0, 0)
  }
  if (key.name === `u` && engine) {
    engine.toggleSuperSampling()
  }
  if (key.name === `i` && engine) {
    const currentAlgorithm = engine.getSuperSampleAlgorithm()
    const newAlgorithm =
      currentAlgorithm === SuperSampleAlgorithm.STANDARD
        ? SuperSampleAlgorithm.PRE_SQUEEZED
        : SuperSampleAlgorithm.STANDARD
    engine.setSuperSampleAlgorithm(newAlgorithm)
  }
  if (key.name === `space`) {
    rotationEnabled = !rotationEnabled
  }
}",0,Clean Code
"transformError: (error) => {
  if (error instanceof Error) {
    return error.message
  }
  if (typeof error === 'object' && error !== null) {
    if (error.error) {
      if (typeof error.error === 'string') {
        return error.error
      }
      if (typeof error.error === 'object' && error.error.message) {
        return error.error.message
      }
      return JSON.stringify(error.error)
    }
    if (error.message) {
      return error.message
    }
    try {
      return `Google Sheets API error: ${JSON.stringify(error)}`
    } catch (_e) {
      return 'Google Sheets API error: Unable to parse error details'
    }
  }
  return 'An error occurred while reading from Google Sheets'
}",0,Clean Code
"export function detectPlatform(
  url: string,
):
  | 'azure'
  | 'bitbucket'
  | 'bitbucket-server'
  | 'forgejo'
  | 'gitea'
  | 'github'
  | 'gitlab'
  | null {
  const { hostname } = parseUrl(url) ?? {};
  if (hostname === 'dev.azure.com' || hostname?.endsWith('.visualstudio.com')) {
    return 'azure';
  }
  if (hostname === 'bitbucket.org' || hostname === 'bitbucket.com') {
    return 'bitbucket';
  }
  if (hostname?.includes('bitbucket')) {
    return 'bitbucket-server';
  }
  if (hostname?.includes('forgejo')) {
    return 'forgejo';
  }
  if (hostname && ['codeberg.org', 'codefloe.com'].includes(hostname)) {
    return 'forgejo';
  }
  if (
    hostname &&
    (['gitea.com'].includes(hostname) || hostname.includes('gitea'))
  ) {
    return 'gitea';
  }
  if (hostname === 'github.com' || hostname?.includes('github')) {
    return 'github';
  }
  if (hostname === 'gitlab.com' || hostname?.includes('gitlab')) {
    return 'gitlab';
  }
  const hostType = hostRules.hostType({ url });
  if (!hostType) {
    return null;
  }
  if (AZURE_API_USING_HOST_TYPES.includes(hostType)) {
    return 'azure';
  }
  if (BITBUCKET_SERVER_API_USING_HOST_TYPES.includes(hostType)) {
    return 'bitbucket-server';
  }
  if (BITBUCKET_API_USING_HOST_TYPES.includes(hostType)) {
    return 'bitbucket';
  }
  if (FORGEJO_API_USING_HOST_TYPES.includes(hostType)) {
    return 'forgejo';
  }
  if (GITEA_API_USING_HOST_TYPES.includes(hostType)) {
    return 'gitea';
  }
  if (GITHUB_API_USING_HOST_TYPES.includes(hostType)) {
    return 'github';
  }
  if (GITLAB_API_USING_HOST_TYPES.includes(hostType)) {
    return 'gitlab';
  }
  return null;
}",0,Clean Code
"constructor(
  messageOrOptions ?: NotificationOptions | NotificationMessageString,
  date ?: OldNotificationDateArg
) {
  if (typeof messageOrOptions === 'string') {
    console.warn(
      `Notification constructor with a string arg is deprecated. Please use NotificationOptions as args instead`
    );
    if (messageOrOptions) {
      this.message = this.prepareMessage(messageOrOptions);
    }
    if (date) {
      this.date = date;
    }
  } else if (messageOrOptions) {
    const { message, date, cluster } = messageOrOptions;
    if (message) {
      this.message = this.prepareMessage(message);
    }
    if (date) {
      if (date instanceof Date) {
        this.date = date.getTime();
      } else {
        this.date = date;
      }
    }
    if (cluster) {
      this.cluster = cluster;
    }
  }
  this.id = btoa(unescape(encodeURIComponent(`${this.date},${this.message},${this.cluster}`)));
}",0,Clean Code
"export function useFormattedHotkey(action: HotkeyAction | null): string[] | null {
  const trigger = action != null ? (hotkeys[action]?.[0] ?? null) : null;
  if (trigger == null) {
    return null;
  }
  const os = type();
  const parts = trigger.split('+');
  const labelParts: string[] = [];
  for (const p of parts) {
    if (os === 'macos') {
      if (p === 'CmdCtrl') {
        labelParts.push('⌘');
      } else if (p === 'Shift') {
        labelParts.push('⇧');
      } else if (p === 'Control') {
        labelParts.push('⌃');
      } else if (p === 'Enter') {
        labelParts.push('↩');
      } else if (p === 'Tab') {
        labelParts.push('⇥');
      } else if (p === 'Backspace') {
        labelParts.push('⌫');
      } else if (p === 'Minus') {
        labelParts.push('-');
      } else if (p === 'Plus') {
        labelParts.push('+');
      } else if (p === 'Equal') {
        labelParts.push('=');
      } else {
        labelParts.push(capitalize(p));
      }
    } else {
      if (p === 'CmdCtrl') {
        labelParts.push('Ctrl');
      } else {
        labelParts.push(capitalize(p));
      }
    }
  }
  if (os === 'macos') {
    return labelParts;
  }
  return [labelParts.join('+')];
}",0,Clean Code
"async function extractLockedVersions(
  project: PyProject,
  deps: PackageDependency[],
  packageFile: string,
): Promise<PackageDependency[]> {
  const lockFileName = await findLocalSiblingOrParent(
    packageFile,
    this.lockfileName,
  );
  if (lockFileName === null) {
    logger.debug({ packageFile }, `No uv lock file found`);
  } else {
    const lockFileContent = await readLocalFile(lockFileName, 'utf8');
    if (lockFileContent) {
      const { val: lockFileMapping, err } = Result.parse(
        lockFileContent,
        UvLockfile,
      ).unwrap();

      if (err) {
        logger.debug({ packageFile, err }, `Error parsing uv lock file`);
      } else {
        for (const dep of deps) {
          const packageName = dep.packageName;
          if (packageName && packageName in lockFileMapping) {
            dep.lockedVersion = lockFileMapping[packageName];
          }
        }
      }
    }
  }
  return Promise.resolve(deps);
}",0,Clean Code
"useKeyboard((key) => {
  if (key.shift && key.name === 'w') {
    key.preventDefault()
    if (textareaRef && !textareaRef.isDestroyed) {
      const currentMode = wrapMode()
      const nextMode = currentMode === 'word' ? 'char' : currentMode === 'char' ? 'none' : 'word'
      setWrapMode(nextMode)
      textareaRef.wrapMode = nextMode
    }
  }
  if (key.name === 'tab') {
    key.preventDefault()
    if (textareaRef && !textareaRef.isDestroyed) {
      const currentStyle = cursorStyle()
      const nextStyle: CursorStyleOptions =
        currentStyle.style === 'block' ? { style: 'line', blinking: false } : { style: 'block', blinking: true }
      setCursorStyle(nextStyle)
      textareaRef.cursorStyle = nextStyle
    }
  }
  if (key.ctrl && (key.name === 'pageup' || key.name === 'pagedown')) {
    key.preventDefault()
    if (textareaRef && !textareaRef.isDestroyed) {
      if (key.name === 'pageup') {
        textareaRef.editBuffer.setCursor(0, 0)
      } else {
        textareaRef.gotoBufferEnd()
      }
    }
  }
})",0,Clean Code
"function handleKeyPress(key: KeyEvent | string): boolean {
  const keyName = typeof key === 'string' ? key : key.name
  const keySequence = typeof key === 'string' ? key : key.sequence
  const keyCtrl = typeof key === 'string' ? false : key.ctrl
  const keyShift = typeof key === 'string' ? false : key.shift
  const keyMeta = typeof key === 'string' ? false : key.meta
  const keySuper = typeof key === 'string' ? false : key.super
  const keyHyper = typeof key === 'string' ? false : key.hyper
  const bindingKey = getKeyBindingKey({
    name: keyName,
    ctrl: keyCtrl,
    shift: keyShift,
    meta: keyMeta,
    super: keySuper,
    action: 'move-left' as TextareaAction,
  })
  const action = this._keyBindingsMap.get(bindingKey)
  if (action) {
    const handler = this._actionHandlers.get(action)
    if (handler) {
      return handler()
    }
  }
  if (keySequence && !keyCtrl && !keyMeta && !keySuper && !keyHyper) {
    const firstCharCode = keySequence.charCodeAt(0)
    if (firstCharCode < 32) {
      return false
    }
    if (firstCharCode === 127) {
      return false
    }
    this.insertText(keySequence)
    return true
  }
  return false
}",0,Clean Code
"export function parseDateRange(value: string, locale = 'en-US', timezone?: string): DateRange {
  if (typeof value !== 'string') {
    return null;
  }
  if (value.startsWith('range')) {
    const [, startTime, endTime] = value.split(':');
    const startDate = new Date(+startTime);
    const endDate = new Date(+endTime);
    const unit = getMinimumUnit(startDate, endDate);
    return {
      startDate,
      endDate,
      value,
      ...parseDateValue(value),
      unit,
    };
  }
  const date = new Date();
  const now = timezone ? utcToZonedTime(date, timezone) : date;
  const dateLocale = getDateLocale(locale);
  const { num = 1, unit } = parseDateValue(value);
  switch (unit) {
    case 'hour':
      return {
        startDate: num ? subHours(startOfHour(now), num) : startOfHour(now),
        endDate: endOfHour(now),
        offset: 0,
        num: num || 1,
        unit,
        value,
      };
    case 'day':
      return {
        startDate: num ? subDays(startOfDay(now), num) : startOfDay(now),
        endDate: endOfDay(now),
        unit: num ? 'day' : 'hour',
        offset: 0,
        num: num || 1,
        value,
      };
    case 'week':
      return {
        startDate: num
          ? subWeeks(startOfWeek(now, { locale: dateLocale }), num)
          : startOfWeek(now, { locale: dateLocale }),
        endDate: endOfWeek(now, { locale: dateLocale }),
        unit: 'day',
        offset: 0,
        num: num || 1,
        value,
      };
    case 'month':
      return {
        startDate: num ? subMonths(startOfMonth(now), num) : startOfMonth(now),
        endDate: endOfMonth(now),
        unit: num ? 'month' : 'day',
        offset: 0,
        num: num || 1,
        value,
      };
    case 'year':
      return {
        startDate: num ? subYears(startOfYear(now), num) : startOfYear(now),
        endDate: endOfYear(now),
        unit: 'month',
        offset: 0,
        num: num || 1,
        value,
      };
  }
}",0,Clean Code
"const handleConfigChange = (value: string) => {
  const nextValue = useToml ? normalizeTomlText(value) : value;
  setFormConfig(nextValue);
  if (useToml) {
    const err = validateTomlConfig(nextValue);
    if (err) {
      setConfigError(err);
      return;
    }
    if (nextValue.trim() && !formId.trim()) {
      const extractedId = extractIdFromToml(nextValue);
      if (extractedId) {
        setFormId(extractedId);
      }
    }
  } else {
    try {
      const result = parseSmartMcpJson(value);
      const configJson = JSON.stringify(result.config);
      const validationErr = validateJsonConfig(configJson);

      if (validationErr) {
        setConfigError(validationErr);
        return;
      }
      if (result.id && !formId.trim() && !isEditing) {
        const uniqueId = ensureUniqueId(result.id);
        setFormId(uniqueId);

        if (!formName.trim()) {
          setFormName(result.id);
        }
      }
      setConfigError('');
    } catch (err: any) {
      const errorMessage = err?.message || String(err);
      setConfigError(t('mcp.error.jsonInvalid') + ': ' + errorMessage);
    }
  }
};",0,Clean Code
"function getResizeDirection(
  mouseX: number,
  mouseY: number,
  boxLeft: number,
  boxTop: number,
  boxWidth: number,
  boxHeight: number,
): 'nw' | 'ne' | 'sw' | 'se' | 'n' | 's' | 'w' | 'e' | null {
  const onLeftBorder = mouseX === boxLeft
  const onRightBorder = mouseX === boxLeft + boxWidth - 1
  const onTopBorder = mouseY === boxTop
  const onBottomBorder = mouseY === boxTop + boxHeight - 1
  const withinHorizontalBounds = mouseX >= boxLeft && mouseX <= boxLeft + boxWidth - 1
  const withinVerticalBounds = mouseY >= boxTop && mouseY <= boxTop + boxHeight - 1
  const left = onLeftBorder && withinVerticalBounds
  const right = onRightBorder && withinVerticalBounds
  const top = onTopBorder && withinHorizontalBounds
  const bottom = onBottomBorder && withinHorizontalBounds
  if (top && left) return 'nw'
  if (top && right) return 'ne'
  if (bottom && left) return 'sw'
  if (bottom && right) return 'se'
  if (top) return 'n'
  if (bottom) return 's'
  if (left) return 'w'
  if (right) return 'e'
  return null
}",0,Clean Code
"function mergeStyles(...styleNames: string[]): MergedStyle {
  this.guard()
  const cacheKey = styleNames.join(`:`)
  const cached = this.mergedCache.get(cacheKey)
  if (cached) return cached
  const styleDefinition: StyleDefinition = {}
  for (const name of styleNames) {
    const style = this.getStyle(name)
    if (!style) continue
    if (style.fg) styleDefinition.fg = style.fg
    if (style.bg) styleDefinition.bg = style.bg
    if (style.bold !== undefined) styleDefinition.bold = style.bold
    if (style.italic !== undefined) styleDefinition.italic = style.italic
    if (style.underline !== undefined) styleDefinition.underline = style.underline
    if (style.dim !== undefined) styleDefinition.dim = style.dim
  }
  const attributes = createTextAttributes({
    bold: styleDefinition.bold,
    italic: styleDefinition.italic,
    underline: styleDefinition.underline,
    dim: styleDefinition.dim,
  })
  const merged: MergedStyle = {
    fg: styleDefinition.fg,
    bg: styleDefinition.bg,
    attributes,
  }
  this.mergedCache.set(cacheKey, merged)
  return merged
}",0,Clean Code
"export function safelyExtractRESTRequest(
  x: unknown,
  defaultReq: HoppRESTRequest
): HoppRESTRequest {
  const req = cloneDeep(defaultReq)
  if (!!x && typeof x === 'object') {
    if ('id' in x && typeof x.id === 'string') req.id = x.id
    if ('name' in x && typeof x.name === 'string') req.name = x.name
    if ('method' in x && typeof x.method === 'string') req.method = x.method
    if ('endpoint' in x && typeof x.endpoint === 'string')
      req.endpoint = x.endpoint
    if ('preRequestScript' in x && typeof x.preRequestScript === 'string')
      req.preRequestScript = x.preRequestScript
    if ('testScript' in x && typeof x.testScript === 'string')
      req.testScript = x.testScript
    if ('body' in x) {
      const result = HoppRESTReqBody.safeParse(x.body)
      if (result.success) {
        req.body = result.data
      }
    }
    if ('auth' in x) {
      const result = HoppRESTAuth.safeParse(x.auth)
      if (result.success) {
        req.auth = result.data
      }
    }
    if ('params' in x) {
      const result = HoppRESTParams.safeParse(x.params)

      if (result.success) {
        req.params = result.data
      }
    }
    if ('headers' in x) {
      const result = HoppRESTHeaders.safeParse(x.headers)
      if (result.success) {
        req.headers = result.data
      }
    }
    if ('requestVariables' in x) {
      const result = HoppRESTRequestVariables.safeParse(x.requestVariables)

      if (result.success) {
        req.requestVariables = result.data
      }
    }
    if ('responses' in x) {
      const result = HoppRESTRequestResponses.safeParse(x.responses)
      if (result.success) {
        req.responses = result.data
      }
    }
  }
  return req
}",0,Clean Code
"const processedLogs = logs.map(log => {
  if (prettifyLogs && hasJsonLogs) {
    try {
      const jsonMatch = log.match(/(\{.*\})/);
      if (!jsonMatch) return log;
      const jsonStr = jsonMatch[1];
      const jsonObj = JSON.parse(jsonStr);
      const valueReplacer = formatJsonValues
        ? (key: string, value: any) =>
          typeof value === 'string' ? unescapeStringLiterals(value) : value
        : undefined;
      const prettyJson = JSON.stringify(jsonObj, valueReplacer, 2);
      const terminalReadyJson = formatJsonValues
        ? unescapeStringLiterals(prettyJson)
        : prettyJson;
      if (showTimestamps) {
        const timestamp = log.slice(0, jsonMatch.index).trim();
        return timestamp ? `${timestamp}\n${terminalReadyJson}\n` : `${terminalReadyJson}\n`;
      } else {
        return `${terminalReadyJson}\n`;
      }
    } catch {
      return log;
    }
  }
  return log;
});",0,Clean Code
"const getSendButtonText = () => {
  if (isDraft) return isLaunchingDraft ? 'Launching...' : 'Launch'
  if (isResponding) return 'Interrupting...'
  if (isDenying) return youSure ? 'Deny?' : 'Deny'
  const isRunning =
    session.status === SessionStatus.Running || session.status === SessionStatus.Starting
  const hasText = !isResponseEditorEmpty
  const canInterrupt = debouncedCanInterrupt 
  if (session.archived && isRunning) {
    return 'Interrupt & Unarchive'
  }
  if (session.archived) return 'Send & Unarchive'
  if (isRunning && !hasText) {
    if (!canInterrupt) return 'Waiting...'
    return 'Interrupt'
  }
  if (isRunning && hasText) {
    return canInterrupt ? 'Interrupt & Send' : 'Waiting...'
  }
  return 'Send'
}",0,Clean Code
"onSessionSettingsChanged: async (data: SessionSettingsChangedEventData) => {
  logger.log('useSessionSubscriptions.onSessionSettingsChanged', data)
  if (
    data.reason === SessionSettingsChangeReason.EXPIRED &&
    data.dangerously_skip_permissions === false
  ) {
    logger.debug('Server disabled expired dangerous skip permissions', {
      sessionId: data.session_id,
      expiredAt: data.expired_at,
    })
  }
  const updates: Record<string, any> = {}
  if (data.auto_accept_edits !== undefined) {
    updates.autoAcceptEdits = data.auto_accept_edits
  }
  if (data.dangerously_skip_permissions !== undefined) {
    updates.dangerouslySkipPermissions = data.dangerously_skip_permissions

    if (data.dangerously_skip_permissions && data.dangerously_skip_permissions_timeout_ms) {
      const expiresAt = new Date(Date.now() + data.dangerously_skip_permissions_timeout_ms)
      updates.dangerouslySkipPermissionsExpiresAt = expiresAt
    } else if (!data.dangerously_skip_permissions) {
      updates.dangerouslySkipPermissionsExpiresAt = undefined
    }
  }
  updateSession(data.session_id, updates)
  if (notificationService) {
    const title = data.dangerously_skip_permissions
      ? 'Bypassing permissions enabled'
      : data.auto_accept_edits
        ? 'Auto-accept edits enabled'
        : 'Auto-accept disabled'
    notificationService.notify({
      type: 'settings_changed',
      title,
      body: data.dangerously_skip_permissions
        ? 'ALL tools will be automatically approved'
        : data.auto_accept_edits
          ? 'Edit, Write, and MultiEdit tools will be automatically approved'
          : 'All tools require manual approval',
      metadata: { sessionId: data.session_id },
    })
  }
}",0,Clean Code
"constructor(data ?: any[] | ({
    name?: string;
    startTime?: number;
    extraGuestsAllowed?: boolean;
    location?: EventLocation;
} & (({
    description?: string;
}) | ({
    endTime?: number;
})))) {
    super();
    pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
    if (!Array.isArray(data) && typeof data == `object`) {
        if (`name` in data && data.name != undefined) {
            this.name = data.name;
        }
        if (`description` in data && data.description != undefined) {
            this.description = data.description;
        }
        if (`startTime` in data && data.startTime != undefined) {
            this.startTime = data.startTime;
        }
        if (`endTime` in data && data.endTime != undefined) {
            this.endTime = data.endTime;
        }
        if (`extraGuestsAllowed` in data && data.extraGuestsAllowed != undefined) {
            this.extraGuestsAllowed = data.extraGuestsAllowed;
        }
        if (`location` in data && data.location != undefined) {
            this.location = data.location;
        }
    }
}",0,Clean Code
"function validateClientSideParams(
  params: Record<string, any>,
  schema: {
    type: string
    properties: Record<string, any>
    required?: string[]
  }
) {
  if (!schema || schema.type !== 'object') {
    throw new Error('Invalid schema format')
  }
  const internalParamSet = new Set(['_context', 'workflowId', 'envVars'])
  if (schema.required) {
    for (const requiredParam of schema.required) {
      if (!(requiredParam in params)) {
        throw new Error(`Required parameter missing: ${requiredParam}`)
      }
    }
  }
  for (const [paramName, paramValue] of Object.entries(params)) {
    if (internalParamSet.has(paramName)) {
      continue
    }
    const paramSchema = schema.properties[paramName]
    if (!paramSchema) {
      throw new Error(`Unknown parameter: ${paramName}`)
    }
    const type = paramSchema.type
    if (type === 'string' && typeof paramValue !== 'string') {
      throw new Error(`Parameter ${paramName} should be a string`)
    }
    if (type === 'number' && typeof paramValue !== 'number') {
      throw new Error(`Parameter ${paramName} should be a number`)
    }
    if (type === 'boolean' && typeof paramValue !== 'boolean') {
      throw new Error(`Parameter ${paramName} should be a boolean`)
    }
    if (type === 'array' && !Array.isArray(paramValue)) {
      throw new Error(`Parameter ${paramName} should be an array`)
    }
    if (type === 'object' && (typeof paramValue !== 'object' || paramValue === null)) {
      throw new Error(`Parameter ${paramName} should be an object`)
    }
  }
}",0,Clean Code
"async (tx) => {
  const isSameCollection = srcCollID === destCollID;
  const isMovingUp = nextRequest?.orderIndex < request.orderIndex;
  const nextReqOrderIndex = nextRequest?.orderIndex;
  const reqCountInDestColl = nextRequest
    ? undefined
    : await this.getRequestsCountInCollection(destCollID);
  if (isSameCollection) {
    const updateFrom = isMovingUp
      ? nextReqOrderIndex
      : request.orderIndex + 1;
    const updateTo = isMovingUp ? request.orderIndex : nextReqOrderIndex;
    await tx.teamRequest.updateMany({
      where: {
        collectionID: srcCollID,
        orderIndex: { gte: updateFrom, lt: updateTo },
      },
      data: {
        orderIndex: isMovingUp ? { increment: 1 } : { decrement: 1 },
      },
    });
  } else {
    await tx.teamRequest.updateMany({
      where: {
        collectionID: srcCollID,
        orderIndex: { gte: request.orderIndex },
      },
      data: { orderIndex: { decrement: 1 } },
    });

    if (nextRequest) {
      await tx.teamRequest.updateMany({
        where: {
          collectionID: destCollID,
          orderIndex: { gte: nextReqOrderIndex },
        },
        data: { orderIndex: { increment: 1 } },
      });
    }
  }
  let adjust: number;
  if (isSameCollection) adjust = nextRequest ? (isMovingUp ? 0 : -1) : 0;
  else adjust = nextRequest ? 0 : 1;
  const newOrderIndex =
    (nextReqOrderIndex ?? reqCountInDestColl) + adjust;
  const updatedRequest = await tx.teamRequest.update({
    where: { id: request.id },
    data: { orderIndex: newOrderIndex, collectionID: destCollID },
  });
  return E.right(updatedRequest);
};",0,Clean Code
"export function asTimestamp(input: unknown): Timestamp | null {
  if (input instanceof Date) {
    const date = DateTime.fromJSDate(input, { zone: 'UTC' });
    if (isValid(date)) {
      return date.toISO() as Timestamp;
    }
    return null;
  }
  if (typeof input === 'number') {
    const millisDate = DateTime.fromMillis(input, { zone: 'UTC' });
    if (isValid(millisDate)) {
      return millisDate.toISO() as Timestamp;
    }
    const secondsDate = DateTime.fromSeconds(input, { zone: 'UTC' });
    if (isValid(secondsDate)) {
      return secondsDate.toISO() as Timestamp;
    }
    return null;
  }
  if (typeof input === 'string') {
    const isoDate = DateTime.fromISO(input, { zone: 'UTC' });
    if (isValid(isoDate)) {
      return isoDate.toISO() as Timestamp;
    }
    const httpDate = DateTime.fromHTTP(input, { zone: 'UTC' });
    if (isValid(httpDate)) {
      return httpDate.toISO() as Timestamp;
    }
    const sqlDate = DateTime.fromSQL(input, { zone: 'UTC' });
    if (isValid(sqlDate)) {
      return sqlDate.toISO() as Timestamp;
    }
    const numberLikeDate = DateTime.fromFormat(input, 'yyyyMMddHHmmss', {
      zone: 'UTC',
    });
    if (isValid(numberLikeDate)) {
      return numberLikeDate.toISO() as Timestamp;
    }
    const numberLikeOffsetDate = DateTime.fromFormat(
      input,
      'yyyyMMddHHmmssZZZ',
      { zone: 'UTC' },
    );
    if (isValid(numberLikeOffsetDate)) {
      return numberLikeOffsetDate.toISO() as Timestamp;
    }
    const fallbackDate = DateTime.fromMillis(
      Date.parse(input) - timezoneOffset,
      { zone: 'UTC' },
    );
    if (isValid(fallbackDate)) {
      return fallbackDate.toISO() as Timestamp;
    }
    return null;
  }
  return null;
}",0,Clean Code
"function calculateAccessibleBlocksLegacy(currentBlockId: string): Set<string> {
  const accessibleBlocks = new Set<string>()
  for (const connection of this.workflow.connections) {
    if (connection.target === currentBlockId) {
      accessibleBlocks.add(connection.source)
    }
  }
  const starterBlock = this.workflow.blocks.find((block) => block.metadata?.id === 'starter')
  if (starterBlock) {
    accessibleBlocks.add(starterBlock.id)
  }
  const currentBlockLoop = this.loopsByBlockId.get(currentBlockId)
  if (currentBlockLoop) {
    const loop = this.workflow.loops?.[currentBlockLoop]
    if (loop) {
      for (const nodeId of loop.nodes) {
        accessibleBlocks.add(nodeId)
      }
    }
  }
  for (const [parallelId, parallel] of Object.entries(this.workflow.parallels || {})) {
    if (parallel.nodes.includes(currentBlockId)) {
      for (const nodeId of parallel.nodes) {
        accessibleBlocks.add(nodeId)
      }
    }
  }
  return accessibleBlocks
}",0,Clean Code
"rendererInstance.keyInput.on('keypress', (key) => {
  if (key.name === 's' && scrollBox) {
    const currentSticky = scrollBox.stickyScroll
    scrollBox.stickyScroll = !currentSticky
    console.log(`Sticky scroll ${!currentSticky ? 'enabled' : 'disabled'}`)
    if (instructionsBox && instructionsBox.getChildren().length >= 3) {
      const statusText = instructionsBox.getChildren()[2] as TextRenderable
      statusText.content = t`${bold(fg('#7aa2f7')('Status:'))} ${fg('#c0caf5')('Sticky Scroll:')} ${(scrollBox as any).stickyScroll ? fg('#9ece6a')('ENABLED') : fg('#f7768e')('DISABLED')}`
    }
  } else if (key.name === 't' && scrollBox) {
    addItem(true)
    console.log('Added item at top')
  } else if (key.name === 'b' && scrollBox) {
    addItem(false)
    console.log('Added item at bottom')
  } else if (key.name === 'e' && scrollBox) {
    clearAllItems()
  }
})",0,Clean Code
"const customEndpointsMap = useMemo(() => {
  const urlSet = new Set<string>();
  const push = (raw?: string) => {
    const url = (raw || '').trim().replace(/\/+$/, '');
    if (url) urlSet.add(url);
  };
  for (const u of draftCustomEndpoints) push(u);
  if (selectedPresetId && selectedPresetId !== 'custom') {
    const entry = presetEntries.find((item) => item.id === selectedPresetId);
    if (entry) {
      const preset = entry.preset as any;
      if (Array.isArray(preset?.endpointCandidates)) {
        for (const u of preset.endpointCandidates as string[]) push(u);
      }
    }
  }
  if (appId === 'codex') {
    push(codexBaseUrl);
  } else {
    push(baseUrl);
  }
  const urls = Array.from(urlSet.values());
  if (urls.length === 0) {
    return null;
  }
  const now = Date.now();
  const customMap: Record<string, CustomEndpoint> = {};
  for (const url of urls) {
    if (!customMap[url]) {
      customMap[url] = { url, addedAt: now, lastUsed: undefined };
    }
  }
  return customMap;
}, []);",0,Clean Code
"transformError: (error) => {
  if (error instanceof Error) {
    return error.message
  }
  if (typeof error === 'object' && error !== null) {
    if (error.error) {
      if (typeof error.error === 'string') {
        return error.error
      }
      if (typeof error.error === 'object' && error.error.message) {
        return error.error.message
      }
      return JSON.stringify(error.error)
    }
    if (error.message) {
      return error.message
    }
    try {
      return `Microsoft Excel API error: ${JSON.stringify(error)}`
    } catch (_e) {
      return 'Microsoft Excel API error: Unable to parse error details'
    }
  }
  return 'An error occurred while reading from Microsoft Excel'
}",0,Clean Code
"function updateSelection(currentRenderable: Renderable | undefined, x: number, y: number): void {
  if (this.currentSelection) {
    this.currentSelection.focus = { x, y }
    if (this.selectionContainers.length > 0) {
      const currentContainer = this.selectionContainers[this.selectionContainers.length - 1]
      if (!currentRenderable || !this.isWithinContainer(currentRenderable, currentContainer)) {
        const parentContainer = currentContainer.parent || this.root
        this.selectionContainers.push(parentContainer)
      } else if (currentRenderable && this.selectionContainers.length > 1) {
        let containerIndex = this.selectionContainers.indexOf(currentRenderable)
        if (containerIndex === -1) {
          const immediateParent = currentRenderable.parent || this.root
          containerIndex = this.selectionContainers.indexOf(immediateParent)
        }
        if (containerIndex !== -1 && containerIndex < this.selectionContainers.length - 1) {
          this.selectionContainers = this.selectionContainers.slice(0, containerIndex + 1)
        }
      }
    }
    this.notifySelectablesOfSelectionChange()
  }
}",0,Clean Code
"renderer.setFrameCallback(async (deltaMs) => {
  const deltaTime = deltaMs / 1000
  time += deltaTime
  const cubeObject = sceneRoot.getObjectByName('cube') as ThreeMesh | undefined
  if (rotationEnabled && cubeObject) {
    cubeObject.rotation.x += rotationSpeed[0] * deltaTime
    cubeObject.rotation.y += rotationSpeed[1] * deltaTime
    cubeObject.rotation.z += rotationSpeed[2] * deltaTime
  }
  if (pointLightNode) {
    const radius = 3
    const speed = 0.9
    pointLightNode.position.set(Math.sin(time * speed) * radius, 1.5, Math.cos(time * speed) * radius)
    const vizObject = sceneRoot.getObjectByName('light_viz')
    if (vizObject) {
      vizObject.position.copy(pointLightNode.position)
    }
  }
  if (cubeObject) {
    let materialIndex = currentMaterial
    if (!manualMaterialSelection) {
      materialIndex = Math.floor(time * 0.5) % (materials.length - 1)
    }
    if (materialIndex < materials.length && cubeObject.material !== materials[materialIndex]) {
      const newMaterialInstance = materials[materialIndex]
      cubeObject.material = newMaterialInstance
      const material = cubeObject.material as MeshPhongMaterial
      material.specularMap = specularMapEnabled ? specularMapTexture : null
      material.normalMap = normalMapEnabled ? normalMapTexture : null
      material.emissiveMap = emissiveMapEnabled ? emissiveMapTexture : null
      material.emissive = new Color(0, 0, 0)
      material.emissiveIntensity = emissiveMapEnabled ? 0.7 : 0.0
      material.needsUpdate = true
    }
  }
  engine.drawScene(sceneRoot, framebuffer, deltaTime)
})",0,Clean Code
"const validateJsonConfig = (value: string): string => {
    const baseErr = validateJson(value);
    if (baseErr) {
      return baseErr;
    }
    if (value.trim()) {
      try {
        const obj = JSON.parse(value);
        if (obj && typeof obj === 'object') {
          if (Object.prototype.hasOwnProperty.call(obj, 'mcpServers')) {
            return t('mcp.error.singleServerObjectRequired');
          }
          const typ = (obj as any)?.type;
          if (typ === 'stdio' && !(obj as any)?.command?.trim()) {
            return t('mcp.error.commandRequired');
          }
          if ((typ === 'http' || typ === 'sse') && !(obj as any)?.url?.trim()) {
            return t('mcp.wizard.urlRequired');
          }
        }
      } catch {}
    }
    return '';
  };",0,Clean Code
"export async function getJavaConstraint(
  gradleVersion: string | null | undefined,
  gradlewFile: string,
): Promise<string> {
  const major = gradleVersion ? gradleVersioning.getMajor(gradleVersion) : null;
  const minor = gradleVersion ? gradleVersioning.getMinor(gradleVersion) : null;
  if (major) {
    if (major > 8 || (major === 8 && minor && minor >= 8)) {
      const toolChainVersion = await getJvmConfiguration(gradlewFile);
      if (toolChainVersion) {
        return `^${toolChainVersion}.0.0`;
      }
    }
    if (major > 6 || (major === 6 && minor && minor >= 7)) {
      const languageVersion = await getJavaLanguageVersion(gradlewFile);
      if (languageVersion) {
        return `^${languageVersion}.0.0`;
      }
    }
    if (major > 8 || (major === 8 && minor && minor >= 5)) {
      return '^21.0.0';
    }
    if (major > 7 || (major === 7 && minor && minor >= 3)) {
      return '^17.0.0';
    }
    if (major === 7) {
      return '^16.0.0';
    }
    if (major > 0 && major < 5) {
      return '^8.0.0';
    }
  }
  return '^11.0.0';
}",0,Clean Code
"const handleExecutionError = (error: any) => {
  let errorMessage = 'Unknown error'
  if (error instanceof Error) {
    errorMessage = error.message || `Error: ${String(error)}`
  } else if (typeof error === 'string') {
    errorMessage = error
  } else if (error && typeof error === 'object') {
    if (
      error.message === 'undefined (undefined)' ||
      (error.error &&
        typeof error.error === 'object' &&
        error.error.message === 'undefined (undefined)')
    ) {
      errorMessage = 'API request failed - no specific error details available'
    } else if (error.message) {
      errorMessage = error.message
    } else if (error.error && typeof error.error === 'string') {
      errorMessage = error.error
    } else if (error.error && typeof error.error === 'object' && error.error.message) {
      errorMessage = error.error.message
    } else {
      try {
        errorMessage = `Error details: ${JSON.stringify(error)}`
      } catch {
        errorMessage = 'Error occurred but details could not be displayed'
      }
    }
  }
  if (errorMessage === 'undefined (undefined)') {
    errorMessage = 'API request failed - no specific error details available'
  }
  const errorResult: ExecutionResult = {
    success: false,
    output: {},
    error: errorMessage,
    logs: [],
  }
  setExecutionResult(errorResult)
  setIsExecuting(false)
  setIsDebugging(false)
  setActiveBlocks(new Set())
  let notificationMessage = 'Workflow execution failed'
  if (error?.request?.url) {
    if (error.request.url && error.request.url.trim() !== '') {
      notificationMessage += `: Request to ${error.request.url} failed`
      if (error.status) {
        notificationMessage += ` (Status: ${error.status})`
      }
    }
  } else {
    notificationMessage += `: ${errorMessage}`
  }
  return errorResult
}",0,Clean Code
"function run(value: unknown): void {
  const packageRules: PackageRule[] = this.get('packageRules') ?? [];
  if (isArray(value)) {
    const fileList: string[] = [];
    for (const packageFile of value) {
      if (
        isNonEmptyObject(packageFile) &&
        'packageFile' in packageFile &&
        isString(packageFile.packageFile)
      ) {
        fileList.push(packageFile.packageFile);
        packageFile.paths = [packageFile.packageFile];
        delete packageFile.packageFile;
        if (Object.keys(packageFile).length > 1) {
          packageRules.push({
            ...packageFile,
          });
        }
      } else if (isArray(packageFile, isString)) {
        fileList.push(...packageFile);
      } else if (isString(packageFile)) {
        fileList.push(packageFile);
      }
    }
    if (fileList.length) {
      this.setSafely('includePaths', fileList);
    }
    if (packageRules.length) {
      this.setSafely('packageRules', packageRules);
    }
  }
}",0,Clean Code
"function updateYogaPosition(position: Position): void {
  const node = this.yogaNode
  const { top, right, bottom, left } = position
  if (isPositionType(top)) {
    if (top === 'auto') {
      node.setPositionAuto(Edge.Top)
    } else {
      node.setPosition(Edge.Top, top)
    }
  }
  if (isPositionType(right)) {
    if (right === 'auto') {
      node.setPositionAuto(Edge.Right)
    } else {
      node.setPosition(Edge.Right, right)
    }
  }
  if (isPositionType(bottom)) {
    if (bottom === 'auto') {
      node.setPositionAuto(Edge.Bottom)
    } else {
      node.setPosition(Edge.Bottom, bottom)
    }
  }
  if (isPositionType(left)) {
    if (left === 'auto') {
      node.setPositionAuto(Edge.Left)
    } else {
      node.setPosition(Edge.Left, left)
    }
  }
  this.requestRender()
}",0,Clean Code
"function getNewValue({
  currentValue,
  rangeStrategy,
  currentVersion,
  newVersion,
}: NewValueConfig): string | null {
  const v = parseVersion(newVersion);
  if (!v) {
    return null;
  }
  if (this.isVersion(currentValue)) {
    return newVersion;
  }
  const r = parseRange(currentValue);
  if (!r) {
    return null;
  }
  if (this.isLessThanRange(newVersion, currentValue)) {
    return currentValue;
  }
  if (r.type === 'nuget-exact-range') {
    return rangeToString({ type: 'nuget-exact-range', version: v });
  }
  if (r.type === 'nuget-floating-range') {
    const floating = r.floating;
    if (!floating) {
      return versionToString(v);
    }
    const res: NugetFloatingRange = { ...r };
    if (floating === 'major') {
      res.major = coerceFloatingComponent(v.major);
      return tryBump(res, v, currentValue);
    }
    res.major = v.major;
    if (floating === 'minor') {
      res.minor = coerceFloatingComponent(v.minor);
      return tryBump(res, v, currentValue);
    }
    res.minor = v.minor ?? 0;
    if (floating === 'patch') {
      res.patch = coerceFloatingComponent(v.patch);
      return tryBump(res, v, currentValue);
    }
    res.patch = v.patch ?? 0;
    res.revision = coerceFloatingComponent(v.revision);
    return tryBump(res, v, currentValue);
  }
  const res: NugetBracketRange = { ...r };
  if (!r.max) {
    res.min = v;
    res.minInclusive = true;
    return rangeToString(res);
  }
  if (matches(v, r)) {
    return currentValue;
  }
  if (!r.min) {
    res.max = v;
    res.maxInclusive = true;
    return rangeToString(res);
  }
  res.max = v;
  res.maxInclusive = true;
  return rangeToString(res);
}",0,Clean Code
"export function writeSettings(settings: Partial<UserSettings>): void {
  try {
    const filePath = getSettingsFilePath();
    const currentSettings = readSettings();
    const newSettings = { ...currentSettings, ...settings };
    if (newSettings.githubAccessToken) {
      newSettings.githubAccessToken = encrypt(
        newSettings.githubAccessToken.value,
      );
    }
    if (newSettings.vercelAccessToken) {
      newSettings.vercelAccessToken = encrypt(
        newSettings.vercelAccessToken.value,
      );
    }
    if (newSettings.supabase) {
      if (newSettings.supabase.accessToken) {
        newSettings.supabase.accessToken = encrypt(
          newSettings.supabase.accessToken.value,
        );
      }
      if (newSettings.supabase.refreshToken) {
        newSettings.supabase.refreshToken = encrypt(
          newSettings.supabase.refreshToken.value,
        );
      }
    }
    if (newSettings.neon) {
      if (newSettings.neon.accessToken) {
        newSettings.neon.accessToken = encrypt(
          newSettings.neon.accessToken.value,
        );
      }
      if (newSettings.neon.refreshToken) {
        newSettings.neon.refreshToken = encrypt(
          newSettings.neon.refreshToken.value,
        );
      }
    }
    for (const provider in newSettings.providerSettings) {
      if (newSettings.providerSettings[provider].apiKey) {
        newSettings.providerSettings[provider].apiKey = encrypt(
          newSettings.providerSettings[provider].apiKey.value,
        );
      }
    }
    const validatedSettings = UserSettingsSchema.parse(newSettings);
    fs.writeFileSync(filePath, JSON.stringify(validatedSettings, null, 2));
  } catch (error) {
    logger.error('Error writing settings:', error);
  }
}",0,Clean Code
"function onLocalSelectionChanged(localSelection: LocalSelectionBounds | null, width: number, height: number): boolean {
  const previousSelection = this.localSelection
  if (!localSelection?.isActive) {
    this.localSelection = null
    return previousSelection !== null
  }
  const text = this.getText()
  const font = this.getFont()
  const selStart = { x: localSelection.anchorX, y: localSelection.anchorY }
  const selEnd = { x: localSelection.focusX, y: localSelection.focusY }
  if (height - 1 < selStart.y || 0 > selEnd.y) {
    this.localSelection = null
    return previousSelection !== null
  }
  let startCharIndex = 0
  let endCharIndex = text.length
  if (selStart.y > height - 1) {
    this.localSelection = null
    return previousSelection !== null
  } else if (selStart.y >= 0 && selStart.y <= height - 1) {
    if (selStart.x > 0) {
      startCharIndex = coordinateToCharacterIndex(selStart.x, text, font)
    }
  }
  if (selEnd.y < 0) {
    this.localSelection = null
    return previousSelection !== null
  } else if (selEnd.y >= 0 && selEnd.y <= height - 1) {
    if (selEnd.x >= 0) {
      endCharIndex = coordinateToCharacterIndex(selEnd.x, text, font)
    } else {
      endCharIndex = 0
    }
  }
  if (startCharIndex < endCharIndex && startCharIndex >= 0 && endCharIndex <= text.length) {
    this.localSelection = { start: startCharIndex, end: endCharIndex }
  } else {
    this.localSelection = null
  }
  return (
    previousSelection?.start !== this.localSelection?.start || previousSelection?.end !== this.localSelection?.end
  )
}",0,Clean Code
"function offsetExcludingNewlines(offset: number): number {
  const text = this.editBuffer.getText()
  let displayWidthSoFar = 0
  let newlineCount = 0
  let i = 0
  while (i < text.length && displayWidthSoFar < offset) {
    if (text[i] === `\n`) {
      displayWidthSoFar++
      newlineCount++
      i++
    } else {
      let j = i
      while (j < text.length && text[j] !== `\n`) {
        j++
      }
      const chunk = text.substring(i, j)
      const chunkWidth = Bun.stringWidth(chunk)
      if (displayWidthSoFar + chunkWidth < offset) {
        displayWidthSoFar += chunkWidth
        i = j
      } else {
        for (let k = i; k < j && displayWidthSoFar < offset; k++) {
          const charWidth = Bun.stringWidth(text[k])
          displayWidthSoFar += charWidth
        }
        break
      }
    }
  }
  return offset - newlineCount
}",0,Clean Code
"React.useEffect(() => {
  const clonedItem = _.cloneDeep(item);
  if (!item || Object.keys(item || {}).length === 0) {
    const defaultCode = '# Enter your YAML or JSON here';
    originalCodeRef.current = { code: defaultCode, format: 'yaml' };
    setCode({ code: defaultCode, format: 'yaml' });
    return;
  }
  if (allowToHideManagedFields && hideManagedFields) {
    if (isKubeObjectIsh(clonedItem) && clonedItem.metadata) {
      delete clonedItem.metadata.managedFields;
    }
  }
  const format = looksLikeJson(originalCodeRef.current.code) ? 'json' : 'yaml';
  const itemCode = format === 'json' ? JSON.stringify(clonedItem) : yaml.dump(clonedItem);
  if (itemCode !== originalCodeRef.current.code) {
    originalCodeRef.current = { code: itemCode, format };
    setCode({ code: itemCode, format });
  }
  if (isKubeObjectIsh(item) && item.metadata) {
    const resourceVersionsDiffer =
      (previousVersionRef.current || '') !== (item.metadata!.resourceVersion || '');
    if (resourceVersionsDiffer || codeRef.current.code === originalCodeRef.current.code) {
      if (codeRef.current.code !== itemCode) {
        setCode({ code: itemCode, format: originalCodeRef.current.format });
      }
      if (resourceVersionsDiffer && !!item.metadata!.resourceVersion) {
        previousVersionRef.current = item.metadata!.resourceVersion;
      }
    }
  }
}, [item, hideManagedFields]);",0,Clean Code
"async () => {
  const resultDoc = []
  for (const docObj of docArr) {
    try {
      const isValidOpenAPISpec =
        objectHasProperty(docObj, 'paths') &&
        (isOpenAPIV2Document(docObj) ||
          isOpenAPIV3Document(docObj) ||
          objectHasProperty(docObj, 'info'))

      if (!isValidOpenAPISpec) {
        throw new Error('INVALID_OPENAPI_SPEC')
      }
      try {
        const validatedDoc = await validateDocs(docObj)
        resultDoc.push(validatedDoc)
      } catch (validationError) {
        if (objectHasProperty(docObj, 'paths')) {
          resultDoc.push(docObj as OpenAPI.Document)
        } else {
          throw validationError
        }
      }
    } catch (err) {
      if (
        err instanceof Error &&
        err.message === 'INVALID_OPENAPI_SPEC'
      ) {
        throw new Error('INVALID_OPENAPI_SPEC')
      }
      if (
        err.files &&
        err.files instanceof SwaggerParser &&
        err.files.schema
      ) {
        resultDoc.push(err.files.schema)
      }
    }
  }
  return resultDoc
}",0,Clean Code
"export function getExtraDeps(
  goModBefore: string,
  goModAfter: string,
  excludeDeps: string[],
): ExtraDep[] {
  const result: ExtraDep[] = [];
  const diff = diffLines(goModBefore, goModAfter, {
    newlineIsToken: true,
  });
  const addDeps: Record<string, string> = {};
  const rmDeps: Record<string, string> = {};
  for (const { added, removed, value } of diff) {
    if (!added && !removed) {
      continue;
    }
    const res = parseLine(value);
    if (!res) {
      continue;
    }
    const { depName, depType, currentValue } = res;
    if (!depName || !currentValue) {
      continue;
    }
    let expandedDepName = depName;
    if (depType === 'toolchain') {
      expandedDepName = `${depName} (${depType})`;
    }
    if (added) {
      addDeps[expandedDepName] = currentValue;
    } else {
      rmDeps[expandedDepName] = currentValue;
    }
  }
  for (const [depName, currentValue] of Object.entries(rmDeps)) {
    if (excludeDeps.includes(depName)) {
      continue;
    }
    const newValue = addDeps[depName];
    if (newValue) {
      result.push({
        depName,
        currentValue,
        newValue,
      });
    }
  }
  return result;
}",0,Clean Code
"function isCompleteCsiSequence(data: string): 'complete' | 'incomplete' {
  if (!data.startsWith(ESC + '[')) {
    return 'complete'
  }
  if (data.length < 3) {
    return 'incomplete'
  }
  const payload = data.slice(2)
  const lastChar = payload[payload.length - 1]
  const lastCharCode = lastChar.charCodeAt(0)
  if (lastCharCode >= 0x40 && lastCharCode <= 0x7e) {
    if (payload.startsWith('<')) {
      const mouseMatch = /^<\d+;\d+;\d+[Mm]$/.test(payload)
      if (mouseMatch) {
        return 'complete'
      }
      if (lastChar === 'M' || lastChar === 'm') {
        const parts = payload.slice(1, -1).split(';')
        if (parts.length === 3 && parts.every((p) => /^\d+$/.test(p))) {
          return 'complete'
        }
      }
      return 'incomplete'
    }
    return 'complete'
  }
  return 'incomplete'
}",0,Clean Code
"transform((pyproject) => {
  const {
    project,
    tool,
    'build-system': poetryRequirement,
    'dependency-groups': dependencyGroups,
  } = pyproject;
  const deps: PackageDependency[] = [];
  const projectDependencies = project?.dependencies;
  if (projectDependencies) {
    deps.push(...projectDependencies);
  }
  const projectOptionalDependencies = project?.['optional-dependencies'];
  if (projectOptionalDependencies) {
    deps.push(...projectOptionalDependencies);
  }
  deps.push(...dependencyGroups);
  const poetryDependencies = tool?.poetry?.dependencies;
  if (poetryDependencies) {
    deps.push(...poetryDependencies);
  }
  const poetryDevDependencies = tool?.poetry?.['dev-dependencies'];
  if (poetryDevDependencies) {
    deps.push(...poetryDevDependencies);
  }
  const poetryGroupDependencies = tool?.poetry?.group;
  if (poetryGroupDependencies) {
    deps.push(...poetryGroupDependencies);
  }
  const packageFileVersion = tool?.poetry?.version;
  const packageFileContent: PackageFileContent = {
    deps,
    packageFileVersion,
  };
  const sourceUrls = tool?.poetry?.source;
  if (sourceUrls) {
    for (const dep of deps) {
      if (dep.managerData?.sourceName) {
        const sourceUrl = sourceUrls.find(
          ({ name }) => name === dep.managerData?.sourceName,
        );
        if (sourceUrl?.url) {
          dep.registryUrls = [sourceUrl.url];
        }
      }
    }
    const sourceUrlsFiltered = sourceUrls.filter(
      ({ priority }) => priority !== 'explicit',
    );
    if (sourceUrlsFiltered.length) {
      packageFileContent.registryUrls = uniq(
        sourceUrlsFiltered.map(({ url }) => url!),
      );
    }
  }
  return { packageFileContent, poetryRequirement };
})",0,Clean Code
"export function getRotatingApiKey(provider: string): string {
  if (provider !== 'openai' && provider !== 'anthropic') {
    throw new Error(`No rotation implemented for provider: ${provider}`)
  }
  const keys = []
  if (provider === 'openai') {
    if (env.OPENAI_API_KEY_1) keys.push(env.OPENAI_API_KEY_1)
    if (env.OPENAI_API_KEY_2) keys.push(env.OPENAI_API_KEY_2)
    if (env.OPENAI_API_KEY_3) keys.push(env.OPENAI_API_KEY_3)
  } else if (provider === 'anthropic') {
    if (env.ANTHROPIC_API_KEY_1) keys.push(env.ANTHROPIC_API_KEY_1)
    if (env.ANTHROPIC_API_KEY_2) keys.push(env.ANTHROPIC_API_KEY_2)
    if (env.ANTHROPIC_API_KEY_3) keys.push(env.ANTHROPIC_API_KEY_3)
  }
  if (keys.length === 0) {
    throw new Error(
      `No API keys configured for rotation. Please configure ${provider.toUpperCase()}_API_KEY_1, ${provider.toUpperCase()}_API_KEY_2, or ${provider.toUpperCase()}_API_KEY_3.`
    )
  }
  const currentMinute = new Date().getMinutes()
  const keyIndex = currentMinute % keys.length
  return keys[keyIndex]
}",0,Clean Code
"export function measureText({ text, font = 'tiny' }: { text: string; font?: keyof typeof fonts }): {
  width: number
  height: number
} {
  const fontDef = getParsedFont(font)
  if (!fontDef) {
    console.warn(`Font '${font}' not found`)
    return { width: 0, height: 0 }
  }
  let currentX = 0
  for (let i = 0; i < text.length; i++) {
    const char = text[i].toUpperCase()
    const charDef = fontDef.chars[char]
    if (!charDef) {
      const spaceChar = fontDef.chars[' ']
      if (spaceChar && spaceChar[0]) {
        let spaceWidth = 0
        for (const segment of spaceChar[0]) {
          spaceWidth += segment.text.length
        }
        currentX += spaceWidth
      } else {
        currentX += 1
      }
      continue
    }
    let charWidth = 0
    if (charDef[0]) {
      for (const segment of charDef[0]) {
        charWidth += segment.text.length
      }
    }
    currentX += charWidth
    if (i < text.length - 1) {
      currentX += fontDef.letterspace_size
    }
  }
  return {
    width: currentX,
    height: fontDef.lines,
  }
}",0,Clean Code
"export function extractLockFileEntries(
  lockFileContent: string,
): Map<string, string> {
  const gemLock = new Map<string, string>();
  try {
    const platforms = extractPlatforms(lockFileContent);
    let inGemSection = false;
    for (const line of lockFileContent.split(newlineRegex)) {
      const trimmed = line.trim();
      const indent = line.indexOf(trimmed);
      if (indent === 0 && trimmed === 'GEM') {
        inGemSection = true;
      } else if (indent === 0 && trimmed && inGemSection) {
        inGemSection = false;
      } else if (indent === 4 && inGemSection) {
        const version = line.match(DEP_REGEX)?.groups?.version;
        if (version) {
          const name = line.replace(`(${version})`, '').trim();
          const cleanedVersion = stripPlatformSuffix(version, platforms);

          if (!gemLock.has(name) && isVersion(cleanedVersion)) {
            gemLock.set(name, cleanedVersion);
          }
        }
      }
    }
  } catch (err) {
    logger.warn({ err }, `Failed to parse Bundler lockfile`);
  }
  return gemLock;
}",0,Clean Code
"function parseV0ExtURL(
  urlParams: Record<string, any>,
  initialReq?: HoppRESTRequest
): HoppRESTRequest {
  const resolvedReq = initialReq ?? getDefaultRESTRequest()
  if (urlParams.method && typeof urlParams.method === 'string') {
    resolvedReq.method = urlParams.method
  }
  if (urlParams.url && typeof urlParams.url === 'string') {
    if (urlParams.path && typeof urlParams.path === 'string') {
      resolvedReq.endpoint = `${urlParams.url}/${urlParams.path}`
    } else {
      resolvedReq.endpoint = urlParams.url
    }
  }
  if (urlParams.headers && typeof urlParams.headers === 'string') {
    resolvedReq.headers = JSON.parse(urlParams.headers)
  }
  if (urlParams.params && typeof urlParams.params === 'string') {
    resolvedReq.params = JSON.parse(urlParams.params)
  }
  if (urlParams.httpUser && typeof urlParams.httpUser === 'string') {
    resolvedReq.auth = {
      authType: 'basic',
      authActive: true,
      username: urlParams.httpUser,
      password: urlParams.httpPassword ?? '',
    }
  }
  if (urlParams.bearerToken && typeof urlParams.bearerToken === 'string') {
    resolvedReq.auth = {
      authType: 'bearer',
      authActive: true,
      token: urlParams.bearerToken,
    }
  }
  if (urlParams.contentType) {
    if (urlParams.contentType === 'multipart/form-data') {
      resolvedReq.body = {
        contentType: 'multipart/form-data',
        body: JSON.parse(urlParams.bodyParams || '[]').map(
          (x: any) =>
            <FormDataKeyValue>{
              active: x.active,
              key: x.key,
              value: x.value,
              isFile: false,
            }
        ),
      }
    } else if (isJSONContentType(urlParams.contentType)) {
      if (urlParams.rawParams) {
        resolvedReq.body = {
          contentType: urlParams.contentType,
          body: urlParams.rawParams,
        }
      } else {
        resolvedReq.body = {
          contentType: urlParams.contentType,
          body: urlParams.bodyParams,
        }
      }
    } else {
      resolvedReq.body = {
        contentType: urlParams.contentType,
        body: urlParams.rawParams,
      }
    }
  }
  return resolvedReq
}",0,Clean Code
"function setProperty(instance: Instance, type: Type, propKey: string, propValue: any, oldPropValue?: any) {
  switch (propKey) {
    case 'onChange':
      if (instance instanceof InputRenderable) {
        initEventListeners(instance, InputRenderableEvents.CHANGE, propValue, oldPropValue)
      } else if (instance instanceof SelectRenderable) {
        initEventListeners(instance, SelectRenderableEvents.SELECTION_CHANGED, propValue, oldPropValue)
      } else if (instance instanceof TabSelectRenderable) {
        initEventListeners(instance, TabSelectRenderableEvents.SELECTION_CHANGED, propValue, oldPropValue)
      }
      break
    case 'onInput':
      if (instance instanceof InputRenderable) {
        initEventListeners(instance, InputRenderableEvents.INPUT, propValue, oldPropValue)
      }
      break
    case 'onSubmit':
      if (instance instanceof InputRenderable) {
        initEventListeners(instance, InputRenderableEvents.ENTER, propValue, oldPropValue)
      }
      break
    case 'onSelect':
      if (instance instanceof SelectRenderable) {
        initEventListeners(instance, SelectRenderableEvents.ITEM_SELECTED, propValue, oldPropValue)
      } else if (instance instanceof TabSelectRenderable) {
        initEventListeners(instance, TabSelectRenderableEvents.ITEM_SELECTED, propValue, oldPropValue)
      }
      break
    case 'focused':
      if (isRenderable(instance)) {
        if (!!propValue) {
          instance.focus()
        } else {
          instance.blur()
        }
      }
      break
    case 'style':
      setStyle(instance, propValue, oldPropValue)
      break
    case 'children':
      break
    default:
      instance[propKey] = propValue
  }
}",0,Clean Code
"async function getUrls(
  searchRoot: string,
  artifactDirs: string[] | null,
  version: string | null,
): Promise<Partial<ReleaseResult>> {
  const result: Partial<ReleaseResult> = {};
  if (!artifactDirs?.length) {
    return result;
  }
  if (!version) {
    return result;
  }
  for (const artifactDir of artifactDirs) {
    const [artifact] = artifactDir.split('_');
    const pomFileNames = [
      `${artifactDir}-${version}.pom`,
      `${artifact}-${version}.pom`,
    ];
    for (const pomFileName of pomFileNames) {
      const pomUrl = `${searchRoot}/${artifactDir}/${version}/${pomFileName}`;
      const content = await downloadHttpContent(this.http, pomUrl);
      if (content) {
        const pomXml = new XmlDocument(content);

        const homepage = pomXml.valueWithPath('url');
        if (homepage) {
          result.homepage = homepage;
        }

        const sourceUrl = pomXml.valueWithPath('scm.url');
        if (sourceUrl) {
          result.sourceUrl = sourceUrl
            .replace(regEx(/^scm:/), '')
            .replace(regEx(/^git:/), '')
            .replace(regEx(/^git@github.com:/), 'https://github.com/')
            .replace(regEx(/\.git$/), '');
        }
        return result;
      }
    }
  }
  return result;
}",1,Code Smell
"function _compare_string(a: string, b: string): number {
  let charPos = 0;
  while (charPos < a.length || charPos < b.length) {
    const aChar = a.charAt(charPos);
    const bChar = b.charAt(charPos);
    if (numericChars.includes(aChar) && numericChars.includes(bChar)) {
      let aNumericEnd = charPos + 1;
      while (numericChars.includes(a.charAt(aNumericEnd))) {
        aNumericEnd += 1;
      }
      let bNumericEnd = charPos + 1;
      while (numericChars.includes(b.charAt(bNumericEnd))) {
        bNumericEnd += 1;
      }
      const numericCmp = a
        .substring(charPos, aNumericEnd)
        .localeCompare(b.substring(charPos, bNumericEnd), undefined, {
          numeric: true,
        });
      if (numericCmp !== 0) {
        return numericCmp;
      }
      charPos = aNumericEnd;
      continue;
    }
    if (aChar !== bChar) {
      const aPriority = characterOrder.indexOf(
        numericChars.includes(aChar) || aChar === '' ? ' ' : aChar,
      );
      const bPriority = characterOrder.indexOf(
        numericChars.includes(bChar) || bChar === '' ? ' ' : bChar,
      );
      return Math.sign(aPriority - bPriority);
    }
    charPos += 1;
  }
  return 0;
}",1,Code Smell
"directExecution: async (params: SupabaseDeleteParams) => {
  try {
    let url = `https://${params.projectId}.supabase.co/rest/v1/${params.table}?select=*`
    if (params.filter?.trim()) {
      url += `&${params.filter.trim()}`
    } else {
      throw new Error(
        'Filter is required for delete operations to prevent accidental deletion of all rows'
      )
    }
    const response = await fetch(url, {
      method: 'DELETE',
      headers: {
        apikey: params.apiKey,
        Authorization: `Bearer ${params.apiKey}`,
        Prefer: 'return=representation',
      },
    })
    if (!response.ok) {
      const errorText = await response.text()
      throw new Error(`Error from Supabase: ${response.status} ${errorText}`)
    }
    const text = await response.text()
    let data
    if (text?.trim()) {
      try {
        data = JSON.parse(text)
      } catch (e) {
        data = text
      }
    } else {
      data = []
    }
    const deletedCount = Array.isArray(data) ? data.length : text ? 1 : 0
    return {
      success: true,
      output: {
        message: `Successfully deleted ${deletedCount === 0 ? 'row(s)' : `${deletedCount} row(s)`} from ${params.table}`,
        results: data,
      },
      error: undefined,
    }
  } catch (error) {
    return {
      success: false,
      output: {
        message: `Error deleting rows from Supabase: ${error instanceof Error ? error.message : String(error)}`,
        results: null,
      },
      error: error instanceof Error ? error.message : String(error),
    }
  }
}",1,Code Smell
"params: (params) => {
  const { credential, operation, properties, filter, sorts, ...rest } = params
  let parsedProperties
  if (
    (operation === 'notion_create_page' || operation === 'notion_create_database') &&
    properties
  ) {
    try {
      parsedProperties = JSON.parse(properties)
    } catch (error) {
      throw new Error(
        `Invalid JSON for properties: ${error instanceof Error ? error.message : String(error)}`
      )
    }
  }
  let parsedFilter
  if (operation === 'notion_query_database' && filter) {
    try {
      parsedFilter = JSON.parse(filter)
    } catch (error) {
      throw new Error(
        `Invalid JSON for filter: ${error instanceof Error ? error.message : String(error)}`
      )
    }
  }
  let parsedSorts
  if (operation === 'notion_query_database' && sorts) {
    try {
      parsedSorts = JSON.parse(sorts)
    } catch (error) {
      throw new Error(
        `Invalid JSON for sorts: ${error instanceof Error ? error.message : String(error)}`
      )
    }
  }
  return {
    ...rest,
    accessToken: credential,
    ...(parsedProperties ? { properties: parsedProperties } : {}),
    ...(parsedFilter ? { filter: JSON.stringify(parsedFilter) } : {}),
    ...(parsedSorts ? { sorts: JSON.stringify(parsedSorts) } : {}),
  }
}",1,Code Smell
"export function handleDepString(ctx: Ctx): Ctx {
  const stringTokens = loadFromTokenMap(ctx, 'templateStringTokens');
  const templateString = interpolateString(stringTokens, ctx);
  if (!templateString) {
    return ctx;
  }
  const dep = parseDependencyString(templateString);
  if (!dep) {
    return ctx;
  }
  let packageFile: string | undefined;
  let fileReplacePosition: number | undefined;
  for (const token of stringTokens) {
    if (token.type === 'symbol') {
      const varData = findVariable(token.value, ctx);
      if (varData) {
        packageFile = varData.packageFile;
        fileReplacePosition = varData.fileReplacePosition;
        if (varData.value === dep.currentValue) {
          dep.managerData = { fileReplacePosition, packageFile };
          dep.sharedVariableName = varData.key;
        }
      }
    }
  }
  if (!dep.managerData) {
    const lastToken = stringTokens[stringTokens.length - 1];
    if (
      lastToken?.type === 'string-value' &&
      dep.currentValue &&
      lastToken.value.includes(dep.currentValue)
    ) {
      packageFile = ctx.packageFile;
      if (stringTokens.length === 1) {
        fileReplacePosition = lastToken.offset + dep.depName!.length + 1;
      } else {
        fileReplacePosition =
          lastToken.offset + lastToken.value.lastIndexOf(dep.currentValue);
      }
      delete dep.sharedVariableName;
    } else {
      dep.skipReason = 'contains-variable';
    }
    dep.managerData = { fileReplacePosition, packageFile };
  }
  ctx.deps.push(dep);
  return ctx;
}",1,Code Smell
"enter(node) {
  if (node.name === 'Tag') {
    if (isSelectionInsideNode(view, node)) return;
    const rawTag = view.state.doc.sliceString(node.from, node.to);
    const inner = rawTag.replace(/^\$\{\[\s*/, '').replace(/\s*]}$/, '');
    let name = inner.match(/([\w.]+)[(]/)?.[1] ?? inner;
    if (inner.includes('\n')) {
      return;
    }
    if (name === 'Response') {
      name = 'response';
    }
    let option = options.find(
      (o) => o.name === name || (o.type === 'function' && o.aliases?.includes(name)),
    );
    if (option == null) {
      const from = node.from;
      option = {
        invalid: true,
        type: 'variable',
        name: inner,
        value: null,
        label: inner,
        onClick: () => {
          onClickMissingVariable(name, rawTag, from);
        },
      };
    }
    let invalid = false;
    if (option.type === 'function') {
      const tokens = parseTemplate(rawTag);
      const values = collectArgumentValues(tokens, option);
      for (const arg of option.args) {
        if (!('optional' in arg)) continue;
        if (!arg.optional && values[arg.name] == null) {
          invalid = true;
          break;
        }
      }
    }
    const widget = new TemplateTagWidget({ ...option, invalid }, rawTag, node.from);
    const deco = Decoration.replace({ widget, inclusive: true });
    widgets.push(deco.range(node.from, node.to));
  }
}",1,Code Smell
"function safeSerialize(obj: any): any {
  if (obj === null || obj === undefined) return null
  if (typeof obj !== 'object') return obj
  if (Array.isArray(obj)) {
    return obj.map((item) => safeSerialize(item))
  }
  const result: Record<string, any> = {}
  for (const key in obj) {
    if (key in obj) {
      const value = obj[key]
      if (
        value === undefined ||
        value === null ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) {
        continue
      }
      try {
        result[key] = safeSerialize(value)
      } catch (_e) {
        try {
          result[key] = String(value)
        } catch (_e2) { }
      }
    }
  }
  return result
}",1,Code Smell
"function updateBlockReferences(
  value: any,
  blockIdMapping: Map<string, string>,
  requestId: string
): any {
  if (typeof value === 'string' && value.includes('<') && value.includes('>')) {
    let processedValue = value
    const blockMatches = value.match(/<([^>]+)>/g)
    if (blockMatches) {
      for (const match of blockMatches) {
        const path = match.slice(1, -1)
        const [blockRef] = path.split('.')
        if (['start', 'loop', 'parallel', 'variable'].includes(blockRef.toLowerCase())) {
          continue
        }
        const newMappedId = blockIdMapping.get(blockRef)
        if (newMappedId) {
          logger.info(`[${requestId}] Updating block reference: ${blockRef} -> ${newMappedId}`)
          processedValue = processedValue.replace(
            new RegExp(`<${blockRef}\\.`, 'g'),
            `<${newMappedId}.`
          )
          processedValue = processedValue.replace(
            new RegExp(`<${blockRef}>`, 'g'),
            `<${newMappedId}>`
          )
        }
      }
    }
    return processedValue
  }
  if (Array.isArray(value)) {
    return value.map((item) => updateBlockReferences(item, blockIdMapping, requestId))
  }
  if (value !== null && typeof value === 'object') {
    const result = { ...value }
    for (const key in result) {
      result[key] = updateBlockReferences(result[key], blockIdMapping, requestId)
    }
    return result
  }
  return value
}",1,Code Smell
"export async function extractAllPackageFiles(
  config: ExtractConfig,
  packageFiles: string[],
): Promise<PackageFile[] | null> {
  const packageFilesByName: Record<string, PackageFile> = {};
  const packageRegistries: PackageRegistry[] = [];
  const extractedDeps: PackageDependency<GradleManagerData>[] = [];
  const kotlinSourceFiles = packageFiles.filter(isKotlinSourceFile);
  const gradleFiles = reorderFiles(
    packageFiles.filter((e) => !kotlinSourceFiles.includes(e)),
  );
  await parsePackageFiles(
    config,
    [...kotlinSourceFiles, ...kotlinSourceFiles, ...gradleFiles],
    extractedDeps,
    packageFilesByName,
    packageRegistries,
  );
  if (!extractedDeps.length) {
    return null;
  }
  for (const dep of extractedDeps) {
    dep.fileReplacePosition = dep?.managerData?.fileReplacePosition;
    const key = dep.managerData?.packageFile;
    if (key) {
      let pkgFile: PackageFile = packageFilesByName[key];
      if (!pkgFile) {
        pkgFile = {
          packageFile: key,
          datasource: mavenDatasource,
          deps: [],
        };
      }
      dep.datasource ??= mavenDatasource;
      if (dep.datasource === mavenDatasource) {
        dep.registryUrls = getRegistryUrlsForDep(packageRegistries, dep);
        dep.depType ??=
          key.startsWith('buildSrc') && !kotlinSourceFiles.length
            ? 'devDependencies'
            : 'dependencies';
      }
      const depAlreadyInPkgFile = pkgFile.deps.some(
        (item) =>
          item.depName === dep.depName &&
          item.managerData?.fileReplacePosition ===
            dep.managerData?.fileReplacePosition,
      );
      if (!depAlreadyInPkgFile) {
        pkgFile.deps.push(dep);
      }
      packageFilesByName[key] = pkgFile;
    } else {
      logger.debug({ dep }, `Failed to process Gradle dependency`);
    }
  }
  return Object.values(packageFilesByName);
}",1,Code Smell
"function _compare_glob(v1: string, v2: string): number {
  if (v1 === v2) {
    return 0;
  }
  const matchesv1 = v1.match(alphaNumPattern) ?? [];
  const matchesv2 = v2.match(alphaNumPattern) ?? [];
  const matches = Math.min(matchesv1.length, matchesv2.length);
  for (let i = 0; i < matches; i++) {
    const matchv1 = matchesv1[i];
    const matchv2 = matchesv2[i];
    if (matchv1?.startsWith('~') || matchv2?.startsWith('~')) {
      if (!matchv1?.startsWith('~')) {
        return 1;
      }
      if (!matchv2?.startsWith('~')) {
        return -1;
      }
    }
    if (isNumericString(matchv1?.[0])) {
      if (!isNumericString(matchv2?.[0])) {
        return 1;
      }
      const result = matchv1.localeCompare(matchv2, undefined, {
        numeric: true,
      });
      if (result === 0) {
        continue;
      }
      return Math.sign(result);
    } else if (isNumericString(matchv2?.[0])) {
      return -1;
    }
    const compared_value = this._compare_string(matchv1, matchv2);
    if (compared_value !== 0) {
      return compared_value;
    }
  }
  if (matchesv1.length === matchesv2.length) {
    return 0;
  }
  if (matchesv1.length > matches && matchesv1[matches].startsWith('~')) {
    return -1;
  }
  if (matchesv2.length > matches && matchesv2[matches].startsWith('~')) {
    return 1;
  }
  return matchesv1.length > matchesv2.length ? 1 : -1;
}",1,Code Smell
"export function extractPackageFile(content: string): PackageFileContent | null {
  const parsed = parseDepsEdnFile(content);
  if (!parsed) {
    return null;
  }
  const { data, metadata } = parsed;
  const deps: PackageDependency[] = [];
  const registryMap: Record<string, string> = {
    clojars: CLOJARS_REPO,
    central: MAVEN_REPO,
  };
  const mavenRepos = data['mvn/repos'];
  if (isPlainObject(mavenRepos)) {
    for (const [repoName, repoSpec] of Object.entries(mavenRepos)) {
      if (isString(repoName)) {
        if (isPlainObject(repoSpec) && isString(repoSpec.url)) {
          registryMap[repoName] = repoSpec.url;
        } else if (isString(repoSpec) && repoSpec === 'nil') {
          delete registryMap[repoName];
        }
      }
    }
  }
  const mavenRegistries: string[] = [...Object.values(registryMap)];
  deps.push(...extractSection(data.deps, metadata, mavenRegistries));
  const aliases = data.aliases;
  if (isPlainObject(aliases)) {
    for (const [depType, aliasSection] of Object.entries(aliases)) {
      if (isPlainObject(aliasSection)) {
        deps.push(
          ...extractSection(
            aliasSection['extra-deps'],
            metadata,
            mavenRegistries,
            depType,
          ),
        );
        deps.push(
          ...extractSection(
            aliasSection['override-deps'],
            metadata,
            mavenRegistries,
            depType,
          ),
        );
      }
    }
  }
  return { deps };
}",1,Code Smell
"const fetchCredentials = useCallback(async () => {
    setIsLoading(true)
    try {
      const response = await fetch(`/api/auth/oauth/credentials?provider=${effectiveProviderId}`)
      if (response.ok) {
        const data = await response.json()
        setCredentials(data.credentials)
        if (selectedId && !data.credentials.some((cred: Credential) => cred.id === selectedId)) {
          setSelectedId('')
          if (!isPreview) {
            setStoreValue('')
          }
        }
        if (
          (!selectedId || !data.credentials.some((cred: Credential) => cred.id === selectedId)) &&
          data.credentials.length > 0
        ) {
          const defaultCred = data.credentials.find((cred: Credential) => cred.isDefault)
          if (defaultCred) {
            setSelectedId(defaultCred.id)
            if (!isPreview) {
              setStoreValue(defaultCred.id)
            }
          } else if (data.credentials.length === 1) {
            setSelectedId(data.credentials[0].id)
            if (!isPreview) {
              setStoreValue(data.credentials[0].id)
            }
          }
        }
      }
    } catch (error) {
      logger.error('Error fetching credentials:', { error })
    } finally {
      setIsLoading(false)
    }
  }, [effectiveProviderId, selectedId, isPreview, setStoreValue])",1,Code Smell
"const loadSnippet = async () => {
  try {
    const snippet = await configApi.getCommonConfigSnippet('codex');
    if (snippet && snippet.trim()) {
      if (mounted) {
        setCommonConfigSnippetState(snippet);
      }
    } else {
      if (typeof window !== 'undefined') {
        try {
          const legacySnippet =
            window.localStorage.getItem(LEGACY_STORAGE_KEY);
          if (legacySnippet && legacySnippet.trim()) {
            await configApi.setCommonConfigSnippet('codex', legacySnippet);
            if (mounted) {
              setCommonConfigSnippetState(legacySnippet);
            }
            window.localStorage.removeItem(LEGACY_STORAGE_KEY);
            console.log(
              '[迁移] Codex 通用配置已从 localStorage 迁移到 config.json',
            );
          }
        } catch (e) {
          console.warn('[迁移] 从 localStorage 迁移失败:', e);
        }
      }
    }
  } catch (error) {
    console.error('加载 Codex 通用配置失败:', error);
  } finally {
    if (mounted) {
      setIsLoading(false);
    }
  }
};",1,Code Smell
"function createSingleConfig(option: RenovateOptions): Record<string, unknown> {
  const temp: Record<string, any> & {
    type?: JsonSchemaType;
  } & Omit<Partial<RenovateOptions>, 'type'> = {};
  if (option.description) {
    temp.description = option.description;
  }
  temp.type = option.type;
  if (option.type === 'array') {
    if (option.subType) {
      temp.items = {
        type: option.subType,
      };
      if (hasKey('format', option) && option.format) {
        temp.items.format = option.format;
      }
      if (option.allowedValues) {
        temp.items.enum = option.allowedValues;
      }
    }
    if (option.subType === 'string' && option.allowString === true) {
      const items = temp.items;
      delete temp.items;
      delete temp.type;
      temp.oneOf = [{ type: 'array', items }, { ...items }];
    }
  } else {
    if (hasKey('format', option) && option.format) {
      temp.format = option.format;
    }
    if (option.name === 'versioning') {
      temp.oneOf = [
        { enum: option.allowedValues },
        { type: 'string', pattern: '^regex:' },
      ];
    } else if (option.allowedValues) {
      temp.enum = option.allowedValues;
    }
  }
  if (option.default !== undefined) {
    temp.default = option.default;
  }
  if (
    hasKey('additionalProperties', option) &&
    option.additionalProperties !== undefined
  ) {
    temp.additionalProperties = option.additionalProperties;
  }
  if (option.default === null) {
    temp.type = [option.type, 'null'];
  }
  if (
    (temp.type === 'object' || temp.type?.includes('object')) &&
    !option.freeChoice
  ) {
    temp.$ref = '#';
  }
  return temp;
}",1,Code Smell
"function autoExtendMavenRange(
  currentRepresentation: string,
  newValue: string,
): string | null {
  const range = parseRange(currentRepresentation);
  if (!range) {
    return currentRepresentation;
  }
  const isPoint = (vals: Range[]): boolean => {
    if (vals.length !== 1) {
      return false;
    }
    const { leftType, leftValue, rightType, rightValue } = vals[0];
    return (
      leftType === 'INCLUDING_POINT' &&
      leftType === rightType &&
      leftValue === rightValue
    );
  };
  if (isPoint(range)) {
    return `[${newValue}]`;
  }
  const interval = [...range].reverse().find((elem) => {
    const { rightType, rightValue } = elem;
    return (
      rightValue === null ||
      (rightType === INCLUDING_POINT && compare(rightValue, newValue) === -1) ||
      (rightType === EXCLUDING_POINT && compare(rightValue, newValue) !== 1)
    );
  });
  if (!interval) {
    return currentRepresentation;
  }
  const { leftValue, rightValue } = interval;
  if (
    leftValue !== null &&
    rightValue !== null &&
    incrementRangeValue(leftValue) === rightValue
  ) {
    if (compare(newValue, leftValue) !== -1) {
      interval.leftValue = coerceRangeValue(leftValue, newValue);
      interval.rightValue = incrementRangeValue(interval.leftValue);
    }
  } else if (rightValue !== null) {
    if (interval.rightType === INCLUDING_POINT) {
      const tokens = tokenize(rightValue);
      const lastToken = tokens[tokens.length - 1];
      if (typeof lastToken.val === 'number') {
        interval.rightValue = coerceRangeValue(rightValue, newValue);
      } else {
        interval.rightValue = newValue;
      }
    } else {
      interval.rightValue = incrementRangeValue(
        coerceRangeValue(rightValue, newValue),
      );
    }
  } else if (leftValue !== null) {
    interval.leftValue = coerceRangeValue(leftValue, newValue);
  }
  return rangeToStr(range);
}",1,Code Smell
"async function processGroupBlock(
    line: string,
    repositoryUrl?: string,
    trimGroupLine = false,
  ): Promise<void> {
    const groupMatch = regEx(/^group\s+(.*?)\s+do/).exec(line);
    if (groupMatch) {
      const depTypes = groupMatch[1]
        .split(',')
        .map((group) => group.trim())
        .map((group) => group.replace(regEx(/^:/), ''));
      const groupLineNumber = lineNumber;
      let groupContent = '';
      let groupLine = '';
      while (
        lineNumber < lines.length &&
        (trimGroupLine ? groupLine.trim() !== 'end' : groupLine !== 'end')
      ) {
        lineNumber += 1;
        groupLine = lines[lineNumber];
        if (!isString(groupLine)) {
          logger.debug(
            { content, packageFile, type: 'groupLine' },
            'Bundler parsing error',
          );
          groupLine = 'end';
        }
        if (trimGroupLine ? groupLine.trim() !== 'end' : groupLine !== 'end') {
          groupContent += formatContent(groupLine);
        }
      }
      const groupRes = await extractPackageFile(groupContent);
      if (groupRes) {
        res.deps = res.deps.concat(
          groupRes.deps.map((dep) => {
            const depObject = {
              ...dep,
              depTypes,
              managerData: {
                lineNumber:
                  Number(dep.managerData?.lineNumber) + groupLineNumber + 1,
              },
            };
            if (repositoryUrl) {
              depObject.registryUrls = [repositoryUrl];
            }
            return depObject;
          }),
        );
      }
    }
  }",1,Code Smell
"function getSimpleHighlights(
  matches: QueryCapture[],
  injectionRanges: Map<string, Array<{ start: number; end: number }>>,
): SimpleHighlight[] {
  const highlights: SimpleHighlight[] = []
  const flatInjectionRanges: Array<{ start: number; end: number; lang: string }> = []
  for (const [lang, ranges] of injectionRanges.entries()) {
    for (const range of ranges) {
      flatInjectionRanges.push({ ...range, lang })
    }
  }
  for (const match of matches) {
    const node = match.node
    let isInjection = false
    let injectionLang: string | undefined
    let containsInjection = false
    for (const injRange of flatInjectionRanges) {
      if (node.startIndex >= injRange.start && node.endIndex <= injRange.end) {
        isInjection = true
        injectionLang = injRange.lang
        break
      } else if (node.startIndex <= injRange.start && node.endIndex >= injRange.end) {
        containsInjection = true
        break
      }
    }
    const matchQuery = (match as any)._injectedQuery
    const patternProperties = matchQuery?.setProperties?.[match.patternIndex]
    const concealValue = patternProperties?.conceal ?? match.setProperties?.conceal
    const concealLines = patternProperties?.conceal_lines ?? match.setProperties?.conceal_lines
    const meta: any = {}
    if (isInjection && injectionLang) {
      meta.isInjection = true
      meta.injectionLang = injectionLang
    }
    if (containsInjection) {
      meta.containsInjection = true
    }
    if (concealValue !== undefined) {
      meta.conceal = concealValue
    }
    if (concealLines !== undefined) {
      meta.concealLines = concealLines
    }
    if (Object.keys(meta).length > 0) {
      highlights.push([node.startIndex, node.endIndex, match.name, meta])
    } else {
      highlights.push([node.startIndex, node.endIndex, match.name])
    }
  }
  highlights.sort((a, b) => a[0] - b[0])
  return highlights
}",1,Code Smell
"export function extractTFLintPlugin(
  startingLine: number,
  lines: string[],
  pluginName: string,
): ExtractionResult {
  let lineNumber = startingLine;
  const deps: PackageDependency[] = [];
  let pluginSource: string | null = null;
  let currentVersion: string | null = null;
  let braceCounter = 0;
  do {
    if (lineNumber > lines.length - 1) {
      logger.debug(`Malformed TFLint configuration file detected.`);
    }
    const line = lines[lineNumber];
    if (isString(line)) {
      const openBrackets = (line.match(regEx(/\{/g)) ?? []).length;
      const closedBrackets = (line.match(regEx(/\}/g)) ?? []).length;
      braceCounter = braceCounter + openBrackets - closedBrackets;
      if (braceCounter === 1) {
        const kvMatch = keyValueExtractionRegex.exec(line);
        if (kvMatch?.groups) {
          if (kvMatch.groups.key === 'version') {
            currentVersion = kvMatch.groups.value;
          } else if (kvMatch.groups.key === 'source') {
            pluginSource = kvMatch.groups.value;
          }
        }
      }
    } else {
      braceCounter = 0;
    }
    lineNumber += 1;
  } while (braceCounter !== 0);
  const dep = analyseTFLintPlugin(pluginSource, currentVersion);
  deps.push(dep);
  lineNumber -= 1;
  return { lineNumber, dependencies: deps };
}",1,Code Smell
"export function getAllTweets(data: TwitterAPIResponse): Tweet[] {
	const tweets: Tweet[] = []
	try {
		const instructions =
			data.data?.bookmark_timeline_v2?.timeline?.instructions ||
			data.data?.bookmark_collection_timeline?.timeline?.instructions ||
			[]
		for (const instruction of instructions) {
			if (instruction.type === `TimelineAddEntries` && instruction.entries) {
				for (const entry of instruction.entries) {
					if (entry.entryId.startsWith(`tweet-`)) {
						const tweet = transformTweetData(entry)
						if (tweet) {
							tweets.push(tweet)
						}
					}
				}
			}
		}
	} catch (error) {
		console.error(`Error extracting tweets:`, error)
	}
	return tweets
}",1,Code Smell
"async function updateYarnOffline(
  lockFileDir: string,
  updatedArtifacts: FileChange[],
): Promise<void> {
  try {
    const resolvedPaths: string[] = [];
    const yarnrcYml = await getFile(upath.join(lockFileDir, '.yarnrc.yml'));
    const yarnrc = await getFile(upath.join(lockFileDir, '.yarnrc'));
    if (yarnrcYml) {
      const paths = getZeroInstallPaths(yarnrcYml);
      resolvedPaths.push(...paths.map((p) => upath.join(lockFileDir, p)));
    } else if (yarnrc) {
      const mirrorLine = yarnrc
        .split(newlineRegex)
        .find((line) => line.startsWith('yarn-offline-mirror '));
      if (mirrorLine) {
        const mirrorPath = ensureTrailingSlash(
          mirrorLine.split(' ')[1].replace(regEx(/`/g), ''),
        );
        resolvedPaths.push(upath.join(lockFileDir, mirrorPath));
      }
    }
    logger.debug({ resolvedPaths }, 'updateYarnOffline resolvedPaths');
    if (resolvedPaths.length) {
      const status = await getRepoStatus();
      for (const f of status.modified.concat(status.not_added)) {
        if (resolvedPaths.some((p) => f.startsWith(p))) {
          updatedArtifacts.push({
            type: 'addition',
            path: f,
            contents: await readLocalFile(f),
          });
        }
      }
      for (const f of status.deleted || []) {
        if (resolvedPaths.some((p) => f.startsWith(p))) {
          updatedArtifacts.push({ type: 'deletion', path: f });
        }
      }
    }
  } catch (err) {
    logger.error({ err }, 'Error updating yarn offline packages');
  }
}",1,Code Smell
"export function instantiate<NodeType extends VNode | Renderable>(
  ctx: RenderContext,
  node: NodeType,
): InstantiateFn<NodeType> {
  if (isRenderable(node)) return node
  if (!node || typeof node !== 'object') {
    throw new TypeError('mount() received an invalid vnode')
  }
  const vnode = node as VNode
  const { type, props } = vnode
  const children = flattenChildren(vnode.children || [])
  const delegateMap = (vnode as any).__delegateMap as Record<string, string> | undefined
  if (isRenderableConstructor(type)) {
    const instance = new type(ctx, (props || {}) as any)
    for (const child of children) {
      if (isRenderable(child)) {
        instance.add(child)
      } else {
        const mounted = instantiate(ctx, child as NodeType)
        instance.add(mounted)
      }
    }
    const delegatedInstance = wrapWithDelegates(instance, delegateMap)
    const pendingCalls = (vnode as any).__pendingCalls as PendingCall[] | undefined
    if (pendingCalls) {
      for (const call of pendingCalls) {
        if (call.isProperty) {
          ;(delegatedInstance as any)[call.method] = call.args[0]
        } else {
          ;(delegatedInstance as any)[call.method].apply(delegatedInstance, call.args)
        }
      }
    }
    return delegatedInstance
  }
  const resolved = (type as FunctionalConstruct)(props || ({} as any), children)
  const inst = instantiate(ctx, resolved)
  return wrapWithDelegates(inst, delegateMap) as InstantiateFn<NodeType>
}",1,Code Smell
"window.addEventListener('message', ({ data }) => {
  if (data && data.target === 'slidev') {
    if (data.type === 'navigate') {
      if (data.no || data.clicks) {
        nav.go(+data.no, +data.clicks || 0)
      }
      else if (typeof data.operation === 'string') {
        const fn = nav[data.operation as keyof typeof nav]
        if (typeof fn === 'function')
          (fn as any)(...(data.args ?? []))
      }
    }
    else if (data.type === 'css-vars') {
      const root = document.documentElement
      for (const [key, value] of Object.entries(data.vars || {}))
        root.style.setProperty(key, value as any)
    }
    else if (data.type === 'color-schema') {
      isDark.value = data.color === 'dark'
    }
  }
})",1,Code Smell
"export async function bake(
  target: string,
  opts: {
    platform?: string;
    version?: SemVer;
    args?: string[];
    delay?: string;
    exitOnError?: boolean;
    tries?: number;
    channel?: string;
  },
): Promise<MetaData | null> {
  if (opts.version) {
    console.log(`Using version: ${opts.version.version}`);
    process.env.RENOVATE_VERSION = opts.version.version;
    if (!opts.version.prerelease.length) {
      process.env.RENOVATE_MAJOR_VERSION = `${opts.version.major}`;
      process.env.RENOVATE_MAJOR_MINOR_VERSION = `${opts.version.major}.${opts.version.minor}`;
    }
  }
  if (opts.channel) {
    process.env.CHANNEL = opts.channel;
  }
  const metadataFile = path.join(await tmp, 'metadata.json');
  const args = [
    'buildx',
    'bake',
    '--file',
    file,
    '--metadata-file',
    metadataFile,
  ];
  if (opts.platform) {
    console.log(`Using platform: ${opts.platform}`);
    args.push('--set', `settings.platform=${opts.platform}`);
  }
  if (Array.isArray(opts.args)) {
    console.log(`Using args: ${opts.args.join(' ')}`);
    args.push(...opts.args);
  }
  args.push(target);
  for (let tries = opts.tries ?? 0; tries >= 0; tries--) {
    const result = exec(`docker`, args);
    if (result.signal) {
      logger.error(`Signal received: ${result.signal}`);
      process.exit(-1);
    } else if (result.status && result.status !== 0) {
      if (tries > 0) {
        logger.debug(`Error occured:\n ${result.stderr}`);
        const delay = opts.delay ? toMs(opts.delay) : null;
        if (delay) {
          logger.info(`Retrying in ${opts.delay} ...`);
          await setTimeout(delay);
        }
      } else {
        logger.error(`Error occured:\n${result.stderr}`);
        if (opts.exitOnError !== false) {
          process.exit(result.status);
        }
        return null;
      }
    } else {
      logger.debug(`${target} succeeded:\n${result.stdout || result.stderr}`);
      break;
    }
  }
  const meta = JSON.parse(await fs.readFile(metadataFile, 'utf8'));
  logger.debug({ meta }, 'metadata');
  return meta;
}",1,Code Smell
"async function getManifestResponse(
  registryHost: string,
  dockerRepository: string,
  tag: string,
  mode: 'head' | 'getText' = 'getText',
): Promise<HttpResponse | null> {
  logger.debug(
    `getManifestResponse(${registryHost}, ${dockerRepository}, ${tag}, ${mode})`,
  );
  try {
    const headers = await getAuthHeaders(
      this.http,
      registryHost,
      dockerRepository,
    );
    if (!headers) {
      logger.warn('No docker auth found - returning');
      return null;
    }
    headers.accept = [
      'application/vnd.docker.distribution.manifest.list.v2+json',
      'application/vnd.docker.distribution.manifest.v2+json',
      'application/vnd.oci.image.manifest.v1+json',
      'application/vnd.oci.image.index.v1+json',
    ].join(', ');
    const url = `${registryHost}/v2/${dockerRepository}/manifests/${tag}`;
    const manifestResponse = await this.http[mode](url, {
      headers,
      noAuth: true,
      cacheProvider: memCacheProvider,
    });
    return manifestResponse;
  } catch (err) {
    if (err instanceof ExternalHostError) {
      throw err;
    }
    if (err.statusCode === 401) {
      logger.debug(
        { registryHost, dockerRepository },
        'Unauthorized docker lookup',
      );
      logger.debug({ err });
      return null;
    }
    if (err.statusCode === 404) {
      logger.debug(
        {
          err,
          registryHost,
          dockerRepository,
          tag,
        },
        'Docker Manifest is unknown',
      );
      return null;
    }
    if (err.statusCode === 429 && isDockerHost(registryHost)) {
      throw new ExternalHostError(err);
    }
    if (err.statusCode >= 500 && err.statusCode < 600) {
      throw new ExternalHostError(err);
    }
    if (err.code === 'ETIMEDOUT') {
      logger.debug(
        { registryHost },
        'Timeout when attempting to connect to docker registry',
      );
      logger.debug({ err });
      return null;
    }
    logger.debug(
      {
        err,
        registryHost,
        dockerRepository,
        tag,
      },
      'Unknown Error looking up docker manifest',
    );
    return null;
  }
}",1,Code Smell
"export function calculateLibYears(
  config: RenovateConfig,
  packageFiles?: Record<string, PackageFile[]>,
): void {
  if (!packageFiles) {
    return;
  }
  const allDeps: DepInfo[] = [];
  for (const [manager, files] of Object.entries(packageFiles)) {
    for (const file of files) {
      for (const dep of file.deps) {
        const depInfo: DepInfo = {
          depName: dep.depName!,
          manager,
          file: file.packageFile,
          datasource: dep.datasource!,
          version: (dep.currentVersion ?? dep.currentValue)!,
        };
        if (!dep.updates?.length) {
          allDeps.push(depInfo);
          continue;
        }
        depInfo.outdated = true;
        if (!dep.currentVersionTimestamp) {
          logger.once.debug(`No currentVersionTimestamp for ${dep.depName}`);
          allDeps.push(depInfo);
          continue;
        }
        const currentVersionDate = DateTime.fromISO(
          dep.currentVersionTimestamp,
        );
        for (const update of dep.updates) {
          if (!update.releaseTimestamp) {
            logger.once.debug(
              `No releaseTimestamp for ${dep.depName} update to ${update.newVersion}`,
            );
            continue;
          }
          const releaseDate = DateTime.fromISO(update.releaseTimestamp);
          const libYears = releaseDate.diff(currentVersionDate, 'years').years;
          if (libYears >= 0) {
            update.libYears = libYears;
          }
        }
        const depLibYears = Math.max(
          ...dep.updates.map((update) => update.libYears ?? 0),
          0,
        );
        depInfo.libYear = depLibYears;
        allDeps.push(depInfo);
      }
    }
  }
  const libYearsWithStatus = getLibYears(allDeps);
  logger.debug(libYearsWithStatus, 'Repository libYears');
  addLibYears(config, libYearsWithStatus);
}

export function calculateLibYears(
  config: RenovateConfig,
  packageFiles?: Record<string, PackageFile[]>,
): void {
  if (!packageFiles) return;

  const allDeps: DepInfo[] = [];

  const versionDate = (ts?: string) =>
    ts ? DateTime.fromISO(ts) : null;

  const computeUpdateLibYears = (dep: any, currentDate: any) => {
    for (const u of dep.updates ?? []) {
      if (!u.releaseTimestamp) {
        logger.once.debug(`No releaseTimestamp for ${dep.depName} update to ${u.newVersion}`);
        continue;
      }
      const rd = versionDate(u.releaseTimestamp);
      if (!rd) continue;
      const y = rd.diff(currentDate, 'years').years;
      if (y >= 0) u.libYears = y;
    }
    return Math.max(...(dep.updates ?? []).map(u => u.libYears ?? 0), 0);
  };

  for (const [manager, files] of Object.entries(packageFiles)) {
    for (const file of files) {
      for (const dep of file.deps) {
        const info: DepInfo = {
          depName: dep.depName!,
          manager,
          file: file.packageFile,
          datasource: dep.datasource!,
          version: (dep.currentVersion ?? dep.currentValue)!,
        };

        const updates = dep.updates;
        if (!updates?.length) {
          allDeps.push(info);
          continue;
        }

        info.outdated = true;

        const currDate = versionDate(dep.currentVersionTimestamp);
        if (!currDate) {
          logger.once.debug(`No currentVersionTimestamp for ${dep.depName}`);
          allDeps.push(info);
          continue;
        }

        info.libYear = computeUpdateLibYears(dep, currDate);
        allDeps.push(info);
      }
    }
  }

  const result = getLibYears(allDeps);
  logger.debug(result, 'Repository libYears');
  addLibYears(config, result);
}",1,Code Smell
"export function extractFieldValues(
  parsedContent: any,
  selectedOutputIds: string[],
  blockId: string
): Record<string, any> {
  const extractedValues: Record<string, any> = {}
  for (const outputId of selectedOutputIds) {
    const blockIdForOutput = extractBlockIdFromOutputId(outputId)
    if (blockIdForOutput !== blockId) {
      continue
    }
    const path = extractPathFromOutputId(outputId, blockIdForOutput)
    if (path) {
      const pathParts = path.split('.')
      let current = parsedContent
      for (const part of pathParts) {
        if (current && typeof current === 'object' && part in current) {
          current = current[part]
        } else {
          current = undefined
          break
        }
      }
      if (current !== undefined) {
        extractedValues[path] = current
      }
    }
  }
  return extractedValues
}",1,Code Smell
"function extractFromSection(
  pubspec: Pubspec,
  sectionKey: keyof Pick<Pubspec, 'dependencies' | 'dev_dependencies'>,
): PackageDependency[] {
  const sectionContent = pubspec[sectionKey];
  if (!sectionContent) {
    return [];
  }
  const skippedPackages = [
    'flutter_driver',
    'flutter_localizations',
    'flutter_test',
    'flutter_web_plugins',
    'meta',
  ];
  const deps: PackageDependency[] = [];
  for (const depName of Object.keys(sectionContent)) {
    if (skippedPackages.includes(depName)) {
      continue;
    }
    let currentValue = sectionContent[depName];
    let skipReason: SkipReason | undefined;
    let registryUrls: string[] | undefined;
    let gitUrl: string | undefined;
    if (!isString(currentValue)) {
      const version = currentValue.version;
      const path = currentValue.path;
      const hosted = currentValue.hosted;
      const git = currentValue.git;
      if (isString(hosted)) {
        registryUrls = [hosted];
      } else if (isString(hosted?.url)) {
        registryUrls = [hosted.url];
      }
      if (isObject(git)) {
        gitUrl = git?.url;
      } else if (isString(git)) {
        gitUrl = git;
      }
      if (version) {
        currentValue = version;
      } else if (path) {
        currentValue = '';
        skipReason = 'path-dependency';
      } else if (isObject(git) && isString(git?.ref)) {
        currentValue = git.ref;
      } else if (isObject(git) && !isString(git?.ref) && !isString(version)) {
        currentValue = '';
        skipReason = 'unspecified-version';
      } else {
        currentValue = '';
      }
    }
    if (gitUrl === undefined) {
      deps.push({
        depName,
        depType: sectionKey,
        currentValue,
        datasource: DartDatasource.id,
        ...(registryUrls && { registryUrls }),
        skipReason,
      });
    } else {
      deps.push({
        depName,
        depType: sectionKey,
        packageName: gitUrl,
        datasource: GitRefsDatasource.id,
        currentValue,
        skipReason,
      });
    }
  }

  return deps;
}",1,Code Smell
"function _processLogEntry(logEntry: [Date, LogLevel, any[], CallerInfo | null]): DisplayLine[] {
  const [date, level, args, callerInfo] = logEntry
  const displayLines: DisplayLine[] = []
  const timestamp = this.formatTimestamp(date)
  const callerSource = callerInfo ? `${callerInfo.fileName}:${callerInfo.lineNumber}` : 'unknown'
  const prefix = `[${timestamp}] [${level}]` + (this._debugModeEnabled ? ` [${callerSource}]` : '') + ' '
  const formattedArgs = this.formatArguments(args)
  const initialLines = formattedArgs.split('\n')
  for (let i = 0; i < initialLines.length; i++) {
    const lineText = initialLines[i]
    const isFirstLineOfEntry = i === 0
    const availableWidth = this.consoleWidth - 1 - (isFirstLineOfEntry ? 0 : INDENT_WIDTH)
    const linePrefix = isFirstLineOfEntry ? prefix : ' '.repeat(INDENT_WIDTH)
    const textToWrap = isFirstLineOfEntry ? linePrefix + lineText : lineText
    let currentPos = 0
    while (currentPos < textToWrap.length || (isFirstLineOfEntry && currentPos === 0 && textToWrap.length === 0)) {
      const segment = textToWrap.substring(currentPos, currentPos + availableWidth)
      const isFirstSegmentOfLine = currentPos === 0
      displayLines.push({
        text: isFirstSegmentOfLine && !isFirstLineOfEntry ? linePrefix + segment : segment,
        level: level,
        indent: !isFirstLineOfEntry || !isFirstSegmentOfLine,
      })
      currentPos += availableWidth
      if (isFirstLineOfEntry && currentPos === 0 && textToWrap.length === 0) break
    }
  }
  return displayLines
}",1,Code Smell
"function rebuildNavStack() {
  if (!schema.value) return
  const newNavStack: ExplorerNavStack = [initialNavStackItem]
  let lastEntity: GraphQLNamedType | GraphQLField<any, any, any> | null = null
  for (const item of navStack.value.slice(1)) {
    if (item.def) {
      if (isNamedType(item.def)) {
        const newType = schema.value.getType(item.def.name)
        if (newType) {
          newNavStack.push({
            name: item.name,
            def: newType,
          })
          lastEntity = newType
        } else {
          break
        }
      } else if (lastEntity === null) {
        break
      } else if (isObjectType(lastEntity) || isInputObjectType(lastEntity)) {
        const field = lastEntity.getFields()[item.name]
        if (field) {
          newNavStack.push({
            name: item.name,
            def: field,
          })
        } else {
          break
        }
      } else if (
        isScalarType(lastEntity) ||
        isEnumType(lastEntity) ||
        isInterfaceType(lastEntity) ||
        isUnionType(lastEntity)
      ) {
        break
      } else {
        const field: GraphQLField<any, any> = lastEntity
        const arg = field.args.find((a) => a.name === item.name)

        if (arg) {
          newNavStack.push({
            name: item.name,
            def: field,
          })
        } else {
          break
        }
      }
    } else {
      lastEntity = null
      newNavStack.push(item)
    }
  }
  navStack.value = newNavStack
}",1,Code Smell
"function findRegion(lines: Array<string>, regionName: string) {
  let chosen: { re: (typeof markers)[number], start: number } | null = null
  for (let i = 0; i < lines.length; i++) {
    for (const re of markers) {
      if (re.start.exec(lines[i])?.[1] === regionName) {
        chosen = { re, start: i + 1 }
        break
      }
    }
    if (chosen)
      break
  }
  if (!chosen)
    return null
  let counter = 1
  for (let i = chosen.start; i < lines.length; i++) {
    if (chosen.re.start.exec(lines[i])?.[1] === regionName) {
      counter++
      continue
    }
    const endRegion = chosen.re.end.exec(lines[i])?.[1]
    if (endRegion === regionName || endRegion === '') {
      if (--counter === 0) {
        return {
          ...chosen,
          end: i,
        }
      }
    }
  }
  return null
}",1,Code Smell
"async function downloadAndCombineQueries(
  filetype: string,
  queryUrls: string[],
  assetsDir: string,
  outputPath: string,
  queryType: 'highlights' | 'injections',
  configPath: string,
): Promise<string> {
  const queriesDir = path.join(assetsDir, filetype)
  const queryPath = path.join(queriesDir, `${queryType}.scm`)
  const queryContents: string[] = []
  for (let i = 0; i < queryUrls.length; i++) {
    const queryUrl = queryUrls[i]
    if (queryUrl.startsWith('./')) {
      console.log(`    Using local query ${i + 1}/${queryUrls.length}: ${queryUrl}`)
      try {
        const localPath = path.resolve(path.dirname(configPath), queryUrl)
        const content = await readFile(localPath, 'utf-8')
        if (content.trim()) {
          queryContents.push(content)
          console.log(`    ✓ Loaded ${content.split('\n').length} lines from local file`)
        }
      } catch (error) {
        console.warn(`Failed to read local query from ${queryUrl}: ${error}`)
        continue
      }
    } else {
      console.log(`    Downloading query ${i + 1}/${queryUrls.length}: ${queryUrl}`)
      try {
        const response = await fetch(queryUrl)
        if (!response.ok) {
          console.warn(`Failed to download query from ${queryUrl}: ${response.statusText}`)
          continue
        }
        const content = await response.text()
        if (content.trim()) {
          queryContents.push(`; Query from: ${queryUrl}\n${content}`)
          console.log(`    ✓ Downloaded ${content.split('\n').length} lines`)
        }
      } catch (error) {
        console.warn(`Failed to download query from ${queryUrl}: ${error}`)
        continue
      }
    }
  }
  const combinedContent = queryContents.join('\n\n')
  await writeFile(queryPath, combinedContent, 'utf-8')
  console.log(`  Combined ${queryContents.length} queries into ${queryPath}`)
  return './' + path.relative(path.dirname(outputPath), queryPath)
}",1,Code Smell
"function getAuthJson(): string | null {
  const authJson: AuthJson = {};
  const githubHostRule = hostRules.find({
    hostType: 'github',
    url: 'https://api.github.com/',
  });
  const gitTagsHostRule = hostRules.find({
    hostType: GitTagsDatasource.id,
    url: 'https://github.com',
  });
  const selectedGithubToken = takePersonalAccessTokenIfPossible(
    isArtifactAuthEnabled(githubHostRule)
      ? findGithubToken(githubHostRule)
      : undefined,
    isArtifactAuthEnabled(gitTagsHostRule)
      ? findGithubToken(gitTagsHostRule)
      : undefined,
  );
  if (selectedGithubToken) {
    authJson['github-oauth'] = {
      'github.com': selectedGithubToken,
    };
  }
  for (const gitlabHostRule of hostRules.findAll({ hostType: 'gitlab' })) {
    if (!isArtifactAuthEnabled(gitlabHostRule)) {
      continue;
    }
    if (gitlabHostRule?.token) {
      const host = coerceString(gitlabHostRule.resolvedHost, 'gitlab.com');
      authJson['gitlab-token'] = authJson['gitlab-token'] ?? {};
      authJson['gitlab-token'][host] = gitlabHostRule.token;
      authJson['gitlab-domains'] = [
        host,
        ...(authJson['gitlab-domains'] ?? []),
      ];
    }
  }
  for (const packagistHostRule of hostRules.findAll({
    hostType: PackagistDatasource.id,
  })) {
    if (!isArtifactAuthEnabled(packagistHostRule)) {
      continue;
    }
    const { resolvedHost, username, password, token } = packagistHostRule;
    if (resolvedHost && username && password) {
      authJson['http-basic'] = authJson['http-basic'] ?? {};
      authJson['http-basic'][resolvedHost] = { username, password };
    } else if (resolvedHost && token) {
      authJson.bearer = authJson.bearer ?? {};
      authJson.bearer[resolvedHost] = token;
    }
  }
  return isEmptyObject(authJson) ? null : JSON.stringify(authJson);
}",1,Code Smell
"setConfig: config => {
  if (config.provider) {
    localStorage.setItem(PROVIDER_KEY, config.provider)
  }
  if (config.model !== undefined) {
    const modelKey =
      config.provider === 'anthropic'
        ? MODEL_KEY
        : config.provider === 'openrouter'
          ? OPENROUTER_MODEL_KEY
          : config.provider === 'baseten'
            ? BASETEN_MODEL_KEY
            : null

    if (modelKey) {
      if (config.model) {
        localStorage.setItem(modelKey, config.model)
      } else {
        localStorage.removeItem(modelKey)
      }
    }
  }
  if (config.openRouterApiKey) {
    localStorage.setItem(OPENROUTER_API_KEY, config.openRouterApiKey)
  } else if (
    config.openRouterApiKey === undefined ||
    config.openRouterApiKey === null ||
    config.openRouterApiKey === ''
  ) {
    localStorage.removeItem(OPENROUTER_API_KEY)
  }
  if (config.basetenApiKey) {
    localStorage.setItem(BASETEN_API_KEY, config.basetenApiKey)
  } else if (
    config.basetenApiKey === undefined ||
    config.basetenApiKey === null ||
    config.basetenApiKey === ''
  ) {
    localStorage.removeItem(BASETEN_API_KEY)
  }
  if (config.additionalDirectories && config.additionalDirectories.length > 0) {
    localStorage.setItem(ADDITIONAL_DIRECTORIES_KEY, JSON.stringify(config.additionalDirectories))
  } else if (
    config.additionalDirectories === undefined ||
    config.additionalDirectories === null ||
    (Array.isArray(config.additionalDirectories) && config.additionalDirectories.length === 0)
  ) {
    localStorage.removeItem(ADDITIONAL_DIRECTORIES_KEY)
  }
  return set({ config, error: undefined })
}",1,Code Smell
"export function takePersonalAccessTokenIfPossible(
  githubToken: string | undefined,
  gitTagsGithubToken: string | undefined,
): string | undefined {
  if (gitTagsGithubToken && isGithubPersonalAccessToken(gitTagsGithubToken)) {
    logger.debug('Using GitHub Personal Access Token (git-tags)');
    return gitTagsGithubToken;
  }
  if (githubToken && isGithubPersonalAccessToken(githubToken)) {
    logger.debug('Using GitHub Personal Access Token');
    return githubToken;
  }
  if (
    gitTagsGithubToken &&
    isGithubFineGrainedPersonalAccessToken(gitTagsGithubToken)
  ) {
    logger.debug('Using GitHub Fine-grained Personal Access Token (git-tags)');
    return gitTagsGithubToken;
  }
  if (githubToken && isGithubFineGrainedPersonalAccessToken(githubToken)) {
    logger.debug('Using GitHub Fine-grained Personal Access Token');
    return githubToken;
  }
  if (gitTagsGithubToken) {
    if (isGithubServerToServerToken(gitTagsGithubToken)) {
      logger.debug('Using GitHub Server-to-Server token (git-tags)');
    } else {
      logger.debug('Using unknown GitHub token type (git-tags)');
    }
    return gitTagsGithubToken;
  }
  if (githubToken) {
    if (isGithubServerToServerToken(githubToken)) {
      logger.debug('Using GitHub Server-to-Server token');
    } else {
      logger.debug('Using unknown GitHub token type');
    }
  }
  return githubToken;
}",1,Code Smell
"export function createAggregatedQuestionEncounter(
  encounters: AggregatableEncounters,
): AggregatedQuestionEncounter {
  const countryCounts: Record<string, CountryInfo> = {};
  const companyCounts: Record<string, number> = {};
  const roleCounts: Record<string, number> = {};
  for (const encounter of encounters) {
    if (encounter.company !== null) {
      if (!(encounter.company.name in companyCounts)) {
        companyCounts[encounter.company!.name] = 0;
      }
      companyCounts[encounter.company!.name] += 1;
    }
    if (encounter.country !== null) {
      if (!(encounter.country.name in countryCounts)) {
        countryCounts[encounter.country.name] = {
          stateInfos: {},
          total: 0,
        };
      }
      const countryInfo = countryCounts[encounter.country.name];
      countryInfo.total += 1;
      const countryStateInfo = countryInfo.stateInfos;
      if (encounter.state !== null) {
        if (!(encounter.state.name in countryStateInfo)) {
          countryStateInfo[encounter.state.name] = {
            cityCounts: {},
            total: 0,
          };
        }
        const stateInfo = countryStateInfo[encounter.state.name];
        stateInfo.total += 1;
        const { cityCounts } = stateInfo;
        if (encounter.city !== null) {
          if (!(encounter.city.name in cityCounts)) {
            cityCounts[encounter.city.name] = 0;
          }
          cityCounts[encounter.city.name] += 1;
        }
      }
    }
    if (!(encounter.role in roleCounts)) {
      roleCounts[encounter.role] = 0;
    }
    roleCounts[encounter.role] += 1;
  }
  return {
    companyCounts,
    countryCounts,
    roleCounts,
  };
}",1,Code Smell
"export function stripTemplates(content: string): string {
  const result: string[] = [];
  const len = content.length;
  let idx = 0;
  let lastPos = 0;
  while (idx < len) {
    if (content[idx] === '{' && idx + 1 < len) {
      let closing: string | undefined;
      let skipLength = 0;
      if (content[idx + 1] === '%') {
        if (idx + 2 < len && content[idx + 2] === '`') {
          closing = '`%}';
          skipLength = 3;
        } else {
          closing = '%}';
          skipLength = 2;
        }
      } else if (content[idx + 1] === '{') {
        if (idx + 2 < len && content[idx + 2] === '`') {
          closing = '`}}';
          skipLength = 3;
        } else {
          closing = '}}';
          skipLength = 2;
        }
      } else if (content[idx + 1] === '#') {
        closing = '#}';
        skipLength = 2;
      }
      if (closing) {
        const end = content.indexOf(closing, idx + skipLength);
        if (end !== -1) {
          if (idx > lastPos) {
            result.push(content.slice(lastPos, idx));
          }
          idx = end + closing.length;
          lastPos = idx;
          continue;
        }
      }
    }
    idx++;
  }
  if (lastPos < len) {
    result.push(content.slice(lastPos));
  }
  return result.join('');
}",1,Code Smell
"export const getIpInfo = async (): Promise<IpInfo> => {
  const maxRetries = 3;
  const serviceTimeout = 5000;
  const overallTimeout = 20000;
  const overallTimeoutController = new AbortController();
  const overallTimeoutId = setTimeout(() => {
    overallTimeoutController.abort();
  }, overallTimeout);
  try {
    const shuffledServices = shuffleServices();
    let lastError: Error | null = null;
    for (const service of shuffledServices) {
      debugLog(`尝试IP检测服务: ${service.url}`);
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        let timeoutId: ReturnType<typeof setTimeout> | null = null;
        try {
          const timeoutController = new AbortController();
          timeoutId = setTimeout(() => {
            timeoutController.abort();
          }, service.timeout || serviceTimeout);
          console.debug(`Fetching IP information...`);
          const response = await fetch(service.url, {
            method: `GET`,
            signal: timeoutController.signal,
            connectTimeout: service.timeout || serviceTimeout,
          });
          const data = await response.json();
          if (timeoutId) clearTimeout(timeoutId);
          if (data && data.ip) {
            debugLog(`IP检测成功，使用服务: ${service.url}`);
            return service.mapping(data);
          } else {
            throw new Error(`无效的响应格式 from ${service.url}`);
          }
        } catch (error: any) {
          if (timeoutId) clearTimeout(timeoutId);
          lastError = error;
          console.warn(
            `尝试 ${attempt + 1}/${maxRetries} 失败 (${service.url}):`,
            error,
          );
          if (error.name === `AbortError`) {
            throw error;
          }
          if (attempt < maxRetries - 1) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
          }
        }
      }
    }
    if (lastError) {
      throw new Error(`所有IP检测服务都失败: ${lastError.message}`);
    } else {
      throw new Error(`没有可用的IP检测服务`);
    }
  } finally {
    clearTimeout(overallTimeoutId);
  }
};",1,Code Smell
"function findCodeBlocks(docText: string): CodeBlockInfo[] {
  const lines = docText.split(/\r?\n/)
  const codeBlocks: CodeBlockInfo[] = []
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]
    const trimmedLine = line.trimStart()
    if (trimmedLine.startsWith('```')) {
      const indent = line.slice(0, line.length - trimmedLine.length)
      const codeBlockLevel = line.match(/^\s*`+/)![0]
      const backtickCount = codeBlockLevel.trim().length
      const startLine = i
      if (backtickCount !== 3) {
        continue
      }
      let endLine = i
      for (let j = i + 1; j < lines.length; j++) {
        if (lines[j].startsWith(codeBlockLevel)) {
          endLine = j
          break
        }
      }
      if (endLine > startLine) {
        codeBlocks.push({
          startLine: startLine + 1,
          endLine,
          indent,
        })
      }
      i = endLine
    }
  }
  return codeBlocks
}",1,Code Smell
"export function find(search: HostRuleSearch): CombinedHostRule {
  if ([search.hostType, search.url].every(isFalsy)) {
    logger.warn({ search }, 'Invalid hostRules search');
    return {};
  }
  const sortedRules = hostRules
    .sort(fromShorterToLongerMatchHost)
    .sort(fromLowerToHigherRank);
  const matchedRules: HostRule[] = [];
  for (const rule of sortedRules) {
    let hostTypeMatch = true;
    let hostMatch = true;
    let readOnlyMatch = true;
    if (rule.hostType) {
      hostTypeMatch = false;
      if (search.hostType === rule.hostType) {
        hostTypeMatch = true;
      }
    }
    if (rule.matchHost && rule.resolvedHost) {
      hostMatch = false;
      if (search.url) {
        hostMatch = matchesHost(search.url, rule.matchHost);
      }
    }
    if (!isUndefined(rule.readOnly)) {
      readOnlyMatch = false;
      if (search.readOnly === rule.readOnly) {
        readOnlyMatch = true;
        hostTypeMatch = true;
      }
    }
    if (hostTypeMatch && readOnlyMatch && hostMatch) {
      matchedRules.push(clone(rule));
    }
  }
  const res: HostRule = Object.assign({}, ...matchedRules);
  delete res.hostType;
  delete res.resolvedHost;
  delete res.matchHost;
  delete res.readOnly;
  return res;
}",1,Code Smell
"export function findExtents(indent: number, content: string): number {
  let blockIdx = 0;
  let mode: 'finding-newline' | 'finding-indention' = 'finding-newline';
  for (;;) {
    if (mode === 'finding-newline') {
      while (content[blockIdx++] !== '\n') {
        if (blockIdx >= content.length) {
          break;
        }
      }
      if (blockIdx >= content.length) {
        return content.length;
      }
      mode = 'finding-indention';
    } else {
      let thisIndent = 0;
      for (;;) {
        if ([' ', '\t'].includes(content[blockIdx])) {
          thisIndent += 1;
          blockIdx++;
          if (blockIdx >= content.length) {
            return content.length;
          }
          continue;
        }
        mode = 'finding-newline';
        blockIdx++;
        break;
      }
      if (thisIndent < indent) {
        if (content.slice(blockIdx - 1, blockIdx + 1) === '--') {
          mode = 'finding-newline';
          continue;
        }
        for (;;) {
          if (content[blockIdx--] === '\n') {
            break;
          }
        }
        return blockIdx + 1;
      }
      mode = 'finding-newline';
    }
  }
}",1,Code Smell
"export function resolvedModelName(r: AnyModel | null): string {
  if (r == null) return '';
  if (!('url' in r) || r.model === 'plugin') {
    return 'name' in r ? r.name : '';
  }
  if ('name' in r && r.name) {
    return r.name;
  }
  const withoutVariables = r.url.replace(/\$\{\[\s*([^\]\s]+)\s*]}/g, '$1');
  if (withoutVariables.trim() === '') {
    return r.model === 'http_request'
      ? r.bodyType && r.bodyType === 'graphql'
        ? 'GraphQL Request'
        : 'HTTP Request'
      : r.model === 'websocket_request'
        ? 'WebSocket Request'
        : 'gRPC Request';
  }
  if (r.model === 'grpc_request' && r.service != null && r.method != null) {
    const shortService = r.service.split('.').pop();
    return `${shortService}/${r.method}`;
  }
  const withoutProto = withoutVariables.replace(/^(http|https|ws|wss):\/\//, '');
  return withoutProto;
}",1,Code Smell
"params: (params) => {
  const {
    credential,
    authMethod,
    botToken,
    operation,
    channel,
    manualChannel,
    title,
    content,
    limit,
    oldest,
    ...rest
  } = params
  const effectiveChannel = (channel || manualChannel || '').trim()
  if (!effectiveChannel) {
    throw new Error(
      'Channel is required. Please select a channel or enter a channel ID manually.'
    )
  }
  const baseParams: Record<string, any> = {
    channel: effectiveChannel,
  }
  if (authMethod === 'bot_token') {
    if (!botToken) {
      throw new Error('Bot token is required when using bot token authentication')
    }
    baseParams.accessToken = botToken
  } else {
    if (!credential) {
      throw new Error('Slack account credential is required when using Sim Bot')
    }
    baseParams.credential = credential
  }
  switch (operation) {
    case 'send':
      if (!rest.text) {
        throw new Error('Message text is required for send operation')
      }
      baseParams.text = rest.text
      break
    case 'canvas':
      if (!title || !content) {
        throw new Error('Title and content are required for canvas operation')
      }
      baseParams.title = title
      baseParams.content = content
      break
    case 'read':
      if (limit) {
        const parsedLimit = Number.parseInt(limit, 10)
        baseParams.limit = !Number.isNaN(parsedLimit) ? parsedLimit : 10
      } else {
        baseParams.limit = 10
      }
      if (oldest) {
        baseParams.oldest = oldest
      }
      break
  }
  return baseParams
}",1,Code Smell
"function aggregateTypeInfo(value: any, node: TypeInfoNode, parentObjectCount: number): void {
  node.presenceCount++;
  node.parentObjectCount = parentObjectCount;
  const type = typeof value;
  if (value === null) {
    node.primitiveTypes.add('null');
  } else if (type === 'string') {
    node.hasStringType = true;
    node.primitiveTypes.add('string');
    if (node.stringLiterals.size < MAX_STRING_LITERALS) {
      if (value.length < MAX_STRING_LITERAL_LENGTH) {
        node.stringLiterals.add(value);
      }
    } else {
      node.stringLiterals.clear();
    }
  } else if (type === 'number') {
    node.primitiveTypes.add('number');
  } else if (type === 'boolean') {
    node.primitiveTypes.add('boolean');
  } else if (Array.isArray(value)) {
    node.isArray = true;
    if (!node.arrayElementInfo) {
      node.arrayElementInfo = createTypeInfoNode();
    }
    const arrayPresenceCount = node.presenceCount;
    value.forEach(element => {
      aggregateTypeInfo(element, node.arrayElementInfo!, arrayPresenceCount);
    });
    if (node.arrayElementInfo) node.arrayElementInfo.parentObjectCount = arrayPresenceCount;
  } else if (type === 'object') {
    node.isObject = true;
    const numObjectOccurrences = node.presenceCount;
    const currentKeys = new Set<string>();

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        currentKeys.add(key);
        if (!node.objectProperties.has(key)) {
          node.objectProperties.set(key, createTypeInfoNode());
        }
        const propertyNode = node.objectProperties.get(key)!;
        aggregateTypeInfo(value[key], propertyNode, numObjectOccurrences);
      }
    }
    node.objectProperties.forEach((propNode, key) => {
      if (!currentKeys.has(key)) {
        propNode.parentObjectCount = numObjectOccurrences;
      }
    });
  }
}",1,Code Smell
"export function parseEnvFile(content: string): EnvVar[] {
  const envVars: EnvVar[] = [];
  const lines = content.split(`\n`);
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine || trimmedLine.startsWith(`#`)) {
      continue;
    }
    const equalIndex = trimmedLine.indexOf(`=`);
    if (equalIndex > 0) {
      const key = trimmedLine.substring(0, equalIndex).trim();
      const value = trimmedLine.substring(equalIndex + 1).trim();
      let cleanValue = value;
      if (value.startsWith('`')) {
        let endQuoteIndex = -1;
        for (let i = 1; i < value.length; i++) {
          if (value[i] === '`' && value[i - 1] !== `\\`) {
            endQuoteIndex = i;
            break;
          }
        }
        if (endQuoteIndex !== -1) {
          cleanValue = value.slice(1, endQuoteIndex);
          cleanValue = cleanValue.replace(/\\`/g, '`');
        }
      } else if (value.startsWith(`'`)) {
        const endQuoteIndex = value.indexOf(`'`, 1);
        if (endQuoteIndex !== -1) {
          cleanValue = value.slice(1, endQuoteIndex);
        }
      }
      envVars.push({ key, value: cleanValue });
    }
  }
  return envVars;
}",1,Code Smell
"export function resolveSaveContextOnCollectionReorder(
  payload: {
    lastIndex: number
    newIndex: number
    folderPath: string
    length?: number
  },
  type: 'remove' | 'drop' = 'remove'
) {
  const { lastIndex, folderPath, length } = payload
  let { newIndex } = payload
  if (newIndex > lastIndex) newIndex--
  if (lastIndex === newIndex) return
  const affectedIndexes = getAffectedIndexes(
    lastIndex,
    newIndex === -1 ? length! : newIndex
  )
  if (newIndex === -1) {
    affectedIndexes.delete(lastIndex)
    if (type === 'remove') {
      resetSaveContextForAffectedRequests(
        folderPath ? `${folderPath}/${lastIndex}` : lastIndex.toString()
      )
    }
  }
  const affectedPaths = new Map<string, string>()
  for (const [key, value] of affectedIndexes) {
    if (folderPath) {
      affectedPaths.set(`${folderPath}/${key}`, `${folderPath}/${value}`)
    } else {
      affectedPaths.set(key.toString(), value.toString())
    }
  }
  const tabService = getService(RESTTabService)
  const tabs = tabService.getTabsRefTo((tab) => {
    return (
      tab.document.saveContext?.originLocation === 'user-collection' &&
      affectedPaths.has(tab.document.saveContext.folderPath)
    )
  })
  for (const tab of tabs) {
    if (tab.value.document.saveContext?.originLocation === 'user-collection') {
      const newPath = affectedPaths.get(
        tab.value.document.saveContext?.folderPath
      )!
      tab.value.document.saveContext.folderPath = newPath
    }
  }
}",1,Code Smell
"function math_block(state: any, start: number, end: number, silent: boolean) {
  let firstLine
  let lastLine
  let next
  let lastPos
  let found = false
  let pos = state.bMarks[start] + state.tShift[start]
  let max = state.eMarks[start]
  if (pos + 2 > max)
    return false
  if (state.src.slice(pos, pos + 2) !== '$$')
    return false
  pos += 2
  firstLine = state.src.slice(pos, max)
  if (silent)
    return true
  if (firstLine.trim().slice(-2) === '$$') {
    firstLine = firstLine.trim().slice(0, -2)
    found = true
  }
  for (next = start; !found;) {
    next++
    if (next >= end)
      break
    pos = state.bMarks[next] + state.tShift[next]
    max = state.eMarks[next]
    if (pos < max && state.tShift[next] < state.blkIndent) {
      break
    }
    if (state.src.slice(pos, max).trim().slice(-2) === '$$') {
      lastPos = state.src.slice(0, max).lastIndexOf('$$')
      lastLine = state.src.slice(pos, lastPos)
      found = true
    }
  }
  state.line = next + 1
  const token = state.push('math_block', 'math', 0)
  token.block = true
  token.content = (firstLine && firstLine.trim() ? `${firstLine}\n` : '')
    + state.getLines(start + 1, next, state.tShift[start], true)
    + (lastLine && lastLine.trim() ? lastLine : '')
  token.map = [start, state.line]
  token.markup = '$$'
  return true
}",1,Code Smell
"async function downloadOrLoad(
  source: string,
  cacheDir: string,
  cacheSubdir: string,
  fileExtension: string,
  useHashForCache: boolean = true,
  filetype?: string,
): Promise<DownloadResult> {
  const isUrl = source.startsWith('http://') || source.startsWith('https://')
  if (isUrl) {
    let cacheFileName: string
    if (useHashForCache) {
      const hash = this.hashUrl(source)
      cacheFileName = filetype ? `${filetype}-${hash}${fileExtension}` : `${hash}${fileExtension}`
    } else {
      cacheFileName = path.basename(source)
    }
    const cacheFile = path.join(cacheDir, cacheSubdir, cacheFileName)
    await mkdir(path.dirname(cacheFile), { recursive: true })
    try {
      const cachedContent = await Bun.file(cacheFile).arrayBuffer()
      if (cachedContent.byteLength > 0) {
        console.log(`Loaded from cache: ${cacheFile} (${source})`)
        return { content: cachedContent, filePath: cacheFile }
      }
    } catch (error) {
    }
    try {
      console.log(`Downloading from URL: ${source}`)
      const response = await fetch(source)
      if (!response.ok) {
        return { error: `Failed to fetch from ${source}: ${response.statusText}` }
      }
      const content = await response.arrayBuffer()
      try {
        await writeFile(cacheFile, Buffer.from(content))
        console.log(`Cached: ${source}`)
      } catch (cacheError) {
        console.warn(`Failed to cache: ${cacheError}`)
      }
      return { content, filePath: cacheFile }
    } catch (error) {
      return { error: `Error downloading from ${source}: ${error}` }
    }
  } else {
    try {
      console.log(`Loading from local path: ${source}`)
      const content = await Bun.file(source).arrayBuffer()
      return { content, filePath: source }
    } catch (error) {
      return { error: `Error loading from local path ${source}: ${error}` }
    }
  }
}",1,Code Smell
"export function replaceInterpolatedValuesInObject(
  config_: RenovateConfig,
  input: Record<string, string>,
  options: InterpolatorOptions,
  deleteValues = true,
): RenovateConfig {
  const config = { ...config_ };
  const { name } = options;
  if (deleteValues) {
    delete config[name];
  }
  for (const [key, value] of Object.entries(config)) {
    if (isPlainObject(value)) {
      config[key] = replaceInterpolatedValuesInObject(
        value,
        input,
        options,
        deleteValues,
      );
    }
    if (isString(value)) {
      config[key] = replaceInterpolatedValuesInString(
        key,
        value,
        input,
        options,
      );
    }
    if (isArray(value)) {
      for (const [arrayIndex, arrayItem] of value.entries()) {
        if (isPlainObject(arrayItem)) {
          value[arrayIndex] = replaceInterpolatedValuesInObject(
            arrayItem,
            input,
            options,
            deleteValues,
          );
        } else if (isString(arrayItem)) {
          value[arrayIndex] = replaceInterpolatedValuesInString(
            key,
            arrayItem,
            input,
            options,
          );
        }
      }
    }
  }
  return config;
}",1,Code Smell
"export function parseMavenBasedRange(input: string): MavenBasedRange | null {
  if (!input) {
    return null;
  }
  const matchGroups = mavenBasedRangeRegex.exec(input)?.groups;
  if (matchGroups) {
    const { leftBoundStr, separator, rightBoundStr } = matchGroups;
    let leftVal: string | null = matchGroups.leftVal;
    let rightVal: string | null = matchGroups.rightVal;
    if (!leftVal) {
      leftVal = null;
    }
    if (!rightVal) {
      rightVal = null;
    }
    const isVersionLeft = isString(leftVal) && isVersion(leftVal);
    const isVersionRight = isString(rightVal) && isVersion(rightVal);
    if (
      (leftVal === null || isVersionLeft) &&
      (rightVal === null || isVersionRight)
    ) {
      if (
        isVersionLeft &&
        isVersionRight &&
        leftVal &&
        rightVal &&
        compare(leftVal, rightVal) === 1
      ) {
        return null;
      }
      const leftBound = leftBoundStr.trim() === '[' ? 'inclusive' : 'exclusive';
      const rightBound =
        rightBoundStr.trim() === ']' ? 'inclusive' : 'exclusive';
      return {
        leftBound,
        leftBoundStr,
        leftVal,
        separator,
        rightBound,
        rightBoundStr,
        rightVal,
      };
    }
  }
  return null;
}",1,Code Smell
"async function evaluateForEachItems(
  forEachItems: any,
  context: ExecutionContext,
  block: SerializedBlock
): Promise<any[] | Record<string, any> | null> {
  if (
    Array.isArray(forEachItems) ||
    (typeof forEachItems === 'object' && forEachItems !== null)
  ) {
    return forEachItems
  }
  if (typeof forEachItems === 'string') {
    try {
      const trimmed = forEachItems.trim()
      if (trimmed.startsWith('//') || trimmed === '') {
        return []
      }
      if (trimmed.startsWith('[') || trimmed.startsWith('{')) {
        try {
          return JSON.parse(trimmed)
        } catch {
        }
      }
      if (this.resolver) {
        const resolved = this.resolver.resolveBlockReferences(forEachItems, context, block)
        try {
          return JSON.parse(resolved)
        } catch {
          try {
            const result = new Function(`return ${resolved}`)()
            if (Array.isArray(result) || (typeof result === 'object' && result !== null)) {
              return result
            }
          } catch (e) {
            logger.error(`Error evaluating forEach expression: ${resolved}`, e)
          }
        }
      }
      logger.warn(`forEach expression evaluation not fully implemented: ${forEachItems}`)
      return null
    } catch (error) {
      logger.error(`Error evaluating forEach items:`, error)
      return null
    }
  }
  return null
}",1,Code Smell
"accessorFn: resource => {
  const kind = resource.kind;
  if (kind === 'Deployment') {
    const deployment = resource as Deployment;
    const spec = deployment.spec;
    const status = deployment.status;
    if (status?.readyReplicas === 0) return 'Unhealthy';
    if ((status?.readyReplicas || 0) < (spec?.replicas || 0)) return 'Degraded';
  } else if (kind === 'StatefulSet') {
    const statefulSet = resource as StatefulSet;
    const spec = statefulSet.spec;
    const status = statefulSet.status;
    if (status?.readyReplicas === 0) return 'Unhealthy';
    if ((status?.readyReplicas || 0) < (spec?.replicas || 0)) return 'Degraded';
  } else if (kind === 'DaemonSet') {
    const daemonSet = resource as DaemonSet;
    const status = daemonSet.status;
    if (status?.numberReady === 0) return 'Unhealthy';
    if ((status?.numberReady || 0) < (status?.desiredNumberScheduled || 0))
      return 'Degraded';
  } else if (kind === 'Pod') {
    const pod = resource as Pod;
    const phase = pod.status?.phase;
    const conditions = pod.status?.conditions || [];
    const ready = conditions.find((c: any) => c.type === 'Ready')?.status === 'True';

    if (phase === 'Failed' || phase === 'CrashLoopBackOff') return 'Failed';
    if (phase === 'Pending' || !ready) return 'Pending';
  }
  return 'Healthy';
}",1,Code Smell
"function getDashboardMarkdownInternal(
  data: Map<string, Record<string, PackageFile[]> | null>,
): string {
  const none = 'None detected\n\n';
  const pad = data.size > 1;
  let deps = '';
  for (const [branch, packageFiles] of Array.from(data).sort(([a], [b]) =>
    a.localeCompare(b, undefined, { numeric: true }),
  )) {
    deps += pad
      ? `<details><summary>Branch ${branch}</summary>\n<blockquote>\n\n`
      : '';
    if (packageFiles === null) {
      deps += none;
      deps += pad ? '</blockquote>\n</details>\n\n' : '';
      continue;
    }
    const managers = Object.keys(packageFiles).sort();
    if (managers.length === 0) {
      deps += none;
      deps += pad ? '</blockquote>\n</details>\n\n' : '';
      continue;
    }
    for (const manager of managers) {
      deps += `<details><summary>${manager}</summary>\n<blockquote>\n\n`;
      for (const packageFile of Array.from(packageFiles[manager]).sort(
        (a, b) => a.packageFile.localeCompare(b.packageFile),
      )) {
        deps += `<details><summary>${packageFile.packageFile}</summary>\n\n`;
        for (const dep of packageFile.deps) {
          const ver = dep.currentValue;
          const digest = dep.currentDigest;
          const lock = dep.lockedVersion;
          let version;
          if (ver || digest) {
            version = ver && digest ? `${ver}@${digest}` : `${digest ?? ver}`;
          } else if (lock) {
            version = `lock file @ ${lock}`;
          } else {
            version = 'unknown version';
          }
          deps += ` - \`${dep.depName!} ${version}\`\n`;
        }
        deps += '\n</details>\n\n';
      }
      deps += `</blockquote>\n</details>\n\n`;
    }
    deps += pad ? '</blockquote>\n</details>\n\n' : '';
  }
  return deps;
}",1,Code Smell
"function updateSelectionForMovement(shiftPressed: boolean, isBeforeMovement: boolean): void {
  if (!this.selectable) return
  if (!shiftPressed) {
    this._ctx.clearSelection()
    this._selectionAnchorState = null
    return
  }
  const visualCursor = this.editorView.getVisualCursor()
  const viewport = this.editorView.getViewport()
  const cursorX = this.x + visualCursor.visualCol
  const cursorY = this.y + visualCursor.visualRow
  if (isBeforeMovement) {
    if (!this._ctx.hasSelection) {
      this._ctx.startSelection(this, cursorX, cursorY)
      this._selectionAnchorState = {
        screenX: cursorX,
        screenY: cursorY,
        viewportX: viewport.offsetX,
        viewportY: viewport.offsetY,
      }
    } else if (!this._selectionAnchorState) {
      const selection = this._ctx.getSelection()
      if (selection && selection.isActive) {
        this._selectionAnchorState = {
          screenX: selection.anchor.x,
          screenY: selection.anchor.y,
          viewportX: viewport.offsetX,
          viewportY: viewport.offsetY,
        }
      }
    }
  } else {
    if (this._selectionAnchorState) {
      const deltaY = viewport.offsetY - this._selectionAnchorState.viewportY
      const deltaX = viewport.offsetX - this._selectionAnchorState.viewportX
      if (deltaY !== 0 || deltaX !== 0) {
        const newAnchorX = this._selectionAnchorState.screenX - deltaX
        const newAnchorY = this._selectionAnchorState.screenY - deltaY
        this._ctx.startSelection(this, newAnchorX, newAnchorY)
        this._ctx.updateSelection(this, cursorX, cursorY)
      } else {
        this._ctx.updateSelection(this, cursorX, cursorY)
      }
    } else {
      this._ctx.updateSelection(this, cursorX, cursorY)
    }
  }
}",1,Code Smell
"export function getExtraFiles(
  annotations: Record<string, string>
): ArtifactHubHeadlampPkg['extraFiles'] | undefined {
  const converted = convertAnnotations(annotations);
  const extraFiles: ArtifactHubHeadlampPkg['extraFiles'] =
    converted?.headlamp?.plugin?.['extra-files'];
  if (!extraFiles) {
    return undefined;
  }
  for (const file of Object.values(extraFiles)) {
    for (const value of Object.values(file.output)) {
      if (
        value.output.startsWith('..') ||
        value.output.startsWith('/') ||
        value.output.startsWith('\\')
      ) {
        throw new Error(`Invalid extra file output path, ${value.output}`);
      }
      if (
        value.input.startsWith('..') ||
        value.input.startsWith('/') ||
        value.input.startsWith('\\')
      ) {
        throw new Error(`Invalid extra file input path, ${value.input}`);
      }
    }
  }
  for (const file of Object.values(extraFiles)) {
    const underTest = process.env.NODE_ENV === 'test' && file.url.includes('localhost');
    const validURL =
      file.url &&
      (file.url.startsWith('https://github.com/kubernetes/minikube/releases/download/') ||
        file.url.startsWith('https://github.com/crc-org/vfkit/releases/download/'));
    if (!underTest && !validURL) {
      throw new Error(`Invalid URL, ${file.url}`);
    }
  }
  return converted.headlamp.plugin['extra-files'];
}",1,Code Smell
"function extractCompleteSequences(buffer: string): { sequences: string[]; remainder: string } {
  const sequences: string[] = []
  let pos = 0
  while (pos < buffer.length) {
    const remaining = buffer.slice(pos)
    if (remaining.startsWith(ESC)) {
      let seqEnd = 1
      while (seqEnd <= remaining.length) {
        const candidate = remaining.slice(0, seqEnd)
        const status = isCompleteSequence(candidate)
        if (status === 'complete') {
          sequences.push(candidate)
          pos += seqEnd
          break
        } else if (status === 'incomplete') {
          seqEnd++
        } else {
          sequences.push(candidate)
          pos += seqEnd
          break
        }
      }
      if (seqEnd > remaining.length) {
        return { sequences, remainder: remaining }
      }
    } else {
      sequences.push(remaining[0])
      pos++
    }
  }

  return { sequences, remainder: '' }
}",1,Code Smell
"function getParallelItems(
  parallel: any,
  context: ExecutionContext
): any[] | Record<string, any> | null {
  if (!parallel || !parallel.distribution) return null
  if (
    Array.isArray(parallel.distribution) ||
    (typeof parallel.distribution === 'object' && parallel.distribution !== null)
  ) {
    return parallel.distribution
  }
  if (typeof parallel.distribution === 'string') {
    try {
      const trimmedExpression = parallel.distribution.trim()
      if (trimmedExpression.startsWith('[') || trimmedExpression.startsWith('{')) {
        try {
          return JSON.parse(trimmedExpression)
        } catch {
        }
      }
      if (trimmedExpression && !trimmedExpression.startsWith('//')) {
        const result = new Function('context', `return ${parallel.distribution}`)(context)
        if (Array.isArray(result) || (typeof result === 'object' && result !== null)) {
          return result
        }
      }
    } catch (e) {
      console.error('Error evaluating parallel distribution items:', e)
    }
  }
  return []
}",1,Code Smell
"() => {
  const visibility = resolvedClickMap.get(el)?.visibilityState.value ?? 'shown'
  if (!clicksContext?.value || !['slide', 'presenter'].includes(renderContext?.value ?? '')) {
    const mixedVariant: Record<string, unknown> = { ...variantInitial, ...variantEnter }
    for (const { variant } of clicks)
      Object.assign(mixedVariant, variant)
    motion.set(mixedVariant)
  }
  else if (isPrintMode.value || thisPage?.value === currentPage.value) {
    if (visibility === 'shown') {
      const mixedVariant: Record<string, unknown> = { ...variantInitial, ...variantEnter }
      for (const { variant, info } of clicks) {
        if (!info || info.isActive.value)
          Object.assign(mixedVariant, variant)
      }
      if (isPrintMode.value)
        motion.set(mixedVariant)
      else
        motion.apply(mixedVariant)
    }
    else {
      motion.apply(visibility === 'before' ? variantInitial : variantLeave)
    }
  }
  else {
    motion.apply((thisPage?.value ?? -1) > currentPage.value ? variantInitial : variantLeave)
  }
}",1,Code Smell
"export async function ensureComment({
  number,
  topic,
  content,
}: EnsureCommentConfig): Promise<boolean> {
  logger.debug(`ensureComment(${number}, ${topic!}, content)`);
  const header = topic ? `### ${topic}\n\n` : '';
  const body = `${header}${sanitize(content)}`;
  let prCommentsResponse: GetCommentsForPullRequestOutput;
  try {
    prCommentsResponse = await client.getPrComments(`${number}`);
  } catch (err) {
    logger.debug({ err }, 'Unable to retrieve pr comments');
    return false;
  }
  let commentId: string | undefined = undefined;
  let commentNeedsUpdating = false;
  if (!prCommentsResponse?.commentsForPullRequestData) {
    return false;
  }
  for (const commentObj of prCommentsResponse.commentsForPullRequestData) {
    if (!commentObj?.comments) {
      continue;
    }
    const firstCommentContent = commentObj.comments[0].content;
    if (
      (topic && firstCommentContent?.startsWith(header)) === true ||
      (!topic && firstCommentContent === body)
    ) {
      commentId = commentObj.comments[0].commentId;
      commentNeedsUpdating = firstCommentContent !== body;
      break;
    }
  }
  if (!commentId) {
    const prs = await getPrList();
    const thisPr = prs.filter((item) => item.number === number);

    if (!thisPr[0].sourceCommit || !thisPr[0].destinationCommit) {
      return false;
    }
    await client.createPrComment(
      `${number}`,
      config.repository,
      body,
      thisPr[0].destinationCommit,
      thisPr[0].sourceCommit,
    );
    logger.info(
      { repository: config.repository, prNo: number, topic },
      'Comment added',
    );
  } else if (commentNeedsUpdating && commentId) {
    await client.updateComment(commentId, body);

    logger.debug(
      { repository: config.repository, prNo: number, topic },
      'Comment updated',
    );
  } else {
    logger.debug(
      { repository: config.repository, prNo: number, topic },
      'Comment is already update-to-date',
    );
  }
  return true;
}",1,Code Smell
"export function fuzzySearch<T>(
  items: T[],
  pattern: string,
  options: FuzzySearchOptions = {},
): FuzzyMatch[] {
  const { keys = [], threshold = 0.1, minMatchCharLength = 1 } = options
  if (!pattern || pattern.length < minMatchCharLength) {
    return items.map(item => ({
      score: 1,
      indices: [],
      item,
      matches: [],
    }))
  }
  const results: FuzzyMatch[] = []
  for (const item of items) {
    let bestScore = 0
    let bestMatches: Array<{ indices: number[]; key?: string }> = []
    if (keys.length === 0) {
      const match = fuzzyMatchString(pattern, String(item))
      if (match.score > threshold) {
        results.push({
          score: match.score,
          indices: match.indices,
          item,
          matches: [{ indices: match.indices }],
        })
      }
    } else {
      for (const key of keys) {
        const value = (item as any)[key]
        if (typeof value === 'string') {
          const match = fuzzyMatchString(pattern, value)
          if (match.score > bestScore) {
            bestScore = match.score
            bestMatches = [{ indices: match.indices, key }]
          } else if (match.score === bestScore && match.score > threshold) {
            bestMatches.push({ indices: match.indices, key })
          }
        }
      }
      if (bestScore > threshold) {
        results.push({
          score: bestScore,
          indices: bestMatches[0]?.indices || [],
          item,
          matches: bestMatches,
        })
      }
    }
  }
  return results.sort((a, b) => b.score - a.score)
}",1,Code Smell
"const visibleSubBlocks = subBlocks.filter((block) => {
  if (block.hidden) return false
  if (block.mode) {
    if (block.mode === 'basic' && isAdvancedMode) return false
    if (block.mode === 'advanced' && !isAdvancedMode) return false
  }
  if (!block.condition) return true
  const fieldValue = stateToUse[block.condition.field]?.value
  const andFieldValue = block.condition.and
    ? stateToUse[block.condition.and.field]?.value
    : undefined
  const isValueMatch = Array.isArray(block.condition.value)
    ? fieldValue != null &&
    (block.condition.not
      ? !block.condition.value.includes(fieldValue as string | number | boolean)
      : block.condition.value.includes(fieldValue as string | number | boolean))
    : block.condition.not
      ? fieldValue !== block.condition.value
      : fieldValue === block.condition.value
  const isAndValueMatch =
    !block.condition.and ||
    (Array.isArray(block.condition.and.value)
      ? andFieldValue != null &&
      (block.condition.and.not
        ? !block.condition.and.value.includes(andFieldValue as string | number | boolean)
        : block.condition.and.value.includes(andFieldValue as string | number | boolean))
      : block.condition.and.not
        ? andFieldValue !== block.condition.and.value
        : andFieldValue === block.condition.and.value)
  return isValueMatch && isAndValueMatch
})",1,Code Smell
"catch ((err): MavenFetchResult => {
  if (!(err instanceof HttpError)) {
    return Result.err({ type: 'unknown', err });
  }
  const failedUrl = url;
  if (err.message === HOST_DISABLED) {
    logger.trace({ failedUrl }, 'Host disabled');
    return Result.err({ type: 'host-disabled' });
  }
  if (isNotFoundError(err)) {
    logger.trace({ failedUrl }, `Url not found`);
    return Result.err({ type: 'not-found' });
  }
  if (isHostError(err)) {
    logger.debug(`Cannot connect to host ${failedUrl}`);
    return Result.err({ type: 'host-error' });
  }
  if (isPermissionsIssue(err)) {
    logger.debug(
      `Dependency lookup unauthorized. Please add authentication with a hostRule for ${failedUrl}`,
    );
    return Result.err({ type: 'permission-issue' });
  }
  if (isTemporaryError(err)) {
    logger.debug({ failedUrl, err }, 'Temporary error');
    if (getHost(url) === getHost(MAVEN_REPO)) {
      const statusCode = err?.response?.statusCode;
      if (statusCode === 429) {
        if (getCacheType() === 'redis') {
          logger.once.warn(
            { failedUrl },
            'Maven Central rate limiting detected despite Redis caching.',
          );
        } else {
          logger.once.warn(
            { failedUrl },
            'Maven Central rate limiting detected. Persistent caching required.',
          );
        }
      }
      return Result.err({ type: 'maven-central-temporary-error', err });
    } else {
      return Result.err({ type: 'temporary-error' });
    }
  }
  if (isConnectionError(err)) {
    logger.debug(`Connection refused to maven registry ${failedUrl}`);
    return Result.err({ type: 'connection-error' });
  }
  if (isUnsupportedHostError(err)) {
    logger.debug(`Unsupported host ${failedUrl}`);
    return Result.err({ type: 'unsupported-host' });
  }
  logger.info({ failedUrl, err }, 'Unknown HTTP download error');
  return Result.err({ type: 'unknown', err });
})",1,Code Smell
"function math_inline(state: any, silent: boolean) {
  let match, token, res, pos
  if (state.src[state.pos] !== '$')
    return false
  res = isValidDelim(state, state.pos)
  if (!res.can_open) {
    if (!silent)
      state.pending += '$'
    state.pos += 1
    return true
  }
  const start = state.pos + 1
  match = start
  while ((match = state.src.indexOf('$', match)) !== -1) {
    pos = match - 1
    while (state.src[pos] === '\\') pos -= 1

    if (((match - pos) % 2) === 1)
      break
    match += 1
  }
  if (match === -1) {
    if (!silent)
      state.pending += '$'
    state.pos = start
    return true
  }
  if (match - start === 0) {
    if (!silent)
      state.pending += '$$'
    state.pos = start + 1
    return true
  }
  res = isValidDelim(state, match)
  if (!res.can_close) {
    if (!silent)
      state.pending += '$'
    state.pos = start
    return true
  }
  if (!silent) {
    token = state.push('math_inline', 'math', 0)
    token.markup = '$'
    token.content = state.src.slice(start, match)
  }
  state.pos = match + 1
  return true
}",1,Code Smell
"function resolveEnvVariables(value: any, isApiKey = false): any {
  if (typeof value === 'string') {
    const isExplicitEnvVar = value.trim().startsWith('{{') && value.trim().endsWith('}}')
    const hasProperEnvVarReferences = this.containsProperEnvVarReference(value)
    if (isApiKey || isExplicitEnvVar || hasProperEnvVarReferences) {
      const envMatches = value.match(/\{\{([^}]+)\}\}/g)
      if (envMatches) {
        let resolvedValue = value
        for (const match of envMatches) {
          const envKey = match.slice(2, -2)
          const envValue = this.environmentVariables[envKey]

          if (envValue === undefined) {
            throw new Error(`Environment variable '${envKey}' was not found.`)
          }

          resolvedValue = resolvedValue.replace(match, envValue)
        }
        return resolvedValue
      }
    }
    return value
  }
  if (Array.isArray(value)) {
    return value.map((item) => this.resolveEnvVariables(item, isApiKey))
  }
  if (value && typeof value === 'object') {
    return Object.entries(value).reduce(
      (acc, [k, v]) => ({
        ...acc,
        [k]: this.resolveEnvVariables(v, k.toLowerCase() === 'apikey'),
      }),
      {}
    )
  }
  return value
}",1,Code Smell
"action((repositories: string[], opts: Record<string, unknown>) => {
  if (repositories?.length) {
    config.repositories = repositories;
  }
  for (const option of options) {
    if (option.cli !== false) {
      if (opts[option.name] !== undefined) {
        config[option.name] = opts[option.name];
        if (option.name === 'dryRun') {
          if (config[option.name] === 'true') {
            logger.warn(
              'cli config dryRun property has been changed to full',
            );
            config[option.name] = 'full';
          } else if (config[option.name] === 'false') {
            logger.warn(
              'cli config dryRun property has been changed to null',
            );
            config[option.name] = null;
          } else if (config[option.name] === 'null') {
            config[option.name] = null;
          }
        }
        if (option.name === 'requireConfig') {
          if (config[option.name] === 'true') {
            logger.warn(
              'cli config requireConfig property has been changed to required',
            );
            config[option.name] = 'required';
          } else if (config[option.name] === 'false') {
            logger.warn(
              'cli config requireConfig property has been changed to optional',
            );
            config[option.name] = 'optional';
          }
        }
      }
    }
  }
})",1,Code Smell
"export function fixParsedRange(range: string): any {
  const ordValues = [];
  const originalSplit = range.split(' ');
  for (let i = 0; i < originalSplit.length; i += 1) {
    if (
      !containsOperators(originalSplit[i]) &&
      !originalSplit[i].includes('||')
    ) {
      if (i !== 0 && originalSplit[i - 1].includes('||')) {
        ordValues.push(`|| ${originalSplit[i]}`);
      } else if (i !== originalSplit.length && originalSplit[i + 1] === '||') {
        ordValues.push(`${originalSplit[i]} ||`);
      }
    } else {
      ordValues.push(originalSplit[i]);
    }
  }
  const parsedRange = parseRange(range);
  const cleanRange = range.replace(/([<=>^~])( )?/g, '');
  const splitRange = cleanRange.split(' ');
  const semverRange: SemVer[] = [];
  for (let i = 0; i < splitRange.length; i += 1) {
    if (!splitRange[i].includes('||')) {
      const splitVersion = splitRange[i].split('.');
      const major = splitVersion[0];
      const minor = splitVersion[1];
      const patch = splitVersion[2];
      const operator = ordValues[i].includes('||')
        ? '||'
        : parsedRange[i].operator;
      const NewSemVer: SemVer = {
        major,
      };
      let full = `${coerceString(operator)}${major}`;
      if (minor) {
        NewSemVer.minor = minor;
        full = `${full}.${minor}`;
        if (patch) {
          NewSemVer.patch = patch;
          full = `${full}.${patch}`;
        }
      }
      if (operator) {
        NewSemVer.operator = operator;
        full = range.includes(`${operator} `)
          ? `${operator} ${full.replace(operator, '')}`
          : `${operator}${full.replace(operator, '')}`;
      }
      full = ordValues[i].includes('||') ? ordValues[i] : full;
      NewSemVer.semver = full;
      semverRange.push(NewSemVer);
    }
  }
  return semverRange;
}",1,Code Smell
"async function fetchReleases(
  config: GetReleasesInternalConfig,
): Promise<ReleaseResult | null> {
  const { datasource: datasourceName } = config;
  let { registryUrls } = config;
  if (!datasourceName || getDatasourceFor(datasourceName) === undefined) {
    logger.warn({ datasource: datasourceName }, 'Unknown datasource');
    return null;
  }
  if (datasourceName === 'npm') {
    if (isString(config.npmrc)) {
      setNpmrc(config.npmrc);
    }
    if (!isNonEmptyArray(registryUrls)) {
      registryUrls = [resolveRegistryUrl(config.packageName)];
    }
  }
  const datasource = getDatasourceFor(datasourceName);
  if (!datasource) {
    logger.warn({ datasource: datasourceName }, 'Unknown datasource');
    return null;
  }
  registryUrls = resolveRegistryUrls(
    datasource,
    config.defaultRegistryUrls,
    registryUrls,
    config.additionalRegistryUrls,
  );
  let dep: ReleaseResult | null = null;
  const registryStrategy =
    config.registryStrategy ?? datasource.registryStrategy ?? 'hunt';
  try {
    if (isNonEmptyArray(registryUrls)) {
      if (registryStrategy === 'first') {
        dep = await firstRegistry(config, datasource, registryUrls);
      } else if (registryStrategy === 'hunt') {
        dep = await huntRegistries(config, datasource, registryUrls);
      } else if (registryStrategy === 'merge') {
        dep = await mergeRegistries(config, datasource, registryUrls);
      }
    } else {
      dep = await datasource.getReleases(config);
    }
  } catch (err) {
    if (err.message === HOST_DISABLED || err.err?.message === HOST_DISABLED) {
      return null;
    }
    if (err instanceof ExternalHostError) {
      throw err;
    }
    logError(datasource.id, config.packageName, err);
  }
  if (!dep || dequal(dep, { releases: [] })) {
    return null;
  }
  addMetaData(dep, datasourceName, config.packageName);
  dep = { ...dep, ...applyReplacements(config) };
  return dep;
}",1,Code Smell
"export function handleRegistryContent(ctx: Ctx): Ctx {
  const methodName = loadFromTokenMap(ctx, 'methodName')[0].value;
  let groupId = loadFromTokenMap(ctx, 'groupId')[0].value;
  let matcher: ContentDescriptorMatcher = 'simple';
  if (methodName.includes('Regex')) {
    matcher = 'regex';
    groupId = `^${groupId}$`.replaceAll('\\\\', '\\');
    if (!isValidContentDescriptorRegex('group', groupId)) {
      return ctx;
    }
  } else if (methodName.includes('AndSubgroups')) {
    matcher = 'subgroup';
  }
  const mode = methodName.startsWith('include') ? 'include' : 'exclude';
  const spec: ContentDescriptorSpec = { mode, matcher, groupId };
  if (methodName.includes('Module') || methodName.includes('Version')) {
    spec.artifactId = loadFromTokenMap(ctx, 'artifactId')[0].value;
    if (matcher === 'regex') {
      spec.artifactId = `^${spec.artifactId}$`.replaceAll('\\\\', '\\');
      if (!isValidContentDescriptorRegex('module', spec.artifactId)) {
        return ctx;
      }
    }
  }
  if (methodName.includes('Version')) {
    spec.version = loadFromTokenMap(ctx, 'version')[0].value;
    if (matcher === 'regex') {
      spec.version = `^${spec.version}$`.replaceAll('\\\\', '\\');
      if (!isValidContentDescriptorRegex('version', spec.version)) {
        return ctx;
      }
    }
  }
  ctx.tmpRegistryContent.push(spec);
  return ctx;
}",1,Code Smell
"export function extractPackageFile(content: string): PackageFileContent | null {
  const sections = content.split(regEx(/def |\n\[/)).filter(
    (part) =>
      part.includes('python_requires') ||
      part.includes('build_require') || 
      part.includes('require'),
  );
  const deps: PackageDependency[] = [];
  for (const section of sections) {
    let depType = setDepType(section, 'requires');
    const rawLines = section.split('\n').filter(isNonEmptyString)
    for (const rawLine of rawLines) {
      if (!isComment(rawLine)) {
        depType = setDepType(rawLine, depType);
        const lines = rawLine.split(regEx(/[`'],/));
        for (const line of lines) {
          const matches = regex.exec(line.trim());
          if (matches?.groups) {
            let dep: PackageDependency = {};
            const depName = matches.groups?.name;
            const currentValue = matches.groups?.version.trim();
            let replaceString = `${depName}/${currentValue}`;
            let userAndChannel = '@_/_';
            if (matches.groups.userChannel) {
              userAndChannel = matches.groups.userChannel;
              replaceString = `${depName}/${currentValue}${userAndChannel}`;
              if (!userAndChannel.includes('/')) {
                userAndChannel = `${userAndChannel}/_`;
              }
            }
            const packageName = `${depName}/${currentValue}${userAndChannel}`;
            dep = {
              ...dep,
              depName,
              packageName,
              currentValue,
              replaceString,
              depType,
            };
            if (matches.groups.revision) {
              dep.currentDigest = matches.groups.revision;
              dep.autoReplaceStringTemplate = `{{depName}}/{{newValue}}${userAndChannel}{{#if newDigest}}#{{newDigest}}{{/if}}`;
              dep.replaceString = `${replaceString}#${dep.currentDigest}`;
            }
            deps.push(dep);
          }
        }
      }
    }
  }

  return deps.length ? { deps } : null;
}",1,Code Smell
"map((x) => {
  const [packageNameString, requirements] = x;
  let depName = packageNameString;
  let currentValue: string | undefined;
  let nestedVersion = false;
  let skipReason: SkipReason | undefined;
  if (isObject(requirements)) {
    if (requirements.git) {
      skipReason = 'git-dependency';
    } else if (requirements.file) {
      skipReason = 'file-dependency';
    } else if (requirements.path) {
      skipReason = 'local-dependency';
    } else if (requirements.version) {
      currentValue = requirements.version;
      nestedVersion = true;
    } else {
      skipReason = 'unspecified-version';
    }
  } else {
    currentValue = requirements;
  }
  if (currentValue === '*') {
    skipReason = 'unspecified-version';
  }
  if (!skipReason) {
    const packageMatches = packageRegex.exec(packageNameString);
    if (packageMatches) {
      depName = packageMatches[1];
    } else {
      logger.debug(
        `Skipping dependency with malformed package name `${packageNameString}`.`,
      );
      skipReason = 'invalid-name';
    }
    const specifierMatches = specifierRegex.exec(currentValue!);
    if (!specifierMatches) {
      logger.debug(
        `Skipping dependency with malformed version specifier `${currentValue!}`.`,
      );
      skipReason = 'invalid-version';
    }
  }
  const dep: PackageDependency = {
    depType: sectionName,
    depName,
    packageName: normalizePythonDepName(depName),
    managerData: {},
  };
  if (currentValue) {
    dep.currentValue = currentValue;
  }
  if (skipReason) {
    dep.skipReason = skipReason;
  } else {
    dep.datasource = PypiDatasource.id;
  }
  if (!skipReason && currentValue?.startsWith('==')) {
    dep.currentVersion = currentValue.replace(regEx(/^==\s*/), '');
  }
  if (nestedVersion) {
    dep.managerData!.nestedVersion = nestedVersion;
  }
  if (sources && isObject(requirements) && requirements.index) {
    const source = sources.find((item) => item.name === requirements.index);
    if (source) {
      dep.registryUrls = [source.url];
    }
  }
  return dep;
})",1,Code Smell
"async function resolve({ ctx, input }) {
  const resumes = await ctx.prisma.resumesResume.findMany({
    select: {
      comments: {
        select: {
          userId: true,
          votes: {
            select: {
              value: true,
            },
          },
        },
      },
    },
  });
  let topUpvotedCommentCount = 0;
  for (const resume of resumes) {
    let highestVoteCount = 2;
    const commentUpvotePairs = [];
    for (const comment of resume.comments) {
      const { userId, votes } = comment;
      let voteCount = 0;
      for (const vote of votes) {
        if (vote.value === Vote.UPVOTE) {
          voteCount++;
        } else {
          voteCount--;
        }
      }
      if (voteCount >= highestVoteCount) {
        highestVoteCount = voteCount;
        commentUpvotePairs.push({ userId, voteCount });
      }
    }
    const userIds = commentUpvotePairs
      .filter((pair) => pair.voteCount === highestVoteCount)
      .map((pair) => pair.userId);
    if (userIds.includes(input.userId)) {
      topUpvotedCommentCount++;
    }
  }
  return topUpvotedCommentCount;
}",1,Code Smell
"obj.forEach(([key, val]) => {
  const el = [key, val];
  if (key === 'cli' && !val) {
    ignoredKeys.push('cli');
  }
  if (key === 'env' && !val) {
    ignoredKeys.push('env');
  }
  if (
    !ignoredKeys.includes(el[0]) ||
    (el[0] === 'default' &&
      (typeof el[1] !== 'object' || ['array', 'object'].includes(type)) &&
      name !== 'prBody')
  ) {
    if (type === 'string' && el[0] === 'default') {
      el[1] = `<code>`${el[1]}`</code>`;
    }
    if (
      (type === 'boolean' && el[0] === 'default') ||
      el[0] === 'cli' ||
      el[0] === 'env'
    ) {
      el[1] = `<code>${el[1]}</code>`;
    }
    if (
      ((type === 'object' || type === 'array') &&
        (el[0] === 'default' || el[0] === 'additionalProperties')) ||
      el[0] === 'allowedValues'
    ) {
      if (Object.keys(el[1] ?? []).length === 0) {
        return;
      }
      el[1] = `\n\`\`\`json\n${stringify(el[1], { indent: 2 })}\n\`\`\`\n`;
    }
    data.push(el);
  }
});",1,Code Smell
"const { isHTML, isMarkdown, processedContent } = useMemo(() => {
	const contentIsHTML = isHTMLContent(content)
	if (contentIsHTML) {
		return {
			isHTML: true,
			isMarkdown: false,
			processedContent: DOMPurify.sanitize(content),
		}
	}
	let processed = content
	if (content.includes('\n$ ')) {
		processed = content.replace(/^\$ (.*$)/gm, '```bash\n$ $1\n```')
	}
	if (
		content.trim().startsWith('{') &&
		content.includes('`') &&
		content.includes(':')
	) {
		const lines = content.split('\n')
		let inJsonBlock = false
		const jsonLines: string[] = []
		const otherLines: string[] = []
		for (const line of lines) {
			if (line.trim() === '{' || line.trim() === '[') {
				inJsonBlock = true
			}
			if (inJsonBlock) {
				jsonLines.push(line)
				if (line.trim() === '}' || line.trim() === ']') {
					inJsonBlock = false
				}
			} else {
				otherLines.push(line)
			}
		}
		if (jsonLines.length > 0 && jsonLines.join('\n').trim()) {
			const jsonBlock = jsonLines.join('\n')
			const otherContent = otherLines.join('\n')
			processed =
				otherContent +
				(otherContent ? '\n\n' : '') +
				'```json\n' +
				jsonBlock +
				'\n```'
		}
	}
	return {
		isHTML: false,
		isMarkdown: true,
		processedContent: processed,
	}
}, [content])",1,Code Smell
"export function extractPackageFile(
  content: string,
  packageFile: string,
  config: ExtractConfig,
): PackageFileContent | null {
  logger.trace(`kustomize.extractPackageFile(${packageFile})`);
  const deps: PackageDependency[] = [];
  const pkg = parseKustomize(content, packageFile);
  if (!pkg) {
    return null;
  }
  for (const base of coerceArray(pkg.bases).filter(isString)) {
    const dep = extractResource(base);
    if (dep) {
      deps.push({
        ...dep,
        depType: pkg.kind,
      });
    }
  }
  for (const resource of coerceArray(pkg.resources).filter(isString)) {
    const dep = extractResource(resource);
    if (dep) {
      deps.push({
        ...dep,
        depType: pkg.kind,
      });
    }
  }
  for (const component of coerceArray(pkg.components).filter(isString)) {
    const dep = extractResource(component);
    if (dep) {
      deps.push({
        ...dep,
        depType: pkg.kind,
      });
    }
  }
  for (const image of coerceArray(pkg.images)) {
    const dep = extractImage(image, config.registryAliases);
    if (dep) {
      deps.push({
        ...dep,
        depType: pkg.kind,
      });
    }
  }
  for (const helmChart of coerceArray(pkg.helmCharts)) {
    const dep = extractHelmChart(helmChart, config.registryAliases);
    if (dep) {
      deps.push({
        ...dep,
        depType: 'HelmChart',
      });
    }
  }
  if (!deps.length) {
    return null;
  }
  return { deps };
}",1,Code Smell
"function extractLiteralVersion({
  version,
  depStartIndex,
  depSubContent,
  sectionKey,
}: {
  version: GradleVersionPointerTarget | undefined;
  depStartIndex: number;
  depSubContent: string;
  sectionKey: string;
}): VersionExtract {
  if (!version) {
    return { skipReason: 'unspecified-version' };
  } else if (isString(version)) {
    const fileReplacePosition =
      depStartIndex + findVersionIndex(depSubContent, sectionKey, version);
    return { currentValue: version, fileReplacePosition };
  } else if (isPlainObject(version)) {
    const versionKeys = ['require', 'prefer', 'strictly'];
    let found = false;
    let currentValue: string | undefined;
    let fileReplacePosition: number | undefined;
    if (version.reject || version.rejectAll) {
      return { skipReason: 'unsupported-version' };
    }
    for (const key of versionKeys) {
      if (key in version) {
        if (found) {
          return { skipReason: 'multiple-constraint-dep' };
        }
        found = true;
        currentValue = version[key] as string;
        fileReplacePosition =
          depStartIndex +
          findIndexAfter(depSubContent, sectionKey, currentValue);
      }
    }
    if (found) {
      return { currentValue, fileReplacePosition };
    }
  }
  return { skipReason: 'unspecified-version' };
}",1,Code Smell
"export function extractPackageFile(content: string): PackageFileContent | null {
  const deps: PackageDependency[] = [];
  const tools: PackageDependency[] = [];
  let inExcludeBlock = false;
  const lines = content.split(newlineRegex);
  for (let lineNumber = 0; lineNumber < lines.length; lineNumber += 1) {
    const line = lines[lineNumber];
    const dep = parseLine(line);
    if (inExcludeBlock) {
      if (endBlockRegex.test(line)) {
        inExcludeBlock = false;
      }
      continue;
    }
    if (!dep) {
      if (excludeBlockStartRegex.test(line)) {
        inExcludeBlock = true;
      }
      continue;
    }
    if (dep.depType === 'tool') {
      tools.push(dep);
      continue;
    }
    dep.managerData ??= {};
    dep.managerData.lineNumber = lineNumber;
    deps.push(dep);
  }
  for (const tool of tools) {
    const match = findMatchingModule(tool, deps);
    if (match?.depType === 'indirect') {
      delete match.enabled;
    }
  }
  if (!deps.length) {
    return null;
  }
  return { deps };
}",1,Code Smell
"export async function persistExecutionLogs(
  activeWorkflowId: string,
  executionId: string,
  result: ExecutionResult,
  streamContent?: string
): Promise<string> {
  try {
    const { traceSpans, totalDuration } = buildTraceSpans(result)
    const enrichedResult = {
      ...result,
      traceSpans,
      totalDuration,
    }
    if (streamContent && result.output && typeof streamContent === 'string') {
      enrichedResult.output.content = streamContent
      if (enrichedResult.logs) {
        const streamingBlockId = (result.metadata as any)?.streamingBlockId || null
        for (const log of enrichedResult.logs) {
          const isStreamingBlock = streamingBlockId && log.blockId === streamingBlockId
          if (
            isStreamingBlock &&
            (log.blockType === 'agent' || log.blockType === 'router') &&
            log.output
          ) {
            log.output.content = streamContent
          }
        }
      }
    }
    const response = await fetch(`/api/workflows/${activeWorkflowId}/log`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        executionId,
        result: enrichedResult,
      }),
    })
    if (!response.ok) {
      throw new Error('Failed to persist logs')
    }
    return executionId
  } catch (error) {
    logger.error('Error persisting logs:', error)
    return executionId
  }
}",1,Code Smell
"export async function findPr({
  branchName,
  prTitle,
  state = 'all',
  includeOtherAuthors,
}: FindPRConfig): Promise<Pr | null> {
  logger.debug(`findPr(${branchName}, ${prTitle}, ${state})`);
  if (includeOtherAuthors) {
    const prs = (
      await bitbucketHttp.getJsonUnchecked<PagedResult<PrResponse>>(
        `/2.0/repositories/${config.repository}/pullrequests?q=source.branch.name=`${branchName}`&state=open`,
        { cacheProvider: memCacheProvider },
      )
    ).body.values;
    if (prs.length === 0) {
      logger.debug(`No PR found for branch ${branchName}`);
      return null;
    }
    return utils.prInfo(prs[0]);
  }
  const prList = await getPrList();
  const pr = prList.find(
    (p) =>
      p.sourceBranch === branchName &&
      (!prTitle || p.title.toUpperCase() === prTitle.toUpperCase()) &&
      matchesState(p.state, state),
  );
  if (!pr) {
    return null;
  }
  logger.debug(`Found PR #${pr.number}`);
  if (pr.state === 'closed') {
    const reopenComments = await comments.reopenComments(config, pr.number);
    if (isNonEmptyArray(reopenComments)) {
      if (config.is_private) {
        logger.debug(
          `Found '${comments.REOPEN_PR_COMMENT_KEYWORD}' comment from workspace member. Renovate will reopen PR ${pr.number} as a new PR`,
        );
        return null;
      }
      for (const comment of reopenComments) {
        if (await isAccountMemberOfWorkspace(comment.user, config.repository)) {
          logger.debug(
            `Found '${comments.REOPEN_PR_COMMENT_KEYWORD}' comment from workspace member. Renovate will reopen PR ${pr.number} as a new PR`,
          );
          return null;
        }
      }
    }
  }
  return pr;
}",1,Code Smell
"export function tokenize(input: string): Tok[] {
  const toks: Tok[] = [];
  let i = 0;
  const n = input.length;
  const peek = () => input[i] ?? '';
  const advance = () => input[i++];
  const readWord = () => {
    let s = '';
    while (i < n && isIdent(peek())) s += advance();
    return s;
  };
  const readPhrase = () => {
    advance();
    let s = '';
    while (i < n) {
      const c = advance();
      if (c === `'`) break;
      if (c === '\\' && i < n) {
        const next = advance();
        s += next;
      } else {
        s += c;
      }
    }
    return s;
  };
  while (i < n) {
    const c = peek();
    if (isSpace(c)) {
      i++;
      continue;
    }
    if (c === '(') {
      toks.push({ kind: 'LPAREN' });
      i++;
      continue;
    }
    if (c === ')') {
      toks.push({ kind: 'RPAREN' });
      i++;
      continue;
    }
    if (c === ':') {
      toks.push({ kind: 'COLON' });
      i++;
      continue;
    }
    if (c === `'`) {
      const text = readPhrase();
      toks.push({ kind: 'PHRASE', text });
      continue;
    }
    if (c === '-') {
      toks.push({ kind: 'MINUS' });
      i++;
      continue;
    }
    if (isIdent(c)) {
      const w = readWord();
      const upper = w.toUpperCase();
      if (upper === 'AND') toks.push({ kind: 'AND' });
      else if (upper === 'OR') toks.push({ kind: 'OR' });
      else if (upper === 'NOT') toks.push({ kind: 'NOT' });
      else toks.push({ kind: 'WORD', text: w });
      continue;
    }
    i++;
  }
  toks.push({ kind: 'EOF' });
  return toks;
}",1,Code Smell
"export function rangeToString(range: NugetRange): string {
  if (range.type === 'nuget-exact-range') {
    return `[${versionToString(range.version)}]`;
  }
  if (range.type === 'nuget-floating-range') {
    const { major, minor, patch, revision, floating, prerelease } = range;
    let res = '';
    if (prerelease) {
      res = `-${prerelease}`;
    }
    if (revision !== undefined) {
      const revisionPart =
        floating === 'revision'
          ? floatingComponentToString(revision)
          : `${revision}`;
      res = `.${revisionPart}${res}`;
    }
    if (patch !== undefined) {
      const patchPart =
        floating === 'patch' ? floatingComponentToString(patch) : `${patch}`;
      res = `.${patchPart}${res}`;
    }
    if (minor !== undefined) {
      const minorPart =
        floating === 'minor' ? floatingComponentToString(minor) : `${minor}`;
      res = `.${minorPart}${res}`;
    }
    if (major !== undefined) {
      const majorPart =
        floating === 'major' ? floatingComponentToString(major) : `${major}`;
      res = `${majorPart}${res}`;
    }
    return res;
  }
  const { min, max, minInclusive, maxInclusive } = range;
  const leftBracket = minInclusive ? '[' : '(';
  const rightBracket = maxInclusive ? ']' : ')';
  if (min && max) {
    const minStr =
      min.type === 'nuget-version' ? versionToString(min) : rangeToString(min);
    const maxStr = versionToString(max);
    return `${leftBracket}${minStr},${maxStr}${rightBracket}`;
  }
  if (min) {
    const minStr =
      min.type === 'nuget-version' ? versionToString(min) : rangeToString(min);
    return `${leftBracket}${minStr},${rightBracket}`;
  }
  const maxStr = versionToString(max);
  return `${leftBracket},${maxStr}${rightBracket}`;
}",1,Code Smell
"const render = () => {
	if (!this.gl || !this.program || this.effects.size === 0) {
		this.animationFrame = requestAnimationFrame(render)
		return
	}
	const currentTime = (performance.now() - this.startTime) / 1000
	for (const [id, effect] of Array.from(this.effects)) {
		const mousePos = this.mousePositions.get(id) || { x: 0, y: 0 }
		if (effect.width <= 0 || effect.height <= 0) {
			continue
		}
		if (
			this.canvas!.width !== effect.width ||
			this.canvas!.height !== effect.height
		) {
			this.canvas!.width = effect.width
			this.canvas!.height = effect.height
			this.gl.viewport(0, 0, effect.width, effect.height)
		}
		this.gl.clearColor(0, 0, 0, 0)
		this.gl.clear(this.gl.COLOR_BUFFER_BIT)
		if (this.uniforms.resolution) {
			this.gl.uniform2f(
				this.uniforms.resolution,
				effect.width,
				effect.height,
			)
		}
		if (this.uniforms.time) {
			this.gl.uniform1f(this.uniforms.time, currentTime)
		}
		if (this.uniforms.mouse) {
			this.gl.uniform2f(this.uniforms.mouse, mousePos.x, mousePos.y)
		}
		if (this.uniforms.expanded) {
			this.gl.uniform1f(
				this.uniforms.expanded,
				effect.isExpanded ? 1.0 : 0.0,
			)
		}
		this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4)
		const targetCtx = effect.targetCanvas.getContext(`2d`)
		if (targetCtx) {
			targetCtx.clearRect(0, 0, effect.width, effect.height)
			targetCtx.drawImage(this.canvas!, 0, 0)
		}
	}
	this.animationFrame = requestAnimationFrame(render)
}",1,Code Smell
"export function extractReleaseResult(
  ...composerReleasesArrays: ComposerReleases[]
): ReleaseResult | null {
  const releases: Release[] = [];
  let homepage: string | null | undefined;
  let sourceUrl: string | null | undefined;
  for (const composerReleasesArray of composerReleasesArrays) {
    for (const composerRelease of composerReleasesArray) {
      const version = composerRelease.version.replace(/^v/, '');
      const gitRef = composerRelease.version;
      const dep: Release = { version, gitRef };
      if (composerRelease.time) {
        dep.releaseTimestamp = composerRelease.time;
      }
      if (composerRelease.require?.php) {
        dep.constraints = { php: [composerRelease.require.php] };
      }
      releases.push(dep);
      if (!homepage && composerRelease.homepage) {
        homepage = composerRelease.homepage;
      }
      if (!sourceUrl && composerRelease.source?.url) {
        sourceUrl = composerRelease.source.url;
      }
    }
  }
  if (releases.length === 0) {
    return null;
  }
  const result: ReleaseResult = { releases };
  if (homepage) {
    result.homepage = homepage;
  }
  if (sourceUrl) {
    result.sourceUrl = sourceUrl;
  }
  return result;
}",1,Code Smell
"function extractTextFromDocument(document: any): string {
  let text = ''
  if (!document.body || !document.body.content) {
    return text
  }
  for (const element of document.body.content) {
    if (element.paragraph) {
      for (const paragraphElement of element.paragraph.elements) {
        if (paragraphElement.textRun?.content) {
          text += paragraphElement.textRun.content
        }
      }
    } else if (element.table) {
      for (const tableRow of element.table.tableRows) {
        for (const tableCell of tableRow.tableCells) {
          if (tableCell.content) {
            for (const cellContent of tableCell.content) {
              if (cellContent.paragraph) {
                for (const paragraphElement of cellContent.paragraph.elements) {
                  if (paragraphElement.textRun?.content) {
                    text += paragraphElement.textRun.content
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return text
}",1,Code Smell
"function reconcile(items: DockerHubTag[], expectedCount: number): boolean {
  let needNextPage = true;
  let earliestDate = null;
  let { updatedAt } = this.cache;
  let latestDate = updatedAt ? DateTime.fromISO(updatedAt) : null;
  for (const newItem of items) {
    const id = newItem.id;
    this.reconciledIds.add(id);
    const oldItem = this.cache.items[id];
    const itemDate = DateTime.fromISO(newItem.last_updated);
    if (!earliestDate || earliestDate > itemDate) {
      earliestDate = itemDate;
    }
    if (!latestDate || latestDate < itemDate) {
      latestDate = itemDate;
      updatedAt = newItem.last_updated;
    }
    if (dequal(oldItem, newItem)) {
      needNextPage = false;
      continue;
    }
    this.cache.items[newItem.id] = newItem;
    this.isChanged = true;
  }
  this.cache.updatedAt = updatedAt;
  if (earliestDate && latestDate) {
    for (const [key, item] of Object.entries(this.cache.items)) {
      const id = parseInt(key);
      const itemDate = DateTime.fromISO(item.last_updated);
      if (
        itemDate < earliestDate ||
        itemDate > latestDate ||
        this.reconciledIds.has(id)
      ) {
        continue;
      }
      delete this.cache.items[id];
      this.isChanged = true;
    }
    if (Object.keys(this.cache.items).length > expectedCount) {
      return true;
    }
  }
  return needNextPage;
}",1,Code Smell
"sortedLogs.forEach((log) => {
  if (!log.blockId || !log.blockType) return
  const spanId = `${log.blockId}-${new Date(log.startedAt).getTime()}`
  const span = spanMap.get(spanId)
  if (!span) return
  if (spanStack.length > 0) {
    const potentialParent = spanStack[spanStack.length - 1]
    const parentStartTime = new Date(potentialParent.startTime).getTime()
    const parentEndTime = new Date(potentialParent.endTime).getTime()
    const spanStartTime = new Date(span.startTime).getTime()
    if (spanStartTime >= parentStartTime && spanStartTime <= parentEndTime) {
      if (!potentialParent.children) potentialParent.children = []
      potentialParent.children.push(span)
    } else {
      while (
        spanStack.length > 0 &&
        new Date(spanStack[spanStack.length - 1].endTime).getTime() < spanStartTime
      ) {
        spanStack.pop()
      }
      if (spanStack.length > 0) {
        const newParent = spanStack[spanStack.length - 1]
        if (!newParent.children) newParent.children = []
        newParent.children.push(span)
      } else {
        rootSpans.push(span)
      }
    }
  } else {
    rootSpans.push(span)
  }
  if (log.blockType === 'agent' || log.blockType === 'workflow') {
    spanStack.push(span)
  }
})",1,Code Smell
"export async function executeRequest(
  toolId: string,
  tool: ToolConfig,
  requestParams: RequestParams
): Promise<ToolResponse> {
  try {
    const { url, method, headers, body } = requestParams
    const externalResponse = await fetch(url, { method, headers, body })
    if (!externalResponse.ok) {
      let errorContent
      try {
        errorContent = await externalResponse.json()
      } catch (_e) {
        errorContent = { message: externalResponse.statusText }
      }
      if (tool.transformError) {
        try {
          const errorResult = tool.transformError(errorContent)
          if (typeof errorResult === 'string') {
            throw new Error(errorResult)
          }
          const transformedError = await errorResult
          if (typeof transformedError === 'string') {
            throw new Error(transformedError)
          }
          if (
            transformedError &&
            typeof transformedError === 'object' &&
            'error' in transformedError
          ) {
            throw new Error(transformedError.error || 'Tool returned an error')
          }
          throw new Error('Tool returned an error')
        } catch (e) {
          if (e instanceof Error) {
            throw e
          }
          throw new Error(`${toolId} API error: ${externalResponse.statusText}`)
        }
      } else {
        const error = errorContent.message || `${toolId} API error: ${externalResponse.statusText}`
        logger.error(`${toolId} error:`, { error })
        throw new Error(error)
      }
    }
    const transformResponse =
      tool.transformResponse ||
      (async (resp: Response) => ({
        success: true,
        output: await resp.json(),
      }))
    return await transformResponse(externalResponse)
  } catch (error: any) {
    return {
      success: false,
      output: {},
      error: error.message || 'Unknown error',
    }
  }
}",1,Code Smell
"params: (params) => {
  if (!params || !params.apiKey || params.apiKey.trim() === '') {
    throw new Error('Mistral API key is required')
  }
  const parameters: any = {
    apiKey: params.apiKey.trim(),
    resultType: params.resultType || 'markdown',
  }
  const inputMethod = params.inputMethod || 'url'
  if (inputMethod === 'url') {
    if (!params.filePath || params.filePath.trim() === '') {
      throw new Error('PDF Document URL is required')
    }
    parameters.filePath = params.filePath.trim()
  } else if (inputMethod === 'upload') {
    if (!params.fileUpload) {
      throw new Error('Please upload a PDF document')
    }
    parameters.fileUpload = params.fileUpload
  }
  let pagesArray: number[] | undefined
  if (params.pages && params.pages.trim() !== '') {
    try {
      pagesArray = params.pages
        .split(',')
        .map((p: string) => p.trim())
        .filter((p: string) => p.length > 0)
        .map((p: string) => {
          const num = Number.parseInt(p, 10)
          if (Number.isNaN(num) || num < 0) {
            throw new Error(`Invalid page number: ${p}`)
          }
          return num
        })
      if (pagesArray && pagesArray.length === 0) {
        pagesArray = undefined
      }
    } catch (error: any) {
      throw new Error(`Page number format error: ${error.message}`)
    }
  }
  if (pagesArray && pagesArray.length > 0) {
    parameters.pages = pagesArray
  }
  return parameters
}",1,Code Smell
"export function setNpmrc(input?: string): void {
  if (input) {
    if (input === npmrcRaw) {
      return;
    }
    const existingNpmrc = npmrc;
    npmrcRaw = input;
    logger.debug('Setting npmrc');
    npmrc = ini.parse(input.replace(regEx(/\\n/g), '\n'));
    const exposeAllEnv = GlobalConfig.get('exposeAllEnv');
    for (const [key, val] of Object.entries(npmrc)) {
      if (
        !exposeAllEnv &&
        key.endsWith('registry') &&
        isString(val) &&
        val.includes('localhost')
      ) {
        logger.debug(
          { key, val },
          'Detected localhost registry - rejecting npmrc file',
        );
        npmrc = existingNpmrc;
        return;
      }
    }
    if (exposeAllEnv) {
      for (const key of Object.keys(npmrc)) {
        npmrc[key] = envReplace(npmrc[key]);
      }
    }
    const npmrcRules = convertNpmrcToRules(npmrc);
    if (npmrcRules.hostRules?.length) {
      npmrcRules.hostRules.forEach((hostRule) => hostRules.add(hostRule));
    }
    packageRules = npmrcRules.packageRules;
  } else if (npmrc) {
    logger.debug('Resetting npmrc');
    npmrc = {};
    npmrcRaw = '';
    packageRules = [];
  }
}",1,Code Smell
"const handleAction = async (action: 'run' | 'skip' | 'background') => {
  if (isProcessing) return
  setButtonsHidden(true)
  if (action === 'background') {
    setIsMovingToBackground(true)
  } else {
    setIsProcessing(true)
  }
  try {
    if (onConfirm) {
      onConfirm()
    }
    const isClientTool = toolRegistry.getTool(toolCall.name) !== undefined
    if (isClientTool) {
      await executeToolWithStateManagement(toolCall, action, {
        onStateChange,
        context,
      })
    } else {
      const toolState =
        action === 'run' ? 'accepted' : action === 'background' ? 'background' : 'rejected'
      const uiState =
        action === 'run' ? 'accepted' : action === 'background' ? 'background' : 'rejected'
      onStateChange(uiState)
      try {
        await notifyServerTool(toolCall.id, toolCall.name, toolState)
      } catch (error) {
        console.error(`Failed to notify server tool ${toolCall.id}:`, error)
        if (action === 'skip') {
          return
        }
        throw error
      }
    }
  } finally {
    setIsProcessing(false)
    setIsMovingToBackground(false)
  }
}",1,Code Smell
"function createOrUpdateCodeRenderable(
  side: 'left' | 'right',
  content: string,
  wrapMode: 'word' | 'char' | 'none' | undefined,
  drawUnstyledText?: boolean,
): CodeRenderable {
  const existingRenderable = side === 'left' ? this.leftCodeRenderable : this.rightCodeRenderable
  if (!existingRenderable) {
    const codeOptions: CodeOptions = {
      id: this.id ? `${this.id}-${side}-code` : undefined,
      content,
      filetype: this._filetype,
      wrapMode,
      conceal: this._conceal,
      syntaxStyle: this._syntaxStyle ?? SyntaxStyle.create(),
      width: '100%',
      height: '100%',
      ...(drawUnstyledText !== undefined && { drawUnstyledText }),
      ...(this._selectionBg !== undefined && { selectionBg: this._selectionBg }),
      ...(this._selectionFg !== undefined && { selectionFg: this._selectionFg }),
      ...(this._treeSitterClient !== undefined && { treeSitterClient: this._treeSitterClient }),
    }
    const newRenderable = new CodeRenderable(this.ctx, codeOptions)
    if (side === 'left') {
      this.leftCodeRenderable = newRenderable
    } else {
      this.rightCodeRenderable = newRenderable
    }
    return newRenderable
  } else {
    existingRenderable.content = content
    existingRenderable.wrapMode = wrapMode ?? 'none'
    existingRenderable.conceal = this._conceal
    if (drawUnstyledText !== undefined) {
      existingRenderable.drawUnstyledText = drawUnstyledText
    }
    if (this._filetype !== undefined) {
      existingRenderable.filetype = this._filetype
    }
    if (this._syntaxStyle !== undefined) {
      existingRenderable.syntaxStyle = this._syntaxStyle
    }
    if (this._selectionBg !== undefined) {
      existingRenderable.selectionBg = this._selectionBg
    }
    if (this._selectionFg !== undefined) {
      existingRenderable.selectionFg = this._selectionFg
    }
    return existingRenderable
  }
}",1,Code Smell
"function list(folder = defaultPluginsDir(), progressCallback: null | ProgressCallback = null) {
  try {
    const pluginsData: PluginData[] = [];
    const entries = fs.readdirSync(folder, { withFileTypes: true });
    const pluginFolders = entries.filter(entry => entry.isDirectory());
    for (const pluginFolder of pluginFolders) {
      const pluginDir = path.join(folder, pluginFolder.name);
      if (checkValidPluginFolder(pluginDir)) {
        const packageJsonPath = path.join(pluginDir, 'package.json');
        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
        const pluginName = packageJson.name || pluginFolder.name;
        const pluginTitle = packageJson.artifacthub.title;
        const pluginVersion = packageJson.version || null;
        const artifacthubURL = packageJson.artifacthub ? packageJson.artifacthub.url : null;
        const repoName = packageJson.artifacthub ? packageJson.artifacthub.repoName : null;
        const author = packageJson.artifacthub ? packageJson.artifacthub.author : null;
        const artifacthubVersion = packageJson.artifacthub
          ? packageJson.artifacthub.version
          : null;
        pluginsData.push({
          pluginName,
          pluginTitle,
          pluginVersion,
          folderName: pluginFolder.name,
          artifacthubURL: artifacthubURL,
          repoName: repoName,
          author: author,
          artifacthubVersion: artifacthubVersion,
        });
      }
    }
    if (progressCallback) {
      progressCallback({ type: 'success', message: 'Plugins Listed', data: pluginsData });
    } else {
      return pluginsData;
    }
  } catch (e) {
    if (progressCallback) {
      progressCallback({ type: 'error', message: e instanceof Error ? e.message : String(e) });
    } else {
      throw e;
    }
  }
}",1,Code Smell
"export async function extractDependencies(
  config: RenovateConfig,
  overwriteCache = true,
): Promise<ExtractResult> {
  await readDashboardBody(config);
  let res: ExtractResult = {
    branches: [],
    branchList: [],
    packageFiles: {},
  };
  if (
    GlobalConfig.get('platform') !== 'local' &&
    config.baseBranchPatterns?.length
  ) {
    config.baseBranches = unfoldBaseBranches(
      config.defaultBranch!,
      config.baseBranchPatterns,
    );
    logger.debug({ baseBranches: config.baseBranches }, 'baseBranches');
    const extracted: Record<string, Record<string, PackageFile[]>> = {};
    for (const baseBranch of config.baseBranches) {
      addMeta({ baseBranch });

      if (scm.syncForkWithUpstream) {
        await scm.syncForkWithUpstream(baseBranch);
      }
      if (await scm.branchExists(baseBranch)) {
        const baseBranchConfig = await getBaseBranchConfig(baseBranch, config);
        extracted[baseBranch] = await extract(baseBranchConfig, overwriteCache);
      } else {
        logger.warn({ baseBranch }, 'Base branch does not exist - skipping');
      }
    }
    addSplit('extract');
    for (const baseBranch of config.baseBranches) {
      if (await scm.branchExists(baseBranch)) {
        addMeta({ baseBranch });
        const baseBranchConfig = await getBaseBranchConfig(baseBranch, config);
        const packageFiles = extracted[baseBranch];
        const baseBranchRes = await lookup(baseBranchConfig, packageFiles);
        res.branches = res.branches.concat(baseBranchRes?.branches);
        res.branchList = res.branchList.concat(baseBranchRes?.branchList);
        if (!res.packageFiles || !Object.keys(res.packageFiles).length) {
          res.packageFiles = baseBranchRes?.packageFiles;
        }
      }
    }
    removeMeta(['baseBranch']);
  } else {
    logger.debug('No baseBranches');
    const packageFiles = await extract(config, overwriteCache);
    addSplit('extract');
    if (GlobalConfig.get('dryRun') === 'extract') {
      res.packageFiles = packageFiles;
      logger.info({ packageFiles }, 'Extracted dependencies');
      return res;
    }
    res = await lookup(config, packageFiles);
  }
  addSplit('lookup');
  return res;
}",1,Code Smell
"function extractWithYAMLParser(
  content: string,
  packageFile: string,
  config: ExtractConfig,
): PackageDependency[] {
  logger.trace('github-actions.extractWithYAMLParser()');
  const deps: PackageDependency[] = [];
  const obj = withMeta({ packageFile }, () => Workflow.parse(content));
  if (!obj) {
    return deps;
  }
  if ('runs' in obj && obj.runs.steps) {
    extractSteps(obj.runs.steps, deps);
  } else if ('jobs' in obj) {
    for (const job of Object.values(obj.jobs)) {
      if (job.container) {
        const dep = getDep(job.container, true, config.registryAliases);
        if (dep) {
          dep.depType = 'container';
          deps.push(dep);
        }
      }
      for (const service of job.services) {
        const dep = getDep(service, true, config.registryAliases);
        if (dep) {
          dep.depType = 'service';
          deps.push(dep);
        }
      }
      for (const runner of job['runs-on']) {
        const dep = extractRunner(runner);
        if (dep) {
          deps.push(dep);
        }
      }
      extractSteps(job.steps, deps);
    }
  }
  return deps;
}",1,Code Smell
"export function findDepConstraints(
  packageJson: PackageJson,
  lockEntry: PackageLockOrEntry,
  depName: string,
  currentVersion: string,
  newVersion: string,
  parentDepName?: string,
): ParentDependency[] {
  let parents: ParentDependency[] = [];
  let packageJsonConstraint = packageJson.dependencies?.[depName];
  if (
    packageJsonConstraint &&
    semver.matches(currentVersion, packageJsonConstraint)
  ) {
    parents.push({
      depType: 'dependencies',
      constraint: packageJsonConstraint,
    });
  }
  packageJsonConstraint = packageJson.devDependencies?.[depName];
  if (
    packageJsonConstraint &&
    semver.matches(currentVersion, packageJsonConstraint)
  ) {
    parents.push({
      depType: 'devDependencies',
      constraint: packageJsonConstraint,
    });
  }
  const { dependencies, requires, version } = lockEntry;
  if (parentDepName && requires) {
    let constraint = requires[depName];
    if (constraint) {
      constraint = constraint.replace(regEx(/(\d)rc$/), '$1-rc');
      if (semver.isValid(constraint)) {
        if (semver.matches(currentVersion, constraint)) {
          if (constraint === currentVersion) {
            requires[depName] = newVersion;
          }
          parents.push({
            parentDepName,
            parentVersion: version,
            constraint,
          });
        }
      } else {
        logger.warn(
          { parentDepName, depName, currentVersion, constraint },
          'Parent constraint is invalid',
        );
      }
    }
  }
  if (dependencies) {
    for (const [packageName, dependency] of Object.entries(dependencies)) {
      parents = parents.concat(
        findDepConstraints(
          packageJson,
          dependency,
          depName,
          currentVersion,
          newVersion,
          packageName,
        ),
      );
    }
  }
  const res: ParentDependency[] = [];
  for (const req of parents) {
    const reqStringified = JSON.stringify(req);
    if (!res.find((i) => JSON.stringify(i) === reqStringified)) {
      res.push(req);
    }
  }
  return res;
}",1,Code Smell
"return (sourceFile: ts.SourceFile) => {
  const statements = [...sourceFile.statements]
  for (let i = 0; i < statements.length; i++) {
    const statement = statements[i]
    if (!isImportDeclaration(statement))
      continue
    let bindingPattern: ts.ObjectBindingPattern | ts.Identifier
    const namedBindings = statement.importClause?.namedBindings
    const bindings: ts.BindingElement[] = []
    if (statement.importClause?.name)
      bindings.push(factory.createBindingElement(undefined, factory.createIdentifier('default'), statement.importClause.name))
    if (namedBindings) {
      if (isNamedImports(namedBindings)) {
        for (const specifier of namedBindings.elements)
          bindings.push(factory.createBindingElement(undefined, specifier.propertyName, specifier.name))
        bindingPattern = factory.createObjectBindingPattern(bindings)
      }
      else {
        bindingPattern = factory.createIdentifier(namedBindings.name.text)
      }
    }
    else {
      bindingPattern = factory.createObjectBindingPattern(bindings)
    }
    const newStatement = factory.createVariableStatement(
      undefined,
      factory.createVariableDeclarationList(
        [
          factory.createVariableDeclaration(
            bindingPattern,
            undefined,
            undefined,
            factory.createAwaitExpression(
              factory.createCallExpression(
                factory.createIdentifier('import'),
                undefined,
                [statement.moduleSpecifier],
              ),
            ),
          ),
        ],
        NodeFlags.Const,
      ),
    )
    statements[i] = newStatement
  }
  return factory.updateSourceFile(sourceFile, statements)
}",1,Code Smell
"function formatMessagesForAnthropic(
  messages: Message[],
): Anthropic.MessageParam[] {
  const anthropicMessages: Anthropic.MessageParam[] = [];
  for (const [index, message] of messages.entries()) {
    const messageContentBlocks = message.content as MessageContentBlock[];
    const content: Anthropic.ContentBlockParam[] = [];
    if (
      messageContentBlocks.every((block) => isUserActionContentBlock(block))
    ) {
      const userActionContentBlocks = messageContentBlocks.flatMap(
        (block) => block.content,
      );
      for (const block of userActionContentBlocks) {
        if (isComputerToolUseContentBlock(block)) {
          content.push({
            type: 'text',
            text: `User performed action: ${block.name}\n${JSON.stringify(block.input, null, 2)}`,
          });
        } else {
          content.push(block as Anthropic.ContentBlockParam);
        }
      }
    } else {
      content.push(
        ...messageContentBlocks.map(
          (block) => block as Anthropic.ContentBlockParam,
        ),
      );
    }
    if (index === messages.length - 1) {
      content[content.length - 1]['cache_control'] = {
        type: 'ephemeral',
      };
    }
    anthropicMessages.push({
      role: message.role === Role.USER ? 'user' : 'assistant',
      content: content,
    });
  }
  return anthropicMessages;
}",1,Code Smell
"transferSubscriptionToOrganization: async (orgId: string) => {
  const { hasTeamPlan, hasEnterprisePlan } = get()
  try {
    const userSubResponse = await client.subscription.list()
    let teamSubscription: Subscription | null =
      (userSubResponse.data?.find(
        (sub) => (sub.plan === 'team' || sub.plan === 'enterprise') && sub.status === 'active'
      ) as Subscription | undefined) || null
    if (!teamSubscription && hasEnterprisePlan) {
      const billingResponse = await fetch('/api/billing?context=user')
      if (billingResponse.ok) {
        const billingData = await billingResponse.json()
        if (billingData.success && billingData.data.isEnterprise && billingData.data.status) {
          teamSubscription = {
            id: `subscription_${Date.now()}`,
            plan: billingData.data.plan,
            status: billingData.data.status,
            seats: billingData.data.seats,
            referenceId: billingData.data.organizationId || 'unknown',
          }
        }
      }
    }
    if (teamSubscription) {
      const transferResponse = await fetch(
        `/api/users/me/subscription/${teamSubscription.id}/transfer`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            organizationId: orgId,
          }),
        }
      )
      if (!transferResponse.ok) {
        const errorText = await transferResponse.text()
        let errorMessage = 'Failed to transfer subscription'

        try {
          if (errorText?.trim().startsWith('{')) {
            const errorData = JSON.parse(errorText)
            errorMessage = errorData.error || errorMessage
          }
        } catch (_e) {
          errorMessage = errorText || errorMessage
        }
        throw new Error(errorMessage)
      }
    }
  } catch (error) {
    logger.error('Subscription transfer failed', { error })
    throw error
  }
}",1,Code Smell
"async function getReleases(config: GetReleasesConfig): Promise<ReleaseResult | null> {
  const { packageName } = config;
  logger.trace(`goproxy.getReleases(${packageName})`);
  const goproxy = getEnv().GOPROXY ?? 'https://proxy.golang.org,direct';
  if (goproxy === 'direct') {
    return this.direct.getReleases(config);
  }
  const proxyList = parseGoproxy(goproxy);
  const noproxy = parseNoproxy();
  let result: ReleaseResult | null = null;
  if (noproxy?.test(packageName)) {
    logger.debug(`Fetching ${packageName} via GONOPROXY match`);
    result = await this.direct.getReleases(config);
    return result;
  }
  for (const { url, fallback } of proxyList) {
    try {
      if (url === 'off') {
        break;
      } else if (url === 'direct') {
        result = await this.direct.getReleases(config);
        break;
      }
      const res = await this.getVersionsWithInfo(url, packageName);
      if (res.releases.length) {
        result = res;
        break;
      }
    } catch (err) {
      const potentialHttpError =
        err instanceof ExternalHostError ? err.err : err;
      const statusCode = potentialHttpError?.response?.statusCode;
      const canFallback =
        fallback === '|' ? true : statusCode === 404 || statusCode === 410;
      const msg = canFallback
        ? 'Goproxy error: trying next URL provided with GOPROXY'
        : 'Goproxy error: skipping other URLs provided with GOPROXY';
      logger.debug({ err }, msg);
      if (!canFallback) {
        break;
      }
    }
  }
  if (result && !result.sourceUrl) {
    try {
      const datasource = await BaseGoDatasource.getDatasource(packageName);
      const sourceUrl = getSourceUrl(datasource);
      if (sourceUrl) {
        result.sourceUrl = sourceUrl;
      }
    } catch (err) {
      logger.trace({ err }, `Can't get datasource for ${packageName}`);
    }
  }
  return result;
}",1,Code Smell
"function enforceSizeLimit(chunks: string[]): string[] {
  const finalChunks: string[] = []
  for (const chunk of chunks) {
    const tokens = this.estimateTokens(chunk)
    if (tokens <= 300) {
      finalChunks.push(chunk)
    } else {
      const lines = chunk.split('\n')
      let currentChunk = ''
      for (const line of lines) {
        const testChunk = currentChunk ? `${currentChunk}\n${line}` : line
        if (this.estimateTokens(testChunk) <= 300) {
          currentChunk = testChunk
        } else {
          if (currentChunk.trim()) {
            finalChunks.push(currentChunk.trim())
          }
          currentChunk = line
        }
      }
      if (currentChunk.trim()) {
        finalChunks.push(currentChunk.trim())
      }
    }
  }
  return finalChunks.filter((chunk) => chunk.trim().length > 100)
}",1,Code Smell
"export async function fetchPreset({
  repo,
  filePreset,
  presetPath,
  endpoint: _endpoint,
  tag,
  fetch,
}: FetchPresetConfig): Promise<Nullish<Preset>> {
  const endpoint = ensureTrailingSlash(_endpoint!);
  const [fileName, presetName, subPresetName] = filePreset.split('/');
  const pathPrefix = presetPath ? `${presetPath}/` : '';
  const buildFilePath = (name: string): string => `${pathPrefix}${name}`;
  let jsonContent: any;
  if (fileName === 'default') {
    try {
      jsonContent = await fetch(
        repo,
        buildFilePath('default.json'),
        endpoint,
        tag,
      );
    } catch (err) {
      if (err.message !== PRESET_DEP_NOT_FOUND) {
        throw err;
      }
      jsonContent = await fetch(
        repo,
        buildFilePath('renovate.json'),
        endpoint,
        tag,
      );
      logger.warn(
        {
          repo,
          filePreset,
          presetPath,
          endpoint,
          tag,
        },
        'Fallback to renovate.json file as a preset is deprecated, please use a default.json file instead.',
      );
    }
  } else {
    jsonContent = await fetch(
      repo,
      buildFilePath(
        regEx(/\.json5?$/).test(fileName) ? fileName : `${fileName}.json`,
      ),
      endpoint,
      tag,
    );
  }
  if (!jsonContent) {
    throw new Error(PRESET_DEP_NOT_FOUND);
  }
  if (presetName) {
    const preset = jsonContent[presetName];
    if (!preset) {
      throw new Error(PRESET_NOT_FOUND);
    }
    if (subPresetName) {
      const subPreset = preset[subPresetName];
      if (!subPreset) {
        throw new Error(PRESET_NOT_FOUND);
      }
      return subPreset;
    }
    return preset;
  }
  return jsonContent;
}",1,Code Smell
"export function TagReceiptNodeToReceiptEvent(
  node: BinaryNode,
  me: Me,
): ReceiptEvent[] {
  const { attrs, content } = node;
  const status = getStatusFromReceiptType(attrs.type);
  if (status == null) {
    return null;
  }
  const from = jidNormalizedUser(jid(attrs.from));
  const participant = jidNormalizedUser(jid(attrs.participant));
  const recipient = jidNormalizedUser(jid(attrs.recipient));
  const isLid = from.includes('lid');
  const isNodeFromMe = areJidsSameUser(
    participant || from,
    isLid ? me?.lid : me?.id,
  );
  const remoteJid = !isNodeFromMe || isJidGroup(from) ? from : recipient;
  const fromMe = !recipient || (attrs.type === 'retry' && isNodeFromMe);
  if (status < proto.WebMessageInfo.Status.SERVER_ACK && isNodeFromMe) {
    return [];
  }
  const key: proto.IMessageKey = {
    remoteJid: remoteJid,
    id: '',
    fromMe: fromMe,
  };
  const ids = [attrs.id];
  if (Array.isArray(content)) {
    const items = getBinaryNodeChildren(content[0], 'item');
    ids.push(...items.map((i) => i.attrs.id));
  }
  if (isJidGroup(remoteJid) || isJidStatusBroadcast(remoteJid)) {
    if (participant) {
      key.participant = fromMe ? (isLid ? me.lid : me.id) : recipient;
      const eventParticipant = fromMe ? participant : isLid ? me.lid : me.id;
      return [
        {
          key: key,
          messageIds: ids,
          status: status as any,
          participant: eventParticipant,
          _node: node,
        },
      ];
    } else {
      return handleGroupedReceipts(node, key, status, fromMe, isLid, me);
    }
  }
  return [
    {
      key: key,
      messageIds: ids,
      status: status as any,
      _node: node,
    },
  ];
}",1,Code Smell
"function extractWithRegex(
  content: string,
  config: ExtractConfig,
): PackageDependency[] {
  const customRegistryUrlsPackageDependency =
    detectCustomGitHubRegistryUrlsForActions();
  logger.trace('github-actions.extractWithRegex()');
  const deps: PackageDependency[] = [];
  for (const line of content.split(newlineRegex)) {
    if (line.trim().startsWith('#')) {
      continue;
    }
    const dockerMatch = dockerActionRe.exec(line);
    if (dockerMatch) {
      const [, currentFrom] = dockerMatch;
      const dep = getDep(currentFrom, true, config.registryAliases);
      dep.depType = 'docker';
      deps.push(dep);
      continue;
    }
    const tagMatch = actionRe.exec(line);
    if (tagMatch?.groups) {
      const {
        depName,
        packageName,
        currentValue,
        path = '',
        tag,
        replaceString,
        registryUrl = '',
        commentWhiteSpaces = ' ',
      } = tagMatch.groups;
      let quotes = '';
      if (replaceString.includes(`'`)) {
        quotes = `'`;
      }
      if (replaceString.includes('`')) {
        quotes = '`';
      }
      const dep: PackageDependency = {
        depName,
        ...(packageName !== depName && { packageName }),
        commitMessageTopic: '{{{depName}}} action',
        datasource: GithubTagsDatasource.id,
        versioning: dockerVersioning.id,
        depType: 'action',
        replaceString,
        autoReplaceStringTemplate: `${quotes}{{depName}}${path}@{{#if newDigest}}{{newDigest}}${quotes}{{#if newValue}}${commentWhiteSpaces}# {{newValue}}{{/if}}{{/if}}{{#unless newDigest}}{{newValue}}${quotes}{{/unless}}`,
        ...(registryUrl
          ? detectDatasource(registryUrl)
          : customRegistryUrlsPackageDependency),
      };
      if (shaRe.test(currentValue)) {
        dep.currentValue = tag;
        dep.currentDigest = currentValue;
      } else if (shaShortRe.test(currentValue)) {
        dep.currentValue = tag;
        dep.currentDigestShort = currentValue;
      } else {
        dep.currentValue = currentValue;
      }
      deps.push(dep);
    }
  }
  return deps;
}",1,Code Smell
"async function queryRepoField<T = Record<string, unknown>>(
  query: string,
  fieldName: string,
  options: GraphqlOptions = {},
): Promise<T[]> {
  const result: T[] = [];
  const { paginate = true } = options;
  let optimalCount: null | number = null;
  let count = getGraphqlPageSize(
    fieldName,
    options.count ?? MAX_GRAPHQL_PAGE_SIZE,
  );
  let limit = options.limit ?? 1000;
  let cursor: string | null = null;
  let isIterating = true;
  while (isIterating) {
    const res = await this.requestGraphql<GithubGraphqlRepoData<T>>(query, {
      ...options,
      count: Math.min(count, limit),
      cursor,
      paginate,
    });
    const repositoryData = res?.data?.repository;
    if (
      isNonEmptyObject(repositoryData) &&
      !isNullOrUndefined(repositoryData[fieldName])
    ) {
      optimalCount = count;
      const {
        nodes = [],
        edges = [],
        pageInfo,
      } = repositoryData[fieldName] as GraphqlPaginatedContent<T>;
      result.push(...nodes);
      result.push(...edges);

      limit = Math.max(0, limit - nodes.length - edges.length);

      if (limit === 0) {
        isIterating = false;
      } else if (paginate && pageInfo) {
        const { hasNextPage, endCursor } = pageInfo;
        if (hasNextPage && endCursor) {
          cursor = endCursor;
        } else {
          isIterating = false;
        }
      }
    } else {
      count = Math.floor(count / 2);
      if (count === 0) {
        logger.warn({ query, options, res }, 'Error fetching GraphQL nodes');
        isIterating = false;
      }
    }
    if (!paginate) {
      isIterating = false;
    }
  }
  if (optimalCount && optimalCount < MAX_GRAPHQL_PAGE_SIZE) {
    setGraphqlPageSize(fieldName, optimalCount);
  }
  return result;
}",1,Code Smell
"export async function extractPackageFile(
  content: string,
  packageFile: string,
): Promise<PackageFileContent | null> {
  logger.trace(`cocoapods.extractPackageFile(${packageFile})`);
  const deps: PackageDependency[] = [];
  const lines: string[] = content.split(newlineRegex);
  const registryUrls: string[] = [];
  for (let lineNumber = 0; lineNumber < lines.length; lineNumber += 1) {
    const line = lines[lineNumber];
    const parsedLine = parseLine(line);
    const {
      depName,
      specName,
      currentValue,
      git,
      tag,
      path,
      source,
    }: ParsedLine = parsedLine;
    if (source) {
      registryUrls.push(source.replace(regEx(/\/*$/), ''));
    }
    if (depName) {
      const managerData = { lineNumber };
      let dep: PackageDependency = {
        depName,
        sharedVariableName: specName,
        skipReason: 'unspecified-version',
      };
      if (currentValue) {
        dep = {
          depName,
          sharedVariableName: specName,
          datasource: PodDatasource.id,
          currentValue,
          managerData,
          registryUrls,
        };
      } else if (git) {
        if (tag) {
          dep = { ...gitDep(parsedLine), managerData };
        } else {
          dep = {
            depName,
            sharedVariableName: specName,
            skipReason: 'git-dependency',
          };
        }
      } else if (path) {
        dep = {
          depName,
          sharedVariableName: specName,
          skipReason: 'path-dependency',
        };
      }
      deps.push(dep);
    }
  }
  const res: PackageFileContent = { deps };
  const lockFile = getSiblingFileName(packageFile, 'Podfile.lock');
  if (await localPathExists(lockFile)) {
    res.lockFiles = [lockFile];
  }
  return res;
}",1,Code Smell
"async function searchDefaultOnboardingPreset(
  repository: string,
): Promise<string | undefined> {
  let foundPreset: string | undefined;
  logger.debug('Checking for a default Renovate preset which can be used.');
  const repoPathParts = repository.split('/');
  for (
    let index = repoPathParts.length - 1;
    index >= 1 && !foundPreset;
    index--
  ) {
    const groupName = repoPathParts.slice(0, index).join('/');
    try {
      const repo = `${groupName}/renovate-config`;
      const preset = `local>${repo}`;
      logger.debug(`Checking for preset: ${preset}`);
      if (await getPreset({ repo })) {
        foundPreset = preset;
      }
    } catch (err) {
      if (
        err.message !== PRESET_DEP_NOT_FOUND &&
        !err.message.startsWith('Unsupported platform')
      ) {
        logger.warn({ err }, 'Unknown error fetching default owner preset');
      }
    }
  }
  if (!foundPreset) {
    const orgName = repoPathParts[0];
    const platform = GlobalConfig.get('platform')!;
    try {
      const repo = `${orgName}/.${platform}`;
      const presetName = 'renovate-config';
      const orgPresetName = `local>${repo}:${presetName}`;
      logger.debug(`Checking for preset: ${orgPresetName}`);
      if (
        await getPreset({
          repo,
          presetName,
        })
      ) {
        foundPreset = orgPresetName;
      }
    } catch (err) {
      if (
        err.message !== PRESET_DEP_NOT_FOUND &&
        !err.message.startsWith('Unsupported platform')
      ) {
        logger.warn({ err }, 'Unknown error fetching default owner preset');
      }
    }
  }
  return foundPreset;
}",1,Code Smell
"export async function createPaymentHeader(
  client: Signer | MultiNetworkSigner,
  x402Version: number,
  paymentRequirements: PaymentRequirements,
  config?: X402Config,
): Promise<string> {
  if (paymentRequirements.scheme === `exact`) {
    if (SupportedEVMNetworks.includes(paymentRequirements.network)) {
      const evmClient = isMultiNetworkSigner(client) ? client.evm : client;
      if (!isEvmSignerWallet(evmClient)) {
        throw new Error(`Invalid evm wallet client provided`);
      }
      return await createPaymentHeaderExactEVM(
        evmClient,
        x402Version,
        paymentRequirements,
      );
    }
    if (SupportedSVMNetworks.includes(paymentRequirements.network)) {
      const svmClient = isMultiNetworkSigner(client) ? client.svm : client;
      if (!isSvmSignerWallet(svmClient)) {
        throw new Error(`Invalid svm wallet client provided`);
      }
      return await createPaymentHeaderExactSVM(
        svmClient,
        x402Version,
        paymentRequirements,
        config,
      );
    }
    throw new Error(`Unsupported network`);
  }
  throw new Error(`Unsupported scheme`);
}",1,Code Smell
"async function resolvePluginReleases(
  rootUrl: string,
  artifact: string,
  scalaVersion: string,
): Promise<string[] | null> {
  const searchRoot = `${rootUrl}/${artifact}`;
  const hrefFilterMap = (href: string): string | null => {
    if (href.startsWith('.')) {
      return null;
    }
    return href;
  };
  const searchRootContent = await downloadHttpContent(
    this.http,
    ensureTrailingSlash(searchRoot),
  );
  if (searchRootContent) {
    const releases: string[] = [];
    const scalaVersionItems = extractPageLinks(
      searchRootContent,
      hrefFilterMap,
    );
    const scalaVersions = scalaVersionItems.map((x) =>
      x.replace(regEx(/^scala_/), ''),
    );
    const searchVersions = scalaVersions.includes(scalaVersion)
      ? [scalaVersion]
      : scalaVersions;
    for (const searchVersion of searchVersions) {
      const searchSubRoot = `${searchRoot}/scala_${searchVersion}`;
      const subRootContent = await downloadHttpContent(
        this.http,
        ensureTrailingSlash(searchSubRoot),
      );
      if (subRootContent) {
        const sbtVersionItems = extractPageLinks(
          subRootContent,
          hrefFilterMap,
        );
        for (const sbtItem of sbtVersionItems) {
          const releasesRoot = `${searchSubRoot}/${sbtItem}`;
          const releasesIndexContent = await downloadHttpContent(
            this.http,
            ensureTrailingSlash(releasesRoot),
          );
          if (releasesIndexContent) {
            const releasesParsed = extractPageLinks(
              releasesIndexContent,
              hrefFilterMap,
            );
            releasesParsed.forEach((x) => releases.push(x));
          }
        }
      }
    }
    if (releases.length) {
      return [...new Set(releases)].sort(compare);
    }
  }
  return null;
}",1,Code Smell
"function toSemverRange(range: string): string | null {
  const fromParamMatch = fromParam.exec(range);
  if (fromParamMatch) {
    const [, version] = fromParamMatch;
    if (semver.valid(version)) {
      const nextMajor = `${semver.major(version) + 1}.0.0`;
      return `>=${version} <${nextMajor}`;
    }
    return null;
  }
  const fromRangeMatch = fromRange.exec(range);
  if (fromRangeMatch) {
    const [, version] = fromRangeMatch;
    if (semver.valid(version)) {
      return `>=${version}`;
    }
    return null;
  }
  const binaryRangeMatch = binaryRange.exec(range);
  if (binaryRangeMatch) {
    const [, currentVersion, op, newVersion] = binaryRangeMatch;
    if (semver.valid(currentVersion) && semver.valid(newVersion)) {
      return op === '..<'
        ? `>=${currentVersion} <${newVersion}`
        : `>=${currentVersion} <=${newVersion}`;
    }
    return null;
  }
  const toRangeMatch = toRange.exec(range);
  if (toRangeMatch) {
    const [, op, newVersion] = toRangeMatch;
    if (semver.valid(newVersion)) {
      return op === '..<' ? `<${newVersion}` : `<=${newVersion}`;
    }
  }
  return null;
}",1,Code Smell
"export async function extract(
  config: RenovateConfig,
  overwriteCache = true,
): Promise<Record<string, PackageFile[]>> {
  logger.debug('extract()');
  const { baseBranch } = config;
  const baseBranchSha = await scm.getBranchCommit(baseBranch!);
  let packageFiles: Record<string, PackageFile[]>;
  const cache = getCache();
  cache.scan ??= {};
  const cachedExtract = cache.scan[baseBranch!];
  const configHash = fingerprint(generateFingerprintConfig(config));
  if (
    overwriteCache &&
    isCacheExtractValid(baseBranchSha!, configHash, cachedExtract)
  ) {
    packageFiles = cachedExtract.packageFiles;
    try {
      for (const files of Object.values(packageFiles)) {
        for (const file of files) {
          for (const dep of file.deps) {
            delete dep.updates;
          }
        }
      }
      logger.debug('Deleted cached dep updates');
    } catch (err) {
      logger.info({ err }, 'Error deleting cached dep updates');
    }
  } else {
    await scm.checkoutBranch(baseBranch!);
    const extractResult = (await extractAllDependencies(config)) || {};
    packageFiles = extractResult.packageFiles;
    const { extractionFingerprints } = extractResult;
    if (overwriteCache) {
      cache.scan[baseBranch!] = {
        revision: EXTRACT_CACHE_REVISION,
        sha: baseBranchSha!,
        configHash,
        extractionFingerprints,
        packageFiles,
      };
    }
    const baseBranches = isNonEmptyArray(config.baseBranches)
      ? config.baseBranches
      : [baseBranch];
    Object.keys(cache.scan).forEach((branchName) => {
      if (!baseBranches.includes(branchName)) {
        delete cache.scan![branchName];
      }
    });
  }
  const stats = extractStats(packageFiles);
  logger.info(
    { baseBranch: config.baseBranch, stats },
    `Dependency extraction complete`,
  );
  logger.trace({ config: packageFiles }, 'packageFiles');
  ensureGithubToken(packageFiles);
  return packageFiles;
}",1,Code Smell
"export async function extractAllPackageFiles(
  config: ExtractConfig,
  packageFiles: string[],
): Promise<PackageFile[]> {
  const packages: PackageFile[] = [];
  const additionalRegistryUrls: string[] = [];
  for (const packageFile of packageFiles) {
    const content = await readLocalFile(packageFile, 'utf8');
    if (!content) {
      logger.debug({ packageFile }, 'packageFile has no content');
      continue;
    }
    if (packageFile.endsWith('settings.xml')) {
      const registries = extractRegistries(content);
      if (registries) {
        logger.debug(
          { registries, packageFile },
          'Found registryUrls in settings.xml',
        );
        additionalRegistryUrls.push(...registries);
      }
    } else if (packageFile.endsWith('.mvn/extensions.xml')) {
      const extensions = extractExtensions(content, packageFile);
      if (extensions) {
        packages.push(extensions);
      } else {
        logger.trace({ packageFile }, 'can not read extensions');
      }
    } else {
      const pkg = extractPackage(content, packageFile, config);
      if (pkg) {
        packages.push(pkg);
      } else {
        logger.trace({ packageFile }, 'can not read dependencies');
      }
    }
  }
  if (additionalRegistryUrls) {
    for (const pkgFile of packages) {
      for (const dep of pkgFile.deps) {
        if (dep.registryUrls) {
          dep.registryUrls.unshift(...additionalRegistryUrls);
        }
      }
    }
  }
  return cleanResult(resolveParents(packages));
}",1,Code Smell
"export function generateGlobalVarDeclarations(
  objects: Record<string, any>[],
  maxKeysPerObject?: number
): string {
  if (!Array.isArray(objects)) {
    throw new TypeError('Input must be an array.');
  }
  if (objects.length === 0) {
    return '';
  }
  const topLevelPropertyNodes = new Map<string, TypeInfoNode>();
  let validObjectCount = 0;
  for (const obj of objects) {
    if (typeof obj === 'object' && obj !== null && !Array.isArray(obj)) {
      validObjectCount++;
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          if (!topLevelPropertyNodes.has(key)) {
            topLevelPropertyNodes.set(key, createTypeInfoNode());
          }
          const propertyRootNode = topLevelPropertyNodes.get(key)!;
          aggregateTypeInfo(obj[key], propertyRootNode, 1);
        }
      }
    }
  }
  if (validObjectCount === 0) {
    return '';
  }
  const declarations: string[] = [];
  const sortedKeys = Array.from(topLevelPropertyNodes.keys()).sort();
  for (const key of sortedKeys) {
    if (validIdentifierRegex.test(key)) {
      const propertyNode = topLevelPropertyNodes.get(key)!;
      propertyNode.parentObjectCount = propertyNode.presenceCount;

      const typeString = generateTypeString(propertyNode, undefined, maxKeysPerObject);

      if (typeString !== 'any' || propertyNode.presenceCount > 0) {
        declarations.push(`declare var ${key}: ${typeString};`);
      }
    }
  }
  return declarations.join('\n\n');
}",1,Code Smell
"async function getReleases({
  packageName,
  registryUrl,
}: GetReleasesConfig): Promise<ReleaseResult | null> {
  if (!registryUrl) {
    return null;
  }
  let result: ReleaseResult | null = null;
  const pkgUrl = `${ensureTrailingSlash(
    registryUrl,
  )}api/packages/${packageName}`;
  let raw: HttpResponse<DartResult> | null = null;
  try {
    raw = await this.http.getJsonUnchecked<DartResult>(pkgUrl);
  } catch (err) {
    this.handleGenericErrors(err);
  }
  const body = raw?.body;
  if (body) {
    const { versions, latest } = body;
    const releases = versions
      ?.filter(({ retracted }) => !retracted)
      ?.map(({ version, published }) => ({
        version,
        releaseTimestamp: asTimestamp(published),
      }));
    if (releases && latest) {
      result = { releases };
      const pubspec = latest.pubspec;
      if (pubspec) {
        if (pubspec.homepage) {
          result.homepage = pubspec.homepage;
        }
        if (pubspec.repository) {
          result.sourceUrl = pubspec.repository;
        }
      }
    }
  }
  return result;
}",1,Code Smell
"function getDepWarnings(
  packageFiles: Record<string, PackageFile[]>,
): DepWarnings {
  const warnings: string[] = [];
  const warningFiles: string[] = [];
  for (const files of Object.values(packageFiles ?? {})) {
    for (const file of files ?? []) {
      if (file.packageFile) {
        for (const dep of coerceArray(file.deps)) {
          for (const w of coerceArray(dep.warnings)) {
            const message = w.message;
            if (!warnings.includes(message)) {
              warnings.push(message);
            }
            if (!warningFiles.includes(file.packageFile)) {
              warningFiles.push(file.packageFile);
            }
          }
        }
      }
    }
  }
  if (warnings.length) {
    logger.warn({ warnings, files: warningFiles }, 'Package lookup failures');
  }
  return { warnings, warningFiles };
}",1,Code Smell
"function handleWebSocketMessage(event: MessageEvent): void {
  try {
    const data = JSON.parse(event.data);
    if (!data.clusterId || !data.path) {
      return;
    }
    const key = this.createKey(data.clusterId, data.path, data.query || '');
    if (data.type === 'COMPLETE') {
      this.completedPaths.add(key);
      return;
    }
    let update;
    try {
      update = data.data ? JSON.parse(data.data) : data;
    } catch (err) {
      console.error('Failed to parse update data:', err);
      return;
    }
    if (update && typeof update === 'object') {
      const listeners = this.listeners.get(key);
      if (listeners) {
        for (const listener of listeners) {
          try {
            listener(update);
          } catch (err) {
            console.error('Failed to process WebSocket message:', err);
          }
        }
      }
    }
  } catch (err) {
    console.error('Failed to process WebSocket message:', err);
  }
}",1,Code Smell
"export function extractCollections(lines: string[]): PackageDependency[] {
  const deps: PackageDependency[] = [];
  for (let lineNumber = 0; lineNumber < lines.length; lineNumber += 1) {
    let lineMatch = newBlockRegEx.exec(lines[lineNumber]);
    if (lineMatch) {
      const dep: AnsibleGalaxyPackageDependency = {
        depType: 'galaxy-collection',
        managerData: {
          name: null,
          version: null,
          type: null,
          source: null,
        },
      };
      do {
        interpretLine(lineMatch, dep);
        const line = lines[lineNumber + 1];

        if (!line) {
          break;
        }
        lineMatch = blockLineRegEx.exec(line);
        if (lineMatch) {
          lineNumber += 1;
        }
      } while (lineMatch);
      if (finalize(dep)) {
        delete (dep as PackageDependency).managerData;
        deps.push(dep);
      }
    }
  }
  return deps;
}",1,Code Smell
"const compareVersionParts = (a: VersionParts, b: VersionParts): number => {
  const length = Math.max(a.main.length, b.main.length);
  for (let i = 0; i < length; i += 1) {
    const diff = (a.main[i] ?? 0) - (b.main[i] ?? 0);
    if (diff !== 0) return diff > 0 ? 1 : -1;
  }
  if (a.pre.length === 0 && b.pre.length === 0) return 0;
  if (a.pre.length === 0) return 1;
  if (b.pre.length === 0) return -1;
  const preLen = Math.max(a.pre.length, b.pre.length);
  for (let i = 0; i < preLen; i += 1) {
    const aToken = a.pre[i];
    const bToken = b.pre[i];
    if (aToken === undefined) return -1;
    if (bToken === undefined) return 1;
    if (typeof aToken === 'number' && typeof bToken === 'number') {
      if (aToken > bToken) return 1;
      if (aToken < bToken) return -1;
      continue;
    }
    if (typeof aToken === 'number') return -1;
    if (typeof bToken === 'number') return 1;
    if (aToken > bToken) return 1;
    if (aToken < bToken) return -1;
  }
  return 0;
};",1,Code Smell
"export async function generatePresets(dist: string): Promise<void> {
  let index = 0;
  for (const [name, presetConfig] of Object.entries(presetGroups)) {
    index += 1;
    const formattedName = jsUcfirst(name)
      .replace('Js', 'JS')
      .replace(/s$/, '')
      .replace(/^Config$/, 'Full Config');
    const frontMatter = generateFrontMatter(formattedName, index, name);
    let content = `\n`;
    for (const [preset, value] of Object.entries(presetConfig)) {
      let header = `\n### ${name === 'default' ? '' : name}:${preset}`;
      let presetDescription = value.description as string;
      delete value.description;
      if (!presetDescription) {
        if (value.packageRules?.[0].description) {
          presetDescription = value.packageRules[0].description as string;
          delete value.packageRules[0].description;
        }
      }
      let body = '';
      if (presetDescription) {
        body += `\n\n${presetDescription}\n`;
      } else {
        logger.warn(
          { preset: `${name}:${preset}` },
          'Preset has no description',
        );
      }
      body += '\n```json\n';
      body += JSON.stringify(value, null, 2);
      body += '\n```\n';
      body += '\n----\n';
      if (body.includes('{{arg0}}')) {
        header += '(`<arg0>`';
        if (body.includes('{{arg1}}')) {
          header += ', `<arg1>`';
          if (body.includes('{{arg2}}')) {
            header += ', `<arg2>`';
          }
        }
        header += ')';
        body = body.replace(/{{(arg\d+)}}/g, '$1');
      }
      content += header + body;
    }
    await updateFile(`${dist}/presets-${name}.md`, frontMatter + content);
  }
}",1,Code Smell
"() => {
  if (!focusedEventId) return
  startKeyboardNavigation?.()
  const focusedEvent = events.find(e => e.id === focusedEventId)
  if (!focusedEvent || focusedEvent.eventType !== ConversationEventType.ToolCall) return
  if (focusedEvent.toolName === 'Task' && focusedEvent.toolInputJson && setExpandedToolCall) {
    try {
      const taskInput = JSON.parse(focusedEvent.toolInputJson)
      if (taskInput.subagent_type && taskInput.subagent_type !== 'Task') {
        setExpandedToolCall(focusedEvent)
        return
      }
    } catch (e) {
      console.error('Failed to parse task input:', e)
    }
  }
  if (focusedEvent.toolName === 'Task' && focusedEvent.toolId && hasSubTasks) {
    const subEventsByParent = new Map<string, ConversationEvent[]>()
    events.forEach(event => {
      if (event.parentToolUseId) {
        const siblings = subEventsByParent.get(event.parentToolUseId) || []
        siblings.push(event)
        subEventsByParent.set(event.parentToolUseId, siblings)
      }
    })
    const hasSubEvents = subEventsByParent.has(focusedEvent.toolId)
    if (hasSubEvents) {
      toggleTaskGroup(focusedEvent.toolId)
      return
    }
  }
  if (setExpandedToolResult && setExpandedToolCall) {
    const toolResult = focusedEvent.toolId
      ? events.find(
        e =>
          e.eventType === ConversationEventType.ToolResult &&
          e.toolResultForId === focusedEvent.toolId,
      )
      : null
    setExpandedToolResult(toolResult || null)
    setExpandedToolCall(focusedEvent)
  }
}",1,Code Smell
"function extractFromSection(
  dependencies: PackageDependency<CargoManagerData>[] | undefined,
  cargoRegistries: CargoRegistries,
  target?: string,
): PackageDependency[] {
  if (!dependencies) {
    return [];
  }
  const deps: PackageDependency<CargoManagerData>[] = [];
  for (const dep of Object.values(dependencies)) {
    let registryUrls: string[] | undefined;
    if (dep.managerData?.registryName) {
      const registryUrl =
        getCargoIndexEnv(dep.managerData.registryName) ??
        cargoRegistries[dep.managerData?.registryName];
      if (registryUrl) {
        if (registryUrl !== DEFAULT_REGISTRY_URL) {
          registryUrls = [registryUrl];
        }
      } else {
        dep.skipReason = 'unknown-registry';
      }
    }
    if (registryUrls) {
      dep.registryUrls = registryUrls;
    } else {
      if (cargoRegistries[DEFAULT_REGISTRY_ID]) {
        if (cargoRegistries[DEFAULT_REGISTRY_ID] !== DEFAULT_REGISTRY_URL) {
          dep.registryUrls = [cargoRegistries[DEFAULT_REGISTRY_ID]];
        }
      } else {
        dep.skipReason = 'unknown-registry';
      }
    }
    if (target) {
      dep.target = target;
    }
    deps.push(dep);
  }
  return deps;
}",1,Code Smell
"export function getAbandonedPackagesMd(
  packageFiles: Record<string, PackageFile[]>,
): string {
  const abandonedPackages: Record<
    string,
    Record<string, string | undefined | null>
  > = {};
  let abandonedCount = 0;
  for (const [manager, managerPackageFiles] of Object.entries(packageFiles)) {
    for (const packageFile of managerPackageFiles) {
      for (const dep of coerceArray(packageFile.deps)) {
        if (dep.depName && dep.isAbandoned) {
          abandonedCount++;
          abandonedPackages[manager] = abandonedPackages[manager] || {};
          abandonedPackages[manager][dep.depName] = dep.mostRecentTimestamp;
        }
      }
    }
  }
  if (abandonedCount === 0) {
    return '';
  }
  let abandonedMd = '> ℹ **Note**\n> \n';
  abandonedMd +=
    'These dependencies have not received updates for an extended period and may be unmaintained:\n\n';
  abandonedMd += '<details>\n';
  abandonedMd += `<summary>View abandoned dependencies (${abandonedCount})</summary>\n\n`;
  abandonedMd += '| Datasource | Name | Last Updated |\n';
  abandonedMd += '|------------|------|-------------|\n';
  for (const manager of Object.keys(abandonedPackages).sort()) {
    const deps = abandonedPackages[manager];
    for (const depName of Object.keys(deps).sort()) {
      const mostRecentTimestamp = deps[depName];
      const formattedDate = mostRecentTimestamp
        ? DateTime.fromISO(mostRecentTimestamp).toFormat('yyyy-MM-dd')
        : 'unknown';
      abandonedMd += `| ${manager} | \`${depName}\` | \`${formattedDate}\` |\n`;
    }
  }
  abandonedMd += '\n</details>\n\n';
  abandonedMd +=
    'Packages are marked as abandoned when they exceed the [`abandonmentThreshold`](https://docs.renovatebot.com/configuration-options/#abandonmentthreshold) since their last release.\n';
  abandonedMd +=
    'Unlike deprecated packages with official notices, abandonment is detected by release inactivity.\n\n';
  return abandonedMd + '\n';
}",1,Code Smell
"transform(data) {
  const derivesMap: Record<string, string[]> = {}
  for (const md of data) {
    const name = basename(md.url, '.md')
    if (name === 'index' || name === 'features')
      continue
    for (const depend of md.frontmatter.depends ?? []) {
      const dependName = depend.match(/\/([\w-]+)($|#)/)?.[1]
      if (dependName) {
        derivesMap[dependName] ??= []
        derivesMap[dependName].push(`features/${name}`)
      }
    }
  }
  const result: Record<string, Feature> = {}
  for (const md of data) {
    const name = basename(md.url, '.md')
    if (name === 'index' || name === 'features')
      continue
    const title = md.src?.match(/^# (.*)$/m)?.[1]?.trim() ?? name
    const derives = md.frontmatter.derives ?? []
    for (const d of derivesMap[name] ?? []) {
      if (!derives.includes(d)) {
        derives.push(d)
      }
    }
    result[name] = {
      name,
      title,
      link: `/features/${name}.html`,
      description: md.frontmatter.description ?? '',
      depends: md.frontmatter.depends ?? [],
      relates: md.frontmatter.relates ?? [],
      derives,
      tags: md.frontmatter.tags ?? [],
      since: md.frontmatter.since,
    }
  }
  return result
}",1,Code Smell
"function splitRecursively(text: string, separatorIndex = 0): string[] {
  const tokenCount = this.estimateTokens(text)
  if (tokenCount <= this.chunkSize) {
    return text.length >= this.minChunkSize ? [text] : []
  }
  if (separatorIndex >= this.separators.length) {
    const chunks: string[] = []
    const targetLength = Math.ceil((text.length * this.chunkSize) / tokenCount)
    for (let i = 0; i < text.length; i += targetLength) {
      const chunk = text.slice(i, i + targetLength).trim()
      if (chunk.length >= this.minChunkSize) {
        chunks.push(chunk)
      }
    }
    return chunks
  }
  const separator = this.separators[separatorIndex]
  const parts = text.split(separator).filter((part) => part.trim())

  if (parts.length <= 1) {
    return this.splitRecursively(text, separatorIndex + 1)
  }
  const chunks: string[] = []
  let currentChunk = ''
  for (const part of parts) {
    const testChunk = currentChunk + (currentChunk ? separator : '') + part
    if (this.estimateTokens(testChunk) <= this.chunkSize) {
      currentChunk = testChunk
    } else {
      if (currentChunk.trim() && currentChunk.length >= this.minChunkSize) {
        chunks.push(currentChunk.trim())
      }
      if (this.estimateTokens(part) > this.chunkSize) {
        chunks.push(...this.splitRecursively(part, separatorIndex + 1))
        currentChunk = ''
      } else {
        currentChunk = part
      }
    }
  }
  if (currentChunk.trim() && currentChunk.length >= this.minChunkSize) {
    chunks.push(currentChunk.trim())
  }
  return chunks
}",1,Code Smell
"function constructProxyRequest(
  request: RelayRequest,
  accessToken: string
): ProxyRequest {
  const wantsBinary = true
  let requestData: any = null
  if (request.content) {
    switch (request.content.kind) {
      case 'json':
        requestData =
          typeof request.content.content === 'string'
            ? request.content.content
            : JSON.stringify(request.content.content)
        break

      case 'binary':
        if (
          request.content.content instanceof Blob ||
          request.content.content instanceof File
        ) {
          requestData = request.content.content
        } else if (typeof request.content.content === 'string') {
          try {
            const base64 =
              request.content.content.split(',')[1] || request.content.content
            const binaryString = window.atob(base64)
            const bytes = new Uint8Array(binaryString.length)
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i)
            }
            requestData = new Blob([bytes.buffer])
          } catch (e) {
            console.error('Error converting binary data:', e)
            requestData = request.content.content
          }
        } else {
          requestData = request.content.content
        }
        break
      case 'multipart':
        requestData = ''
        break
      default:
        requestData = request.content.content
    }
  }
  return {
    accessToken,
    wantsBinary,
    url: request.url,
    method: request.method,
    headers: request.headers,
    params: request.params,
    data: requestData,
    auth:
      request.auth?.kind === 'basic'
        ? {
          username: request.auth.username,
          password: request.auth.password,
        }
        : undefined,
  }
}",1,Code Smell
"const fetchExistingChat = async () => {
    try {
      setIsLoading(true)
      const response = await fetch(`/api/workflows/${workflowId}/chat/status`)
      if (response.ok) {
        const data = await response.json()
        if (data.isDeployed && data.deployment) {
          const detailResponse = await fetch(`/api/chat/edit/${data.deployment.id}`)
          if (detailResponse.ok) {
            const chatDetail = await detailResponse.json()
            setExistingChat(chatDetail)
            setFormData({
              subdomain: chatDetail.subdomain || '',
              title: chatDetail.title || '',
              description: chatDetail.description || '',
              authType: chatDetail.authType || 'public',
              password: '',
              emails: Array.isArray(chatDetail.allowedEmails) ? [...chatDetail.allowedEmails] : [],
              welcomeMessage:
                chatDetail.customizations?.welcomeMessage || 'Hi there! How can I help you today?',
              selectedOutputBlocks: Array.isArray(chatDetail.outputConfigs)
                ? chatDetail.outputConfigs.map(
                    (config: { blockId: string; path: string }) =>
                      `${config.blockId}_${config.path}`
                  )
                : [],
            })
            if (chatDetail.customizations?.imageUrl) {
              setImageUrl(chatDetail.customizations.imageUrl)
            }
            setImageUploadError(null)

            onChatExistsChange?.(true)
          }
        } else {
          setExistingChat(null)
          setImageUrl(null)
          setImageUploadError(null)
          onChatExistsChange?.(false)
        }
      }
    } catch (error) {
      logger.error('Error fetching chat status:', error)
    } finally {
      setIsLoading(false)
    }
  }",1,Code Smell
"async function evaluateDistributionItems(
  distribution: any,
  context: ExecutionContext,
  block: SerializedBlock
): Promise<any[] | Record<string, any> | null> {
  if (
    Array.isArray(distribution) ||
    (typeof distribution === 'object' && distribution !== null)
  ) {
    return distribution
  }
  if (typeof distribution === 'string') {
    try {
      const trimmed = distribution.trim()
      if (trimmed.startsWith('//') || trimmed === '') {
        return []
      }
      if (trimmed.startsWith('[') || trimmed.startsWith('{')) {
        try {
          return JSON.parse(trimmed)
        } catch {
        }
      }
      if (this.resolver) {
        const resolved = this.resolver.resolveBlockReferences(distribution, context, block)
        try {
          return JSON.parse(resolved)
        } catch {
          try {
            const result = new Function(`return ${resolved}`)()
            if (Array.isArray(result) || (typeof result === 'object' && result !== null)) {
              return result
            }
          } catch (e) {
            logger.error(`Error evaluating distribution expression: ${resolved}`, e)
          }
        }
      }
      logger.warn(`Distribution expression evaluation not fully implemented: ${distribution}`)
      return null
    } catch (error) {
      logger.error(`Error evaluating distribution items:`, error)
      return null
    }
  }
  return null
}",1,Code Smell
"async function slice(end: number) {
  if (start === end)
    return
  const raw = lines.slice(start, end).join('\n')
  const slide: SourceSlideInfo = {
    ...parseSlide(raw, options),
    filepath,
    index: slides.length,
    start,
    contentStart,
    end,
  }
  if (extensions) {
    for (const e of extensions) {
      if (e.transformSlide) {
        const newContent = await e.transformSlide(slide.content, slide.frontmatter)
        if (newContent !== undefined)
          slide.content = newContent
        if (typeof slide.frontmatter.title === 'string') {
          slide.title = slide.frontmatter.title
        }
        if (typeof slide.frontmatter.level === 'number') {
          slide.level = slide.frontmatter.level
        }
      }

      if (e.transformNote) {
        const newNote = await e.transformNote(slide.note, slide.frontmatter)
        if (newNote !== undefined)
          slide.note = newNote
      }
    }
  }
  slides.push(slide)
  start = end + 1
  contentStart = end + 1
}",1,Code Smell
"const onSave = useLockFn(async () => {
    try {
      let config: Record<string, any>;
      if (visualization) {
        config = {};
        const dnsConfig = generateDnsConfig();
        if (Object.keys(dnsConfig).length > 0) {
          config.dns = dnsConfig;
        }
        const hosts = parseHosts(values.hosts);
        if (Object.keys(hosts).length > 0) {
          config.hosts = hosts;
        }
      } else {
        const parsedConfig = yaml.load(yamlContent);
        if (typeof parsedConfig !== 'object' || parsedConfig === null) {
          throw new Error(t('settings.modals.dns.errors.invalid'));
        }
        config = parsedConfig as Record<string, any>;
      }
      await invoke('save_dns_config', { dnsConfig: config });
      const [isValid, errorMsg] = await invoke<[boolean, string]>(
        'validate_dns_config',
        {},
      );
      if (!isValid) {
        let cleanErrorMsg = errorMsg;
        if (errorMsg.includes('level=error')) {
          const errorLines = errorMsg
            .split('\n')
            .filter(
              (line) =>
                line.includes('level=error') ||
                line.includes('level=fatal') ||
                line.includes('failed'),
            );
          if (errorLines.length > 0) {
            cleanErrorMsg = errorLines
              .map((line) => {
                const msgMatch = line.match(/msg='([^']+)'/);
                return msgMatch ? msgMatch[1] : line;
              })
              .join(', ');
          }
        }
        showNotice.error(
          'settings.modals.dns.messages.configError',
          cleanErrorMsg,
        );
        return;
      }
      if (clash?.dns?.enable) {
        await invoke('apply_dns_config', { apply: true });
        mutateClash();
      }
      setOpen(false);
      showNotice.success('settings.modals.dns.messages.saved');
    } catch (err) {
      showNotice.error(err);
    }
  });",1,Code Smell
"server.middlewares.use(async (req, res, next) => {
  const match = req.url?.match(regexSlideReqPath)
  if (!match)
    return next()
  const [, no] = match
  const idx = Number.parseInt(no) - 1
  if (req.method === 'GET') {
    res.write(JSON.stringify(withRenderedNote(data.slides[idx])))
    return res.end()
  }
  else if (req.method === 'POST') {
    const body: SlidePatch = await getBodyJson(req)
    const slide = data.slides[idx]
    if (body.content && body.content !== slide.source.content)
      hmrSlidesIndexes.add(idx)
    if (body.content)
      slide.content = slide.source.content = body.content
    if (body.frontmatterRaw != null) {
      if (body.frontmatterRaw.trim() === '') {
        slide.source.frontmatterDoc = slide.source.frontmatterStyle = undefined
      }
      else {
        const parsed = YAML.parseDocument(body.frontmatterRaw)
        if (parsed.errors.length)
          console.error('ERROR when saving frontmatter', parsed.errors)
        else
          slide.source.frontmatterDoc = parsed
      }
    }
    if (body.note)
      slide.note = slide.source.note = body.note
    if (body.frontmatter) {
      updateFrontmatterPatch(slide.source, body.frontmatter)
      Object.assign(slide.frontmatter, body.frontmatter)
    }
    parser.prettifySlide(slide.source)
    const fileContent = await parser.save(data.markdownFiles[slide.source.filepath])
    if (body.skipHmr) {
      skipHmr = {
        filePath: slide.source.filepath,
        fileContent,
      }
      server?.moduleGraph.invalidateModule(
        server.moduleGraph.getModuleById(sourceIds.md[idx])!,
      )
      if (body.frontmatter) {
        server?.moduleGraph.invalidateModule(
          server.moduleGraph.getModuleById(sourceIds.frontmatter[idx])!,
        )
      }
    }
    res.statusCode = 200
    res.write(JSON.stringify(withRenderedNote(slide)))
    return res.end()
  }
  next()
})",1,Code Smell
"export function processSupersedesManagers(extracts: ExtractResults[]): void {
  const rejected: Record<string, string[]> = {};
  for (const primaryExtract of extracts) {
    const primaryManager = primaryExtract.manager;
    const secondaryManagers = get(primaryExtract.manager, 'supersedesManagers');
    if (!isNonEmptyArray(secondaryManagers)) {
      continue;
    }
    if (!primaryExtract.packageFiles) {
      continue;
    }
    const primaryPackageFiles = primaryExtract.packageFiles.map(
      ({ packageFile }) => packageFile,
    );
    for (const secondaryManager of secondaryManagers) {
      const secondaryExtract = extracts.find(
        ({ manager }) => manager === secondaryManager,
      );
      if (!secondaryExtract?.packageFiles) {
        continue;
      }
      for (const { packageFile, lockFiles } of secondaryExtract.packageFiles) {
        if (isNonEmptyArray(lockFiles)) {
          rejected[primaryManager] ??= [];
          rejected[primaryManager].push(packageFile);
          continue;
        }
        if (primaryPackageFiles.includes(packageFile)) {
          rejected[secondaryManager] ??= [];
          rejected[secondaryManager].push(packageFile);
        }
      }
    }
  }
  for (const extract of extracts) {
    const rejectedFiles = rejected[extract.manager];
    if (!isNonEmptyArray(rejectedFiles) || !extract.packageFiles) {
      continue;
    }
    extract.packageFiles = extract.packageFiles.filter(
      ({ packageFile }) => !rejectedFiles.includes(packageFile),
    );
  }
}",1,Code Smell
"releaseResult.releases = filterMap(releaseResult.releases, (release) => {
  const releaseConstraints = release.constraints;
  delete release.constraints;
  if (!configConstraints || !releaseConstraints) {
    return release;
  }
  for (const [name, configConstraint] of Object.entries(configConstraints)) {
    if (!versioning.isValid(configConstraint)) {
      logger.once.warn(
        {
          packageName: config.packageName,
          constraint: configConstraint,
          versioning: versioningName,
        },
        'Invalid constraint used with strict constraintsFiltering',
      );
      continue;
    }
    const constraint = releaseConstraints[name];
    if (!isNonEmptyArray(constraint)) {
      continue;
    }
    let satisfiesConstraints = false;
    for (const releaseConstraint of constraint) {
      if (!releaseConstraint) {
        satisfiesConstraints = true;
        logger.once.debug(
          {
            packageName: config.packageName,
            versioning: versioningName,
            constraint: releaseConstraint,
          },
          'Undefined release constraint',
        );
        break;
      }
      if (!versioning.isValid(releaseConstraint)) {
        logger.once.debug(
          {
            packageName: config.packageName,
            versioning: versioningName,
            constraint: releaseConstraint,
          },
          'Invalid release constraint',
        );
        break;
      }
      if (configConstraint === releaseConstraint) {
        satisfiesConstraints = true;
        break;
      }
      if (versioning.subset?.(configConstraint, releaseConstraint)) {
        satisfiesConstraints = true;
        break;
      }
      if (versioning.matches(configConstraint, releaseConstraint)) {
        satisfiesConstraints = true;
        break;
      }
    }
    if (!satisfiesConstraints) {
      filteredReleases.push(release.version);
      return null;
    }
  }
  return release;
});",1,Code Smell
"function hasCommonConfigSnippet(config: any, commonConfig: any): boolean {
  if (typeof config !== 'object' || config === null) return false;
  if (typeof commonConfig !== 'object' || commonConfig === null) return false;
  for (const key of Object.keys(commonConfig)) {
    if (config[key] === undefined) return false;
    if (JSON.stringify(config[key]) !== JSON.stringify(commonConfig[key])) {
      if (
        typeof config[key] === 'object' &&
        !Array.isArray(config[key]) &&
        typeof commonConfig[key] === 'object' &&
        !Array.isArray(commonConfig[key])
      ) {
        if (!hasCommonConfigSnippet(config[key], commonConfig[key])) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  return true;
}",1,Code Smell
"const handleConfirmDiscard = async () => {
  try {
    if (draftsToDiscard.length === 1) {
      const sessionId = draftsToDiscard[0]
      const currentSession = sessions.find(s => s.id === sessionId)
      await daemonClient.deleteDraftSession(sessionId)
      useStore.getState().removeSession(sessionId)
      const currentIndex = sessions.findIndex(s => s.id === sessionId)
      let nextFocusSession = null
      if (currentIndex > 0) {
        nextFocusSession = sessions[currentIndex - 1]
      } else if (currentIndex < sessions.length - 1) {
        nextFocusSession = sessions[currentIndex + 1]
      }
      if (nextFocusSession && handleFocusSession) {
        handleFocusSession(nextFocusSession)
      }
      toast.success('Draft discarded', {
        description: currentSession?.summary || 'Untitled draft',
        duration: 3000,
      })
    } else {
      const nonSelectedSessions = sessions.filter(s => !draftsToDiscard.includes(s.id))
      const nextFocusSession = nonSelectedSessions.length > 0 ? nonSelectedSessions[0] : null
      await bulkDiscardDrafts(draftsToDiscard)
      if (nextFocusSession && handleFocusSession) {
        handleFocusSession(nextFocusSession)
      }
      toast.success(`Discarded ${draftsToDiscard.length} drafts`, {
        duration: 3000,
      })
    }
    await useStore.getState().refreshSessions()
  } catch (error) {
    toast.error('Failed to discard draft(s)', {
      description: error instanceof Error ? error.message : 'Unknown error',
    })
  } finally {
    setDiscardDialogOpen(false)
    setDraftsToDiscard([])
  }
}",1,Code Smell
"async function onMessageUpdate(updates) {
  for (const update of updates) {
    const jid = jidNormalizedUser(update.key.remoteJid!);
    if (!update.key.id) {
      continue;
    }
    if (!jid) {
      this.logger.warn(
        `got message update for unknown jid. update: '${JSON.stringify(
          update,
        )}'`,
      );
      continue;
    }
    const message = await this.messagesRepo.getByJidById(jid, update.key.id);
    if (!message) {
      this.logger.warn(
        `got update for non-existent message. update: '${JSON.stringify(
          update,
        )}'`,
      );
      continue;
    }
    const fields = { ...update.update };
    const onlyStatusField =
      Object.keys(fields).length === 1 &&
      'status' in fields &&
      fields.status !== null;
    if (onlyStatusField) {
      if (message.status >= fields.status) {
        continue;
      }
    }
    delete fields['key'];
    Object.assign(message, fields);
    const isYetRealMessage =
      isRealMessage(message, this.socket?.authState?.creds?.me?.id) || false;
    if (isYetRealMessage) {
      await this.messagesRepo.upsertOne(message);
    } else {
      await this.messagesRepo.deleteByJidByIds(jid, [update.key.id]);
    }
  }
}",1,Code Smell
"export function extractPackageFile(
  content: string,
  packageFile: string,
  config: ExtractConfig,
): PackageFileContent | null {
  const deps: PackageDependency[] = [];
  const descriptor = parseProjectToml(content, packageFile);
  if (!descriptor) {
    return null;
  }
  if (
    descriptor.io?.buildpacks?.builder &&
    isDockerRef(descriptor.io.buildpacks.builder)
  ) {
    const dep = getDockerDep(
      descriptor.io.buildpacks.builder.replace(DOCKER_PREFIX, ''),
      true,
      config.registryAliases,
    );
    logger.trace(
      {
        depName: dep.depName,
        currentValue: dep.currentValue,
        currentDigest: dep.currentDigest,
      },
      'Cloud Native Buildpacks builder',
    );
    deps.push({ ...dep, commitMessageTopic: 'builder {{depName}}' });
  }
  if (
    descriptor.io?.buildpacks?.group &&
    isArray(descriptor.io.buildpacks.group)
  ) {
    for (const group of descriptor.io.buildpacks.group) {
      if (isBuildpackByURI(group) && isDockerRef(group.uri)) {
        const dep = getDockerDep(
          group.uri.replace(DOCKER_PREFIX, ''),
          true,
          config.registryAliases,
        );
        logger.trace(
          {
            depName: dep.depName,
            currentValue: dep.currentValue,
            currentDigest: dep.currentDigest,
          },
          'Cloud Native Buildpack',
        );
        deps.push(dep);
      } else if (isBuildpackByURI(group) && isBuildpackRegistryRef(group.uri)) {
        const dep = getDep(group.uri.replace(BUILDPACK_REGISTRY_PREFIX, ''));
        if (dep) {
          deps.push(dep);
        }
      } else if (isBuildpackByName(group)) {
        const version = group.version;
        if (version) {
          const dep: PackageDependency = {
            datasource: BuildpacksRegistryDatasource.id,
            currentValue: version,
            packageName: group.id,
          };
          deps.push(dep);
        }
      }
    }
  } 
  if (!deps.length) {
    return null;
  }
  return { deps };
}",1,Code Smell
"async function getRelatedPods(): Promise<Pod[]> {
  if (item instanceof Deployment || item instanceof ReplicaSet || item instanceof DaemonSet) {
    try {
      let labelSelector = '';
      const selector = item.spec.selector;
      if (selector.matchLabels) {
        labelSelector = Object.entries(selector.matchLabels)
          .map(([key, value]) => `${key}=${value}`)
          .join(',');
      }
      if (!labelSelector) {
        const resourceType =
          item instanceof Deployment
            ? 'deployment'
            : item instanceof ReplicaSet
              ? 'replicaset'
              : 'daemonset';
        throw new Error(
          t('translation|No label selectors found for this {{type}}', { type: resourceType })
        );
      }
      const response = await clusterFetch(
        `/api/v1/namespaces/${item.metadata.namespace}/pods?labelSelector=${labelSelector}`,
        { cluster: item.cluster }
      ).then(it => it.json());

      if (!response?.items) {
        throw new Error(t('translation|Invalid response from server'));
      }
      return response.items.map((podData: any) => new Pod(podData));
    } catch (error) {
      console.error('Error in getRelatedPods:', error);
      throw new Error(
        error instanceof Error ? error.message : t('translation|Failed to fetch related pods')
      );
    }
  }
  return [];
}",1,Code Smell
"export async function handleClosedPr(
  config: BranchConfig,
  pr: Pr,
): Promise<void> {
  if (pr.state === 'closed') {
    let content;
    const userStrings = config.userStrings!;
    if (config.updateType === 'major') {
      content = template.compile(userStrings.ignoreMajor, config);
    } else if (config.updateType === 'digest') {
      content = template.compile(userStrings.ignoreDigest, config);
    } else {
      content = template.compile(userStrings.ignoreOther, config);
    }
    content +=
      '\n\nIf you accidentally closed this PR, or if you changed your mind: rename this PR to get a fresh replacement PR.';
    if (!config.suppressNotifications!.includes('prIgnoreNotification')) {
      if (GlobalConfig.get('dryRun')) {
        logger.info(
          `DRY-RUN: Would ensure closed PR comment in PR #${pr.number}`,
        );
      } else {
        await ensureComment({
          number: pr.number,
          topic: userStrings.ignoreTopic,
          content,
        });
      }
    }
    if (await scm.branchExists(config.branchName)) {
      if (GlobalConfig.get('dryRun')) {
        logger.info('DRY-RUN: Would delete branch ' + config.branchName);
      } else {
        await scm.deleteBranch(config.branchName);
      }
    }
  }
}",1,Code Smell
"export function extractPackageFile(
  content: string,
  packageFile?: string,
): PackageFileContent | null {
  let doc: TravisYaml;
  try {
    doc = parseSingleYaml(content);
  } catch (err) {
    logger.debug({ err, packageFile }, 'Failed to parse .travis.yml file.');
    return null;
  }
  let deps: PackageDependency[] = [];
  if (doc && isArray(doc.node_js)) {
    deps = doc.node_js.map((currentValue) => ({
      depName: 'node',
      datasource: NodeVersionDatasource.id,
      currentValue: currentValue.toString(),
    }));
  }
  let matrix_include: TravisMatrixItem[] | undefined;
  if (doc?.jobs?.include) {
    matrix_include = doc.jobs.include;
  } else if (doc?.matrix?.include) {
    matrix_include = doc.matrix.include;
  }
  if (!isArray(matrix_include)) {
    return deps.length ? { deps } : null;
  }
  for (const item of matrix_include) {
    if (item?.node_js) {
      if (isArray(item.node_js)) {
        item.node_js.forEach((currentValue) => {
          deps.push({
            depName: 'node',
            datasource: NodeVersionDatasource.id,
            currentValue: currentValue.toString(),
          });
        });
      } else if (isString(item.node_js)) {
        deps.push({
          depName: 'node',
          datasource: NodeVersionDatasource.id,
          currentValue: item.node_js.toString(),
        });
      }
    }
  }
  if (!deps.length) {
    return null;
  }
  return { deps };
}",1,Code Smell
"export function getPluginBinDirectories(pluginsDir: string): string[] {
  if (!fs.existsSync(pluginsDir)) {
    return [];
  }
  const binDirs: string[] = [];
  try {
    const entries = fs.readdirSync(pluginsDir, { withFileTypes: true });
    const pluginFolders = entries.filter(entry => entry.isDirectory());
    for (const pluginFolder of pluginFolders) {
      if (!validPluginBinFolder(pluginFolder.name)) {
        continue;
      }
      const binDir = path.join(pluginsDir, pluginFolder.name, 'bin');
      if (fs.existsSync(binDir)) {
        if (process.platform !== 'win32') {
          try {
            const files = fs.readdirSync(binDir);
            for (const file of files) {
              const filePath = path.join(binDir, file);
              if (fs.statSync(filePath).isDirectory()) {
                continue;
              }
              fs.chmodSync(filePath, 0o755);
            }
          } catch (err) {
            console.error(`Error setting executable permissions in ${binDir}:`, err);
          }
        }
        binDirs.push(binDir);
      }
    }
  } catch (err) {
    console.error(`Error scanning plugin directories in ${pluginsDir}:`, err);
  }

  return binDirs;
}",1,Code Smell
"function ensureVisibleTextBeforeHighlight(): void {
  const content = this._content
  if (!this._filetype) {
    if (this.isDestroyed) return
    this.textBuffer.setText(content)
    this._shouldRenderTextBuffer = true
    this.updateTextInfo()
    return
  }
  const isInitialContent = this._streaming && !this._hadInitialContent
  const shouldDrawUnstyledNow = this._streaming ? isInitialContent && this._drawUnstyledText : this._drawUnstyledText
  if (this._streaming && !isInitialContent) {
    if (this._lastHighlights.length > 0) {
      const chunks = treeSitterToTextChunks(content, this._lastHighlights, this._syntaxStyle, {
        enabled: this._conceal,
      })
      const partialStyledText = new StyledText(chunks)
      if (this.isDestroyed) return
      this.textBuffer.setStyledText(partialStyledText)
      this._shouldRenderTextBuffer = true
      this.updateTextInfo()
    } else {
      if (this.isDestroyed) return
      this.textBuffer.setText(content)
      this._shouldRenderTextBuffer = true
      this.updateTextInfo()
    }
  } else if (shouldDrawUnstyledNow) {
    if (this.isDestroyed) return
    this.textBuffer.setText(content)
    this._shouldRenderTextBuffer = true
    this.updateTextInfo()
  } else {
    if (this.isDestroyed) return
    this._shouldRenderTextBuffer = false
    this.updateTextInfo()
  }
}",1,Code Smell
"export function parseSync(
  markdown: string,
  filepath: string,
  options: SlidevParserOptions = {},
): SlidevMarkdown {
  const lines = markdown.split(options.preserveCR ? '\n' : /\r?\n/g)
  const slides: SourceSlideInfo[] = []
  let start = 0
  let contentStart = 0
  function slice(end: number) {
    if (start === end)
      return
    const raw = lines.slice(start, end).join('\n')
    const slide: SourceSlideInfo = {
      ...parseSlide(raw, options),
      filepath,
      index: slides.length,
      start,
      contentStart,
      end,
    }
    slides.push(slide)
    start = end + 1
    contentStart = end + 1
  }
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trimEnd()
    if (line.startsWith('---')) {
      slice(i)
      const next = lines[i + 1]
      if (line[3] !== '-' && next?.trim()) {
        start = i
        for (i += 1; i < lines.length; i++) {
          if (lines[i].trimEnd() === '---')
            break
        }
        contentStart = i + 1
      }
    }
    else if (line.trimStart().startsWith('```')) {
      const codeBlockLevel = line.match(/^\s*`+/)![0]
      let j = i + 1
      for (; j < lines.length; j++) {
        if (lines[j].startsWith(codeBlockLevel))
          break
      }
      if (j !== lines.length)
        i = j
    }
  }
  if (start <= lines.length - 1)
    slice(lines.length)
  return {
    filepath,
    raw: markdown,
    slides,
  }
}",1,Code Smell
"async function parseExtractedPackageIndex(
  extractedFile: string,
  _lastTimestamp: Date,
): Promise<Record<string, PackageDescription[]>> {
  const rl = readline.createInterface({
    input: fs.createCacheReadStream(extractedFile),
    terminal: false,
  });
  let currentPackage: PackageDescription = {};
  const allPackages: Record<string, PackageDescription[]> = {};
  for await (const line of rl) {
    if (line === '') {
      if (requiredPackageKeys.every((key) => key in currentPackage)) {
        if (!allPackages[currentPackage.Package!]) {
          allPackages[currentPackage.Package!] = [];
        }
        allPackages[currentPackage.Package!].push(currentPackage);
        currentPackage = {};
      }
    } else {
      for (const key of packageKeys) {
        if (line.startsWith(`${key}:`)) {
          currentPackage[key] = line.substring(key.length + 1).trim();
          break;
        }
      }
    }
  }
  if (requiredPackageKeys.every((key) => key in currentPackage)) {
    if (!allPackages[currentPackage.Package!]) {
      allPackages[currentPackage.Package!] = [];
    }
    allPackages[currentPackage.Package!].push(currentPackage);
  }
  return allPackages;
}",1,Code Smell
"async function getReleases(
  http: Http,
  feedUrl: string,
  pkgName: string,
): Promise<ReleaseResult | null> {
  const dep: ReleaseResult = {
    releases: [],
  };
  let pkgUrlList: string | null = `${feedUrl.replace(
    regEx(/\/+$/),
    '',
  )}/FindPackagesById()?id=%27${pkgName}%27&$select=Version,IsLatestVersion,ProjectUrl,Published`;
  while (pkgUrlList !== null) {
    const pkgVersionsListRaw = await http.getText(pkgUrlList);
    const pkgVersionsListDoc = new XmlDocument(pkgVersionsListRaw.body);
    const pkgInfoList = pkgVersionsListDoc.childrenNamed('entry');
    for (const pkgInfo of pkgInfoList) {
      const version = this.getPkgProp(pkgInfo, 'Version');
      const releaseTimestamp = asTimestamp(
        this.getPkgProp(pkgInfo, 'Published'),
      );
      dep.releases.push({
        version: removeBuildMeta(`${version}`),
        releaseTimestamp,
      });
      try {
        const pkgIsLatestVersion = this.getPkgProp(
          pkgInfo,
          'IsLatestVersion',
        );
        if (pkgIsLatestVersion === 'true') {
          dep.tags = { latest: removeBuildMeta(`${version}`) };
          const projectUrl = this.getPkgProp(pkgInfo, 'ProjectUrl');
          if (projectUrl) {
            dep.sourceUrl = massageUrl(projectUrl);
          }
        }
      } catch (err) {
        logger.debug(
          { err, pkgName, feedUrl },
          `nuget registry failure: can't parse pkg info for project url`,
        );
      }
    }
    const nextPkgUrlListLink = pkgVersionsListDoc
      .childrenNamed('link')
      .find((node) => node.attr.rel === 'next');

    pkgUrlList = nextPkgUrlListLink ? nextPkgUrlListLink.attr.href : null;
  }
  if (dep.releases.length === 0) {
    return null;
  }
  return dep;
}",1,Code Smell
"export function getCharacterPositions(text: string, font: keyof typeof fonts = 'tiny'): number[] {
  const fontDef = getParsedFont(font)
  if (!fontDef) {
    return [0]
  }
  const positions: number[] = [0]
  let currentX = 0
  for (let i = 0; i < text.length; i++) {
    const char = text[i].toUpperCase()
    const charDef = fontDef.chars[char]
    let charWidth = 0
    if (!charDef) {
      const spaceChar = fontDef.chars[' ']
      if (spaceChar && spaceChar[0]) {
        for (const segment of spaceChar[0]) {
          charWidth += segment.text.length
        }
      } else {
        charWidth = 1
      }
    } else if (charDef[0]) {
      for (const segment of charDef[0]) {
        charWidth += segment.text.length
      }
    }
    currentX += charWidth
    if (i < text.length - 1) {
      currentX += fontDef.letterspace_size
    }
    positions.push(currentX)
  }
  return positions
}",1,Code Smell
"export function extractPackage(
  rawContent: string,
  packageFile: string,
  config: ExtractConfig,
): PackageFile | null {
  if (!rawContent) {
    return null;
  }
  const project = parsePom(rawContent, packageFile);
  if (!project) {
    return null;
  }
  const result: MavenInterimPackageFile = {
    datasource: MavenDatasource.id,
    packageFile,
    deps: [],
  };
  result.deps = deepExtract(project);
  const CNBDependencies = getAllCNBDependencies(project, config);
  if (CNBDependencies) {
    result.deps.push(...CNBDependencies);
  }
  const propsNode = project.childNamed('properties');
  const props: Record<string, MavenProp> = {};
  if (propsNode?.children) {
    for (const propNode of propsNode.children as XmlElement[]) {
      const key = propNode.name;
      const val = propNode?.val?.trim();
      if (key && val && propNode.position) {
        const fileReplacePosition = propNode.position;
        props[key] = { val, fileReplacePosition, packageFile };
      }
    }
  }
  result.mavenProps = props;
  const repositories = project.childNamed('repositories');
  if (repositories?.children) {
    const repoUrls: string[] = [];
    for (const repo of repositories.childrenNamed('repository')) {
      const repoUrl = repo.valueWithPath('url')?.trim();
      if (repoUrl) {
        repoUrls.push(repoUrl);
      }
    }
    result.deps.forEach((dep) => {
      if (isArray(dep.registryUrls)) {
        repoUrls.forEach((url) => dep.registryUrls!.push(url));
      }
    });
  }
  if (packageFile && project.childNamed('parent')) {
    const parentPath =
      project.valueWithPath('parent.relativePath')?.trim() ?? '../pom.xml';
    result.parent = resolveParentFile(packageFile, parentPath);
  }
  if (project.childNamed('version')) {
    result.packageFileVersion = project.valueWithPath('version')!.trim();
  }
  return result;
}",1,Code Smell
"const getValidationStatus = (variable: Variable): string | undefined => {
  if (variable.value === '') return undefined
  switch (variable.type) {
    case 'number':
      return Number.isNaN(Number(variable.value)) ? 'Not a valid number' : undefined
    case 'boolean':
      return !/^(true|false)$/i.test(String(variable.value).trim())
        ? 'Expected `true` or `false`'
        : undefined
    case 'object':
      try {
        const valueToEvaluate = String(variable.value).trim()
        if (!valueToEvaluate.startsWith('{') || !valueToEvaluate.endsWith('}')) {
          return 'Not a valid object format'
        }
        const parsed = new Function(`return ${valueToEvaluate}`)()
        if (parsed === null || typeof parsed !== 'object' || Array.isArray(parsed)) {
          return 'Not a valid object'
        }
        return undefined
      } catch (e) {
        logger.info('Object parsing error:', e)
        return 'Invalid object syntax'
      }
    case 'array':
      try {
        const valueToEvaluate = String(variable.value).trim()
        if (!valueToEvaluate.startsWith('[') || !valueToEvaluate.endsWith(']')) {
          return 'Not a valid array format'
        }
        const parsed = new Function(`return ${valueToEvaluate}`)()
        if (!Array.isArray(parsed)) {
          return 'Not a valid array'
        }
        return undefined
      } catch (e) {
        logger.info('Array parsing error:', e)
        return 'Invalid array syntax'
      }
    default:
      return undefined
  }
}",1,Code Smell
"function insertBefore(obj: Renderable | VNode<any, any[]> | unknown, anchor?: Renderable | unknown): number {
  if (!anchor) {
    return this.add(obj)
  }
  if (!obj) {
    return -1
  }
  const renderable = maybeMakeRenderable(this._ctx, obj)
  if (!renderable) {
    return -1
  }
  if (renderable.isDestroyed) {
    if (process.env.NODE_ENV !== 'production') {
      console.warn(`Renderable with id ${renderable.id} was already destroyed, skipping insertBefore`)
    }
    return -1
  }
  if (!isRenderable(anchor)) {
    throw new Error('Anchor must be a Renderable')
  }
  if (anchor.isDestroyed) {
    if (process.env.NODE_ENV !== 'production') {
      console.warn(`Anchor with id ${anchor.id} was already destroyed, skipping insertBefore`)
    }
    return -1
  }
  if (!this.renderableMapById.has(anchor.id)) {
    throw new Error('Anchor does not exist')
  }
  if (renderable.parent === this) {
    this.yogaNode.removeChild(renderable.getLayoutNode())
    this._childrenInLayoutOrder.splice(this._childrenInLayoutOrder.indexOf(renderable), 1)
  } else {
    this.replaceParent(renderable)
    this.needsZIndexSort = true
    this.renderableMapById.set(renderable.id, renderable)
    this._childrenInZIndexOrder.push(renderable)
    if (typeof renderable.onLifecyclePass === 'function') {
      this._ctx.registerLifecyclePass(renderable)
    }
    if (renderable._liveCount > 0) {
      this.propagateLiveCount(renderable._liveCount)
    }
  }
  this.childrenPrimarySortDirty = true
  const anchorIndex = this._childrenInLayoutOrder.indexOf(anchor)
  const insertedIndex = Math.max(0, Math.min(anchorIndex, this._childrenInLayoutOrder.length))
  this._childrenInLayoutOrder.splice(insertedIndex, 0, renderable)
  this.yogaNode.insertChild(renderable.getLayoutNode(), insertedIndex)
  this._shouldUpdateBefore.add(renderable)
  this.requestRender()
  return insertedIndex
}",1,Code Smell
"export async function getYarnLock(filePath: string): Promise<LockFile> {
  const yarnLockRaw = (await readLocalFile(filePath, 'utf8'))!;
  try {
    const parsed = parseSyml(yarnLockRaw);
    const lockedVersions: Record<string, string> = {};
    let lockfileVersion: number | undefined;
    for (const [key, val] of Object.entries(parsed)) {
      if (key === '__metadata') {
        lockfileVersion = parseInt(val.cacheKey);
        logger.once.debug(
          `yarn.lock ${filePath} has __metadata.cacheKey=${lockfileVersion}`,
        );
      } else {
        for (const entry of key.split(', ')) {
          try {
            const { scope, name, range } = structUtils.parseDescriptor(entry);
            const packageName = scope ? `@${scope}/${name}` : name;
            const { selector } = structUtils.parseRange(range);
            logger.trace({ entry, version: val.version });
            lockedVersions[packageName + '@' + selector] = parsed[key].version;
          } catch (err) {
            logger.debug(
              { entry, err },
              'Invalid descriptor or range found in yarn.lock',
            );
          }
        }
      }
    }
    const isYarn1 = !('__metadata' in parsed);
    if (isYarn1) {
      logger.once.debug(
        `yarn.lock ${filePath} is has no __metadata so is yarn 1`,
      );
    } else {
      logger.once.debug(
        `yarn.lock ${filePath} is has __metadata so is yarn 2+`,
      );
    }
    return {
      isYarn1,
      lockfileVersion,
      lockedVersions,
    };
  } catch (err) {
    logger.debug({ filePath, err }, 'Warning: Exception parsing yarn.lock');
    return { isYarn1: true, lockedVersions: {} };
  }
}",1,Code Smell
"function _compare(version: string, other: string): number {
  const parsed1 = this._parse(version);
  const parsed2 = this._parse(other);
  if (!(parsed1 && parsed2)) {
    return 1;
  }
  const length = Math.max(parsed1.release.length, parsed2.release.length);
  for (let i = 0; i < length; i += 1) {
    const part1 = parsed1.release[i];
    const part2 = parsed2.release[i];
    if (part1 === undefined) {
      return 1;
    }
    if (part2 === undefined) {
      return -1;
    }
    if (part1 !== part2) {
      return part1 - part2;
    }
  }
  if (parsed1.prerelease !== parsed2.prerelease) {
    if (!parsed1.prerelease && parsed2.prerelease) {
      return 1;
    }
    if (parsed1.prerelease && !parsed2.prerelease) {
      return -1;
    }
    if (parsed1.prerelease && parsed2.prerelease) {
      return parsed1.prerelease.localeCompare(parsed2.prerelease);
    }
  }
  const suffix1 = coerceString(parsed1.suffix);
  const suffix2 = coerceString(parsed2.suffix);
  return suffix2.localeCompare(suffix1);
}",1,Code Smell
"function compilePrTitle(
  upgrade: BranchUpgradeConfig,
  commitMessage: string,
): void {
  if (upgrade.prTitle) {
    upgrade.prTitle = template.compile(upgrade.prTitle, upgrade);
    upgrade.prTitle = template.compile(upgrade.prTitle, upgrade);
    upgrade.prTitle = template
      .compile(upgrade.prTitle, upgrade)
      .trim()
      .replace(regEx(/\s+/g), ' ');
    if (upgrade.prTitle !== sanitize(upgrade.prTitle)) {
      logger.debug(
        { branchName: upgrade.branchName },
        'Secrets were exposed in PR title',
      );
      throw new Error(CONFIG_SECRETS_EXPOSED);
    }
    if (upgrade.toLowerCase && upgrade.commitMessageLowerCase !== 'never') {
      upgrade.prTitle = upgrade.prTitle.toLowerCase();
    }
  } else {
    [upgrade.prTitle] = commitMessage.split(newlineRegex);
  }
  if (!upgrade.prTitleStrict) {
    upgrade.prTitle += upgrade.hasBaseBranches ? ' ({{baseBranch}})' : '';
    if (upgrade.isGroup) {
      upgrade.prTitle +=
        upgrade.updateType === 'major' && upgrade.separateMajorMinor
          ? ' (major)'
          : '';
      upgrade.prTitle +=
        upgrade.updateType === 'minor' && upgrade.separateMinorPatch
          ? ' (minor)'
          : '';
      upgrade.prTitle +=
        upgrade.updateType === 'patch' && upgrade.separateMinorPatch
          ? ' (patch)'
          : '';
    }
  }
  upgrade.prTitle = template.compile(upgrade.prTitle, upgrade);
  logger.trace(`prTitle: ` + JSON.stringify(upgrade.prTitle));
}",1,Code Smell
"function normalizeNoticeMessage(
  message: NoticeContent,
  params?: Record<string, unknown>,
  raw?: unknown,
): { message?: ReactNode; i18n?: NoticeTranslationDescriptor } {
  const rawText = raw !== undefined ? extractDisplayText(raw) : undefined;
  if (isValidElement(message)) {
    return { message };
  }
  if (isMaybeTranslationDescriptor(message)) {
    const originalParams = message.params ?? {};
    const mergedParams = Object.keys(params ?? {}).length
      ? { ...originalParams, ...params }
      : { ...originalParams };
    if (rawText !== undefined) {
      return {
        i18n: {
          key: 'shared.feedback.notices.prefixedRaw',
          params: {
            ...mergedParams,
            prefixKey: message.key,
            prefixParams: originalParams,
            message: rawText,
          },
        },
      };
    }
    return {
      i18n: {
        key: message.key,
        params: Object.keys(mergedParams).length ? mergedParams : undefined,
      },
    };
  }
  if (typeof message === 'string') {
    if (rawText !== undefined) {
      if (shouldUseTranslationKey(message, params)) {
        return {
          i18n: {
            key: 'shared.feedback.notices.prefixedRaw',
            params: {
              ...(params ?? {}),
              prefixKey: message,
              message: rawText,
            },
          },
        };
      }
      return {
        i18n: {
          key: 'shared.feedback.notices.prefixedRaw',
          params: {
            ...(params ?? {}),
            prefix: message,
            message: rawText,
          },
        },
      };
    }
    if (shouldUseTranslationKey(message, params)) {
      return {
        i18n: {
          key: message,
          params: params && Object.keys(params).length ? params : undefined,
        },
      };
    }
    return { i18n: createRawDescriptor(message) };
  }
  if (rawText !== undefined) {
    return { i18n: createRawDescriptor(rawText) };
  }
  const extracted = extractDisplayText(message);
  if (extracted !== undefined) {
    return { i18n: createRawDescriptor(extracted) };
  }
  return { i18n: createRawDescriptor('') };
}",1,Code Smell
"function getSatisfyingVersion(versions: string[], range: string): string | null {
  const r = parseRange(range);
  if (r) {
    let result: string | null = null;
    let vMax: NugetVersion | undefined;
    for (const version of versions) {
      const v = parseVersion(version);
      if (!v) {
        continue;
      }
      if (!matches(v, r)) {
        continue;
      }
      if (!vMax || compare(v, vMax) > 0) {
        vMax = v;
        result = version;
      }
    }
    return result;
  }
  const u = parseVersion(range);
  if (u) {
    let result: string | null = null;
    let vMax: NugetVersion | undefined;
    for (const version of versions) {
      const v = parseVersion(version);
      if (!v) {
        continue;
      }
      if (compare(v, u) < 0) {
        continue;
      }
      if (!vMax || compare(v, vMax) > 0) {
        vMax = v;
        result = version;
      }
    }
    return result;
  }
  return null;
}",1,Code Smell
"export async function markMessageAsProcessed(
  key: string,
  expirySeconds: number = MESSAGE_ID_EXPIRY
): Promise<void> {
  try {
    const redis = getRedisClient()
    const fullKey = `${MESSAGE_ID_PREFIX}${key}`
    if (redis) {
      await redis.set(fullKey, '1', 'EX', expirySeconds)
    } else {
      const expiry = expirySeconds ? Date.now() + expirySeconds * 1000 : null
      inMemoryCache.set(fullKey, { value: '1', expiry })
      if (inMemoryCache.size > MAX_CACHE_SIZE) {
        const now = Date.now()
        for (const [cacheKey, entry] of inMemoryCache.entries()) {
          if (entry.expiry && entry.expiry < now) {
            inMemoryCache.delete(cacheKey)
          }
        }
        if (inMemoryCache.size > MAX_CACHE_SIZE) {
          const keysToDelete = Array.from(inMemoryCache.keys()).slice(
            0,
            inMemoryCache.size - MAX_CACHE_SIZE
          )
          for (const keyToDelete of keysToDelete) {
            inMemoryCache.delete(keyToDelete)
          }
        }
      }
    }
  } catch (error) {
    logger.error(`Error marking key ${key} as processed:`, { error })
    const fullKey = `${MESSAGE_ID_PREFIX}${key}`
    const expiry = expirySeconds ? Date.now() + expirySeconds * 1000 : null
    inMemoryCache.set(fullKey, { value: '1', expiry })
  }
}",1,Code Smell
"async (searchQuery?: string) => {
  if (!selectedCredentialId) return
  setIsLoading(true)
  try {
    const queryParams = new URLSearchParams({
      credentialId: selectedCredentialId,
    })
    if (searchQuery) {
      queryParams.append('query', searchQuery)
    }
    let apiEndpoint: string
    if (provider === 'outlook') {
      apiEndpoint = `/api/tools/outlook/folders?${queryParams.toString()}`
    } else {
      apiEndpoint = `/api/tools/gmail/labels?${queryParams.toString()}`
    }
    const response = await fetch(apiEndpoint)
    if (response.ok) {
      const data = await response.json()
      const folderList = provider === 'outlook' ? data.folders : data.labels
      setFolders(folderList || [])
      if (selectedFolderId) {
        const folderInfo = folderList.find(
          (folder: FolderInfo) => folder.id === selectedFolderId
        )
        if (folderInfo) {
          setSelectedFolder(folderInfo)
          onFolderInfoChange?.(folderInfo)
        } else if (!searchQuery && provider !== 'outlook') {
          fetchFolderById(selectedFolderId)
        }
      }
    } else {
      logger.error('Error fetching folders:', {
        error: await response.text(),
      })
      setFolders([])
    }
  } catch (error) {
    logger.error('Error fetching folders:', { error })
    setFolders([])
  } finally {
    setIsLoading(false)
  }
}",1,Code Smell
"const loadAllChunks = useCallback(async () => {
  if (!knowledgeBaseId || !documentId || !isMounted) return
  try {
    setIsLoading(true)
    setError(null)
    const allChunksData: ChunkData[] = []
    let hasMore = true
    let offset = 0
    const limit = 50
    while (hasMore && isMounted) {
      const response = await fetch(
        `/api/knowledge/${knowledgeBaseId}/documents/${documentId}/chunks?limit=${limit}&offset=${offset}`
      )
      if (!response.ok) {
        throw new Error('Failed to fetch chunks')
      }
      const result = await response.json()
      if (result.success) {
        allChunksData.push(...result.data)
        hasMore = result.pagination.hasMore
        offset += limit
      } else {
        throw new Error(result.error || 'Failed to fetch chunks')
      }
    }
    if (isMounted) {
      setAllChunks(allChunksData)
      setChunks(allChunksData)
    }
  } catch (err) {
    if (isMounted) {
      setError(err instanceof Error ? err.message : 'Failed to load chunks')
    }
  } finally {
    if (isMounted) {
      setIsLoading(false)
    }
  }
}, [knowledgeBaseId, documentId, isMounted])",1,Code Smell
"function handleGroupedReceipts(
  node: BinaryNode,
  key: proto.IMessageKey,
  status: number,
  fromMe: boolean,
  isLid: boolean,
  me: Me,
): ReceiptEvent[] | null {
  const { content } = node;
  if (!Array.isArray(content)) {
    return [];
  }
  const participantsTags = content.filter((c) => c.tag === 'participants');
  if (participantsTags.length === 0) {
    return null;
  }
  const receiptEvents: ReceiptEvent[] = [];
  for (const participants of participantsTags) {
    const participantKey = participants.attrs?.key;
    if (!participantKey) continue;
    const users = getBinaryNodeChildren(participants, 'user');
    for (const user of users) {
      const userAttrs = user.attrs;
      if (!userAttrs) continue;
      const userJid = jidNormalizedUser(jid(userAttrs.jid));
      if (!userJid) continue;
      key.participant = fromMe ? (isLid ? me.lid : me.id) : userJid;
      const eventParticipant = fromMe ? userJid : isLid ? me.lid : me.id;
      const receiptEvent: ReceiptEvent = {
        key: {
          ...key,
          id: participantKey,
        },
        messageIds: [participantKey],
        status: status as any,
        participant: eventParticipant,
        _node: node,
      };
      receiptEvents.push(receiptEvent);
    }
  }
  return receiptEvents;
}",1,Code Smell
"vi.fn().mockImplementation(async (context) => {
  for (const [parallelId, parallel] of Object.entries(context.workflow?.parallels || {})) {
    if (context.completedLoops.has(parallelId)) {
      continue
    }
    const parallelState = context.parallelExecutions?.get(parallelId)
    if (!parallelState || parallelState.currentIteration === 0) {
      continue
    }
    const checkCount = executionCounts.get(parallelId) || 0
    executionCounts.set(parallelId, checkCount + 1)
    if (checkCount >= maxChecks) {
      context.completedLoops.add(parallelId)
      continue
    }
    let allVirtualBlocksExecuted = true
    const parallelNodes = (parallel as any).nodes || []
    for (const nodeId of parallelNodes) {
      for (let i = 0; i < parallelState.parallelCount; i++) {
        const virtualBlockId = `${nodeId}_parallel_${parallelId}_iteration_${i}`
        if (!context.executedBlocks.has(virtualBlockId)) {
          allVirtualBlocksExecuted = false
          break
        }
      }
      if (!allVirtualBlocksExecuted) break
    }
    if (allVirtualBlocksExecuted && !context.completedLoops.has(parallelId)) {
      context.executedBlocks.delete(parallelId)
      context.activeExecutionPath.add(parallelId)

      for (const nodeId of parallelNodes) {
        context.activeExecutionPath.delete(nodeId)
      }
    }
  }
})",1,Code Smell
"async function getReleases({
  packageName,
  registryUrl,
}: GetReleasesConfig): Promise<ReleaseResult | null> {
  logger.trace(`getReleases(${packageName})`);
  if (!registryUrl) {
    return null;
  }
  try {
    const meta = await this.getRegistryMeta(registryUrl);
    if (
      meta.availablePackages &&
      !meta.availablePackages.includes(packageName)
    ) {
      return null;
    }
    if (meta.metadataUrl) {
      const packagistResult = await this.packagistV2Lookup(
        registryUrl,
        meta.metadataUrl,
        packageName,
      );
      return packagistResult;
    }
    if (meta.packages[packageName]) {
      const result = extractDepReleases(meta.packages[packageName]);
      return result;
    }
    await this.fetchIncludesPackages(registryUrl, meta);
    if (meta.includesPackages[packageName]) {
      return meta.includesPackages[packageName];
    }
    await this.fetchProviderPackages(registryUrl, meta);
    const pkgUrl = this.getPkgUrl(packageName, registryUrl, meta);
    if (!pkgUrl) {
      return null;
    }
    const pkgRes = await this.getJson(pkgUrl, PackagesResponse);
    const dep = extractDepReleases(pkgRes.packages[packageName]);
    logger.trace({ dep }, 'dep');
    return dep;
  } catch (err) {
    if (err.host === 'packagist.org') {
      if (err.code === 'ECONNRESET' || err.code === 'ETIMEDOUT') {
        throw new ExternalHostError(err);
      }
      if (err.statusCode && err.statusCode >= 500 && err.statusCode < 600) {
        throw new ExternalHostError(err);
      }
    }
    throw err;
  }
}",1,Code Smell
"const handleRemoveAllFiles = async (e: React.MouseEvent) => {
  e.preventDefault()
  e.stopPropagation()
  if (!value) return
  const filesToDelete = Array.isArray(value) ? value : [value]
  const _fileCount = filesToDelete.length
  const deletingStatus: Record<string, boolean> = {}
  filesToDelete.forEach((file) => {
    deletingStatus[file.path] = true
  })
  setDeletingFiles(deletingStatus)
  setStoreValue(null)
  useWorkflowStore.getState().triggerUpdate()
  if (fileInputRef.current) {
    fileInputRef.current.value = ''
  }
  const deletionResults = {
    success: 0,
    failures: [] as string[],
  }
  for (const file of filesToDelete) {
    try {
      const response = await fetch('/api/files/delete', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ filePath: file.path }),
      })

      if (response.ok) {
        deletionResults.success++
      } else {
        const errorData = await response.json().catch(() => ({ error: response.statusText }))
        const errorMessage = errorData.error || `Failed to delete file: ${response.status}`
        deletionResults.failures.push(`${file.name}: ${errorMessage}`)
      }
    } catch (error) {
      console.error(`Failed to delete file ${file.name}:`, error)
      deletionResults.failures.push(
        `${file.name}: ${error instanceof Error ? error.message : 'Unknown error'}`
      )
    }
  }
  if (deletionResults.failures.length > 0) {
    if (deletionResults.failures.length === 1) {
      logger.error(`Failed to delete file: ${deletionResults.failures[0]}`, activeWorkflowId)
    } else {
      logger.error(
        `Failed to delete ${deletionResults.failures.length} files: ${deletionResults.failures.join('; ')}`,
        activeWorkflowId
      )
    }
  }
  setDeletingFiles({})
}",1,Code Smell
"export async function extractAllPackageFiles(
  _config: ExtractConfig,
  packageFiles: string[],
): Promise<PackageFile[]> {
  const packages: PackageFile[] = [];
  const proxyUrls: string[] = [];
  let ctxScalaVersion: string | undefined;
  const sortedPackageFiles = sortPackageFiles(packageFiles);
  for (const packageFile of sortedPackageFiles) {
    const content = await readLocalFile(packageFile, 'utf8');
    if (!content) {
      logger.debug({ packageFile }, 'packageFile has no content');
      continue;
    }
    if (packageFile === 'repositories') {
      const urls = extractProxyUrls(content, packageFile);
      proxyUrls.push(...urls);
    } else {
      const pkg = extractPackageFileInternal(
        content,
        packageFile,
        ctxScalaVersion,
      );
      if (pkg) {
        packages.push({ deps: pkg.deps, packageFile });
        if (pkg.managerData?.scalaVersion) {
          ctxScalaVersion = pkg.managerData.scalaVersion;
        }
      }
    }
  }
  for (const pkg of packages) {
    for (const dep of pkg.deps) {
      if (dep.datasource !== GithubReleasesDatasource.id) {
        if (proxyUrls.length > 0) {
          dep.registryUrls!.unshift(...proxyUrls);
        } else if (dep.depType === 'plugin') {
          dep.registryUrls!.unshift(SBT_PLUGINS_REPO, MAVEN_REPO);
        } else {
          dep.registryUrls!.unshift(MAVEN_REPO);
        }
      }
    }
  }
  return packages;
}",1,Code Smell
"const handleKeyDown = (e: React.KeyboardEvent) => {
  const isSchemaPromptVisible = activeSection === 'schema' && schemaGeneration.isPromptVisible
  const isCodePromptVisible = activeSection === 'code' && codeGeneration.isPromptVisible
  if (e.key === 'Escape') {
    if (isSchemaPromptVisible) {
      schemaGeneration.hidePromptInline()
      e.preventDefault()
      e.stopPropagation()
      return
    }
    if (isCodePromptVisible) {
      codeGeneration.hidePromptInline()
      e.preventDefault()
      e.stopPropagation()
      return
    }
    if (!showEnvVars && !showTags) {
      setShowEnvVars(false)
      setShowTags(false)
    }
  }
  if (activeSection === 'schema' && schemaGeneration.isStreaming) {
    e.preventDefault()
    return
  }
  if (activeSection === 'code' && codeGeneration.isStreaming) {
    e.preventDefault()
    return
  }
  if (showEnvVars || showTags) {
    if (['ArrowDown', 'ArrowUp', 'Enter'].includes(e.key)) {
      e.preventDefault()
      e.stopPropagation()
    }
  }
}",1,Code Smell
"export async function clearRenovateRefs(): Promise<void> {
  if (!gitInitialized || !remoteRefsExist) {
    return;
  }
  logger.debug(`Cleaning up Renovate refs: refs/renovate/branches/*`);
  const renovateRefs: string[] = [];
  try {
    const rawOutput = await git.listRemote([
      config.url,
      'refs/renovate/branches/*',
    ]);
    const refs = rawOutput
      .split(newlineRegex)
      .map((line) => line.replace(regEx(/[0-9a-f]+\s+/i), '').trim())
      .filter((line) => line.startsWith('refs/renovate/branches/'));
    renovateRefs.push(...refs);
  } catch (err) {
    logger.warn({ err }, `Renovate refs cleanup error`);
  }
  if (renovateRefs.length) {
    try {
      const pushOpts = ['--delete', 'origin', ...renovateRefs];
      await git.push(pushOpts);
    } catch (err) {
      if (bulkChangesDisallowed(err)) {
        for (const ref of renovateRefs) {
          try {
            const pushOpts = ['--delete', 'origin', ref];
            await git.push(pushOpts);
          } catch (err) {
            logger.debug({ err }, 'Error deleting `refs/renovate/branches/*`');
            break;
          }
        }
      } else {
        logger.warn({ err }, 'Error deleting `refs/renovate/branches/*`');
      }
    }
  }
  remoteRefsExist = false;
}",1,Code Smell
"export async function extractAllPackageFiles(
  config: ExtractConfig,
  packageFiles: string[],
): Promise<PackageFile<NpmManagerData>[]> {
  const npmFiles: PackageFile<NpmManagerData>[] = [];
  for (const packageFile of packageFiles) {
    const content = await readLocalFile(packageFile, 'utf8');
    if (content) {
      const parsedPnpmWorkspaceYaml = tryParsePnpmWorkspaceYaml(content);
      if (parsedPnpmWorkspaceYaml.success) {
        logger.trace(
          { packageFile },
          `Extracting file as a pnpm workspace YAML file`,
        );
        const deps = await extractPnpmWorkspaceFile(
          parsedPnpmWorkspaceYaml.data,
          packageFile,
        );
        if (deps) {
          npmFiles.push({
            ...deps,
            packageFile,
          });
        }
      } else {
        if (packageFile.endsWith('json')) {
          logger.trace({ packageFile }, `Extracting as a package.json file`);
          const deps = await extractPackageFile(content, packageFile, config);
          if (deps) {
            npmFiles.push({
              ...deps,
              packageFile,
            });
          }
        } else {
          logger.trace({ packageFile }, `Extracting as a .yarnrc.yml file`);
          const yarnConfig = loadConfigFromYarnrcYml(content);
          if (yarnConfig?.catalogs || yarnConfig?.catalog) {
            const hasPackageManagerResult = await hasPackageManager(
              upath.dirname(packageFile),
            );
            const catalogsDeps = await extractYarnCatalogs(
              { catalog: yarnConfig.catalog, catalogs: yarnConfig.catalogs },
              packageFile,
              hasPackageManagerResult,
            );
            if (catalogsDeps) {
              npmFiles.push({
                ...catalogsDeps,
                packageFile,
              });
            }
          }
        }
      }
    } else {
      logger.debug({ packageFile }, `No content found`);
    }
  }
  await postExtract(npmFiles);
  return npmFiles;
}",1,Code Smell
"export function safeJoin(basePath: string, ...paths: string[]): string {
  for (const pathSegment of paths) {
    if (path.isAbsolute(pathSegment)) {
      throw new Error(
        `Unsafe path: joining '${paths.join(`, `)}' with base '${basePath}' would escape the base directory`,
      );
    }
    if (pathSegment.startsWith(`~/`)) {
      throw new Error(
        `Unsafe path: joining '${paths.join(`, `)}' with base '${basePath}'' would escape the base directory`,
      );
    }
    if (/^[A-Za-z]:[/\\]/.test(pathSegment)) {
      throw new Error(
        `Unsafe path: joining '${paths.join(`, `)}' with base '${basePath}' would escape the base directory`,
      );
    }
    if (pathSegment.startsWith(`\\\\`)) {
      throw new Error(
        `Unsafe path: joining '${paths.join(`, `)}' with base '${basePath}' would escape the base directory`,
      );
    }
  }
  const joinedPath = path.join(basePath, ...paths);
  const resolvedBasePath = path.resolve(basePath);
  const resolvedJoinedPath = path.resolve(joinedPath);
  const relativePath = path.relative(resolvedBasePath, resolvedJoinedPath);
  if (relativePath.startsWith(`..`) || path.isAbsolute(relativePath)) {
    throw new Error(
      `Unsafe path: joining '${paths.join(`, `)}' with base '${basePath}' would escape the base directory`,
    );
  }
  return joinedPath;
}",0,Clean Code
"export function useCreateApp() {
  const queryClient = useQueryClient();
  const mutation = useMutation<CreateAppResult, Error, CreateAppParams>({
    mutationFn: async (params: CreateAppParams) => {
      if (!params.name.trim()) {
        throw new Error(`App name is required`);
      }
      const ipcClient = IpcClient.getInstance();
      return ipcClient.createApp(params);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`apps`] });
    },
    onError: (error) => {
      showError(error);
    },
  });
  const createApp = async (
    params: CreateAppParams,
  ): Promise<CreateAppResult> => {
    return mutation.mutateAsync(params);
  };
  return {
    createApp,
    isCreating: mutation.isPending,
    error: mutation.error,
  };
}",0,Clean Code
"export const useResizeObserver = (el?: HTMLElement | null) => {
  const resizeObserverRef = useRef<ResizeObserver>();
  const [size, setSize] = useState<Size>({ width: 0, height: 0 });
  const disconnect = useCallback(() => {
    resizeObserverRef.current?.disconnect();
  }, []);
  const observe = useCallback(
    (element: HTMLElement) => {
      disconnect();

      resizeObserverRef.current = new ResizeObserver(() => {
        setSize({
          width: element.clientWidth,
          height: element.clientHeight
        });
      });

      resizeObserverRef.current.observe(element);
    },
    [disconnect]
  );
  useEffect(() => {
    return () => {
      disconnect();
    };
  }, [disconnect]);
  useEffect(() => {
    if (el) observe(el);
  }, [observe, el]);
  return {
    size,
    disconnect,
    observe
  };
};",0,Clean Code
"export function useLanguageModelProviders() {
  const ipcClient = IpcClient.getInstance();
  const { settings, envVars } = useSettings();
  const queryResult = useQuery<LanguageModelProvider[], Error>({
    queryKey: [`languageModelProviders`],
    queryFn: async () => {
      return ipcClient.getLanguageModelProviders();
    },
  });
  const isProviderSetup = (provider: string) => {
    const providerSettings = settings?.providerSettings[provider];
    if (queryResult.isLoading) {
      return false;
    }
    if (providerSettings?.apiKey?.value) {
      return true;
    }
    const providerData = queryResult.data?.find((p) => p.id === provider);
    if (providerData?.envVarName && envVars[providerData.envVarName]) {
      return true;
    }
    return false;
  };
  const isAnyProviderSetup = () => {
    return cloudProviders.some((provider) => isProviderSetup(provider));
  };

  return {
    ...queryResult,
    isProviderSetup,
    isAnyProviderSetup,
  };
}",0,Clean Code
"export const useSwitchProviderMutation = (appId: AppId) => {
  const queryClient = useQueryClient();
  const { t } = useTranslation();
  return useMutation({
    mutationFn: async (providerId: string) => {
      return await providersApi.switch(providerId, appId);
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: [`providers`, appId] });
      try {
        await providersApi.updateTrayMenu();
      } catch (trayError) {
        console.error(
          `Failed to update tray menu after switching provider`,
          trayError,
        );
      }
      toast.success(
        t(`notifications.switchSuccess`, {
          defaultValue: `切换供应商成功`,
          appName: t(`apps.${appId}`, { defaultValue: appId }),
        }),
      );
    },
    onError: (error: Error) => {
      const detail = extractErrorMessage(error) || t(`common.unknown`);
      toast.error(
        t(`notifications.switchFailedTitle`, { defaultValue: `切换失败` }),
        {
          description: t(`notifications.switchFailed`, {
            defaultValue: `切换失败：{{error}}`,
            error: detail,
          }),
          duration: 6000,
          action: {
            label: t(`common.copy`, { defaultValue: `复制` }),
            onClick: () => {
              navigator.clipboard?.writeText(detail).catch(() => undefined);
            },
          },
        },
      );
    },
  });
};",0,Clean Code
"export const useIconCategories = () => {
  const icons = useModelStore((state) => {
    return state.icons;
  });
  const iconCategoriesState = useUiStateStore((state) => {
    return state.iconCategoriesState;
  });
  const iconCategories = useMemo<IconCollectionStateWithIcons[]>(() => {
    return iconCategoriesState.map((collection) => {
      return {
        ...collection,
        icons: icons.filter((icon) => {
          return icon.collection === collection.id;
        })
      };
    });
  }, [icons, iconCategoriesState]);
  return {
    iconCategories
  };
};",0,Clean Code
"export function registerReleaseNoteHandlers() {
  handle(
    `does-release-note-exist`,
    async (_, params: DoesReleaseNoteExistParams) => {
      const { version } = params;
      if (!version || typeof version !== `string`) {
        throw new Error(`Invalid version provided`);
      }
      if (IS_TEST_BUILD) {
        return { exists: false };
      }
      const releaseNoteUrl = `https://www.dyad.sh/docs/releases/${version}`;
      logger.debug(`Checking for release note at: ${releaseNoteUrl}`);
      try {
        const response = await fetch(releaseNoteUrl, { method: `HEAD` });
        if (response.ok) {
          logger.debug(
            `Release note found for version ${version} at ${releaseNoteUrl}`,
          );
          return { exists: true, url: releaseNoteUrl };
        } else if (response.status === 404) {
          logger.debug(
            `Release note not found for version ${version} at ${releaseNoteUrl}`,
          );
          return { exists: false };
        } else {
          logger.warn(
            `Unexpected status code ${response.status} when checking for release note: ${releaseNoteUrl}`,
          );
          return { exists: false };
        }
      } catch (error) {
        logger.error(
          `Error fetching release note for version ${version} at ${releaseNoteUrl}:`,
          error,
        );
        return { exists: false };
      }
    },
  );
  logger.debug(`Registered release note IPC handlers`);
}",0,Clean Code
"export async function generateAuthHeaders(
  auth: HoppRESTAuth,
  request: HoppRESTRequest,
  envVars: Environment[`variables`],
  showKeyIfSecret = false
): Promise<HoppRESTHeader[]> {
  switch (auth.authType) {
    case `basic`:
      return generateBasicAuthHeaders(auth, request, envVars, showKeyIfSecret)
    case `bearer`:
      return generateBearerAuthHeaders(auth, request, envVars, showKeyIfSecret)
    case `api-key`:
      return auth.addTo === `HEADERS`
        ? generateApiKeyAuthHeaders(auth, request, envVars, showKeyIfSecret)
        : []
    case `oauth-2`:
      return generateOAuth2AuthHeaders(auth, request, envVars, showKeyIfSecret)
    case `digest`:
      return generateDigestAuthHeaders(auth, request, envVars, showKeyIfSecret)
    case `aws-signature`:
      return generateAwsSignatureAuthHeaders(auth, request, envVars)
    case `hawk`:
      return generateHawkAuthHeaders(auth, request, envVars, showKeyIfSecret)
    case `jwt`:
      return generateJwtAuthHeaders(auth, request, envVars, showKeyIfSecret)
    default:
      return []
  }
}",0,Clean Code
"export function initializeDatabase(): BetterSQLite3Database<typeof schema> & {
  $client: Database.Database;
} {
  if (_db) return _db as any;
  const dbPath = getDatabasePath();
  logger.log(`Initializing database at:`, dbPath);
  try {
    if (fs.existsSync(dbPath)) {
      const stats = fs.statSync(dbPath);
      if (stats.size < 100) {
        logger.log(`Database file exists but may be corrupted. Removing it...`);
        fs.unlinkSync(dbPath);
      }
    }
  } catch (error) {
    logger.error(`Error checking database file:`, error);
  }
  fs.mkdirSync(getUserDataPath(), { recursive: true });
  fs.mkdirSync(getDyadAppPath(`.`), { recursive: true });
  const sqlite = new Database(dbPath, { timeout: 10000 });
  sqlite.pragma(`foreign_keys = ON`);
  _db = drizzle(sqlite, { schema });
  try {
    const migrationsFolder = path.join(__dirname, `..`, `..`, `drizzle`);
    if (!fs.existsSync(migrationsFolder)) {
      logger.error(`Migrations folder not found:`, migrationsFolder);
    } else {
      logger.log(`Running migrations from:`, migrationsFolder);
      migrate(_db, { migrationsFolder });
    }
  } catch (error) {
    logger.error(`Migration error:`, error);
  }
  return _db as any;
}",0,Clean Code
"handle(`get-user-budget`, async (): Promise<UserBudgetInfo | null> => {
  if (IS_TEST_BUILD) {
    return null;
  }
  logger.info(`Attempting to fetch user budget information.`);
  const settings = readSettings();
  const apiKey = settings.providerSettings?.auto?.apiKey?.value;
  if (!apiKey) {
    logger.error(`LLM Gateway API key (Dyad Pro) is not configured.`);
    return null;
  }
  const url = `https://llm-gateway.dyad.sh/user/info`;
  const headers = {
    'Content-Type': `application/json`,
    Authorization: `Bearer ${apiKey}`,
  };
  try {
    const response = await fetch(url, {
      method: `GET`,
      headers: headers,
    });
    if (!response.ok) {
      const errorBody = await response.text();
      logger.error(
        `Failed to fetch user budget. Status: ${response.status}. Body: ${errorBody}`,
      );
      return null;
    }
    const data = await response.json();
    const userInfoData = data[`user_info`];
    logger.info(`Successfully fetched user budget information.`);
    return UserBudgetInfoSchema.parse({
      usedCredits: userInfoData[`spend`] * CONVERSION_RATIO,
      totalCredits: userInfoData[`max_budget`] * CONVERSION_RATIO,
      budgetResetDate: new Date(userInfoData[`budget_reset_at`]),
    });
  } catch (error: any) {
    logger.error(`Error fetching user budget: ${error.message}`, error);
    return null;
  }
});",0,Clean Code
"export const useRequestNameGeneration = (targetNameRef: Ref<string>) => {
  const toast = useToast()
  const t = useI18n()
  const route = useRoute()
  const targetPage = computed(() => {
    return route.fullPath.includes(`/graphql`) ? `gql` : `rest`
  })
  const isGenerateRequestNamePending = ref(false)
  const generateRequestNameForPlatform =
    platform.experiments?.aiExperiments?.generateRequestName
  const currentUser = useReadonlyStream(
    platform.auth.getCurrentUserStream(),
    platform.auth.getCurrentUser()
  )
  const ENABLE_AI_EXPERIMENTS = useSetting(`ENABLE_AI_EXPERIMENTS`)
  const canDoRequestNameGeneration = computed(() => {
    return ENABLE_AI_EXPERIMENTS.value && !!platform.experiments?.aiExperiments
  })
  const lastTraceID = ref<string | null>(null)
  const generateRequestName = async (
    requestContext: HoppRESTRequest | HoppGQLRequest | null
  ) => {
    if (!currentUser.value) {
      invokeAction(`modals.login.toggle`)
      return
    }
    if (!requestContext || !generateRequestNameForPlatform) {
      toast.error(t(`request.generate_name_error`))
      return
    }
    const namingStyle = useSetting(`AI_REQUEST_NAMING_STYLE`).value
    const customNamingStyle = useSetting(`CUSTOM_NAMING_STYLE`).value
    isGenerateRequestNamePending.value = true
    platform.analytics?.logEvent({
      type: `EXPERIMENTS_GENERATE_REQUEST_NAME_WITH_AI`,
      platform: targetPage.value,
    })
    const result = await generateRequestNameForPlatform(
      JSON.stringify(requestContext),
      namingStyle === `CUSTOM` ? customNamingStyle : namingStyle
    )
    if (result && E.isLeft(result)) {
      toast.error(t(`request.generate_name_error`))
      isGenerateRequestNamePending.value = false
      return
    }
    targetNameRef.value = result.right.request_name
    lastTraceID.value = result.right.trace_id
    isGenerateRequestNamePending.value = false
  }
  return {
    generateRequestName,
    isGenerateRequestNamePending,
    canDoRequestNameGeneration,
    lastTraceID,
  }
}",0,Clean Code
"export function useCodexTomlValidation() {
  const [configError, setConfigError] = useState(``);
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);
  const validateToml = useCallback((tomlText: string): boolean => {
    if (!tomlText.trim()) {
      setConfigError(``);
      return true;
    }
    try {
      TOML.parse(tomlText);
      setConfigError(``);
      return true;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : `TOML 格式错误`;
      setConfigError(errorMessage);
      return false;
    }
  }, []);
  const debouncedValidate = useCallback(
    (tomlText: string) => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }

      debounceTimerRef.current = setTimeout(() => {
        validateToml(tomlText);
      }, 500);
    },
    [validateToml],
  );
  const clearError = useCallback(() => {
    setConfigError(``);
  }, []);
  useEffect(() => {
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, []);
  return {
    configError,
    validateToml,
    debouncedValidate,
    clearError,
  };
}",0,Clean Code
"export function sync(regexPattern: string, options: Options): string[] {
  const entries: string[] = [];
  const baseDir = options.baseDir ?? path.resolve(__dirname);
  const filePattern = new RegExp(regexPattern);
  walkSync(baseDir, {
    entryFilter: entry => {
      const relativePath = path.relative(baseDir, entry.path);
      const normalizedPath = relativePath.replace(/\\/g, '/');
      const fileTest = filePattern.test(normalizedPath);
      const ignoreTest = Array.isArray(options.ignore)
        ? options.ignore.some(ignore => ignore.test(normalizedPath))
        : options.ignore.test(normalizedPath);

      return fileTest && !ignoreTest;
    },
    errorFilter: error => {
      console.error(error);
      return false;
    },
  }).forEach(entry => entries.push(entry.path));
  return entries;
}",0,Clean Code
"export const createSmoothPath = (points: Coords[]): string => {
  if (points.length < 2) return '';
  let path = `M ${points[0].x},${points[0].y}`;
  for (let i = 1; i < points.length; i++) {
    const current = points[i];
    const previous = points[i - 1];
    const cpX = (previous.x + current.x) / 2;
    const cpY = (previous.y + current.y) / 2;
    if (i === 1) {
      path += ` L ${cpX},${cpY}`;
    } else {
      path += ` Q ${previous.x},${previous.y} ${cpX},${cpY}`;
    }
  }
  const lastPoint = points[points.length - 1];
  const secondLastPoint = points[points.length - 2];
  path += ` Q ${secondLastPoint.x},${secondLastPoint.y} ${lastPoint.x},${lastPoint.y}`;
  path += ' Z';
  return path;
};",0,Clean Code
"otherRefs.forEach((item) => {
  if (item.type === 'RECTANGLE') {
    if (itemRefs.length > 0) return;
    const rectangle = getItemByIdOrThrow(scene.rectangles, item.id).value;
    const newFrom = CoordsUtils.add(rectangle.from, delta);
    const newTo = CoordsUtils.add(rectangle.to, delta);
    scene.updateRectangle(item.id, { from: newFrom, to: newTo });
  } else if (item.type === 'TEXTBOX') {
    const textBox = getItemByIdOrThrow(scene.textBoxes, item.id).value;
    scene.updateTextBox(item.id, {
      tile: CoordsUtils.add(textBox.tile, delta)
    });
  } else if (item.type === 'CONNECTOR_ANCHOR') {
    const connector = getAnchorParent(item.id, scene.connectors);
    const newConnector = produce(connector, (draft) => {
      const anchor = getItemByIdOrThrow(connector.anchors, item.id);
      const itemAtTile = getItemAtTile({ tile, scene });
      switch (itemAtTile?.type) {
        case 'ITEM':
          draft.anchors[anchor.index] = {
            ...anchor.value,
            ref: {
              item: itemAtTile.id
            }
          };
          break;
        case 'CONNECTOR_ANCHOR':
          draft.anchors[anchor.index] = {
            ...anchor.value,
            ref: {
              anchor: itemAtTile.id
            }
          };
          break;
        default:
          draft.anchors[anchor.index] = {
            ...anchor.value,
            ref: {
              tile
            }
          };
          break;
      }
    });
    scene.updateConnector(connector.id, newConnector);
  }
});",0,Clean Code
"export const useDiagramUtils = () => {
  const scene = useScene();
  const rendererEl = useUiStateStore((state) => {
    return state.rendererEl;
  });
  const { size: rendererSize } = useResizeObserver(rendererEl);
  const uiStateActions = useUiStateStore((state) => {
    return state.actions;
  });
  const getUnprojectedBounds = useCallback((): Size & Coords => {
    return getUnprojectedBoundsUtil(scene.currentView);
  }, [scene.currentView]);
  const getVisualBounds = useCallback((): Size & Coords => {
    return getVisualBoundsUtil(scene.currentView);
  }, [scene.currentView]);
  const getFitToViewParams = useCallback(
    (viewportSize: Size) => {
      return getFitToViewParamsUtil(scene.currentView, viewportSize);
    },
    [scene.currentView]
  );
  const fitToView = useCallback(async () => {
    const { zoom, scroll } = getFitToViewParams(rendererSize);
    uiStateActions.setScroll({
      position: scroll,
      offset: CoordsUtils.zero()
    });
    uiStateActions.setZoom(zoom);
  }, [uiStateActions, getFitToViewParams, rendererSize]);
  return {
    getUnprojectedBounds,
    getVisualBounds,
    fitToView,
    getFitToViewParams
  };
};",0,Clean Code
"export function useCheckProblems(appId: number | null) {
  const { settings } = useSettings();
  const {
    data: problemReport,
    isLoading: isChecking,
    error,
    refetch: checkProblems,
  } = useQuery<ProblemReport, Error>({
    queryKey: [`problems`, appId],
    queryFn: async (): Promise<ProblemReport> => {
      if (!appId) {
        throw new Error(`App ID is required`);
      }
      const ipcClient = IpcClient.getInstance();
      return ipcClient.checkProblems({ appId });
    },
    enabled: !!appId && settings?.enableAutoFixProblems,
  });

  return {
    problemReport,
    isChecking,
    error,
    checkProblems,
  };
}",0,Clean Code
"export function useLoadAppFile(appId: number | null, filePath: string | null) {
  const [content, setContent] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  useEffect(() => {
    const loadFile = async () => {
      if (appId === null || filePath === null) {
        setContent(null);
        setError(null);
        return;
      }
      setLoading(true);
      try {
        const ipcClient = IpcClient.getInstance();
        const fileContent = await ipcClient.readAppFile(appId, filePath);
        setContent(fileContent);
        setError(null);
      } catch (error) {
        console.error(
          `Error loading file ${filePath} for app ${appId}:`,
          error,
        );
        setError(error instanceof Error ? error : new Error(String(error)));
        setContent(null);
      } finally {
        setLoading(false);
      }
    };
    loadFile();
  }, [appId, filePath]);
  const refreshFile = async () => {
    if (appId === null || filePath === null) {
      return;
    }
    setLoading(true);
    try {
      const ipcClient = IpcClient.getInstance();
      const fileContent = await ipcClient.readAppFile(appId, filePath);
      setContent(fileContent);
      setError(null);
    } catch (error) {
      console.error(
        `Error refreshing file ${filePath} for app ${appId}:`,
        error,
      );
      setError(error instanceof Error ? error : new Error(String(error)));
    } finally {
      setLoading(false);
    }
    return { content, loading, error, refreshFile };
  }
}",0,Clean Code
"export const useIconFiltering = () => {
  const [filter, setFilter] = useState<string>('');
  const icons = useModelStore((state) => {
    return state.icons;
  });
  const filteredIcons = useMemo(() => {
    if (filter === '') return null;
    const escapedFilter = filter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(escapedFilter, 'gi');
    return icons.filter((icon: Icon) => {
      if (!filter) {
        return true;
      }
      return regex.test(icon.name);
    });
  }, [icons, filter]);
  return {
    setFilter,
    filter,
    filteredIcons
  };
};",0,Clean Code
"const loadInitialData = useCallback(async () => {
    setLoading(true);
    try {
      const ipcClient = IpcClient.getInstance();
      // Fetch settings and env vars concurrently
      const [userSettings, fetchedEnvVars] = await Promise.all([
        ipcClient.getUserSettings(),
        ipcClient.getEnvVars(),
      ]);
      processSettingsForTelemetry(userSettings);
      if (!isInitialLoad && appVersion) {
        posthog.capture(`app:initial-load`, {
          isPro: Boolean(userSettings.providerSettings?.auto?.apiKey?.value),
          appVersion,
        });
        isInitialLoad = true;
      }
      setSettingsAtom(userSettings);
      setEnvVarsAtom(fetchedEnvVars);
      setError(null);
    } catch (error) {
      console.error(`Error loading initial data:`, error);
      setError(error instanceof Error ? error : new Error(String(error)));
    } finally {
      setLoading(false);
    }
  }, [setSettingsAtom, setEnvVarsAtom, appVersion]);",0,Clean Code
"export async function neonTemplateHook({
  appId,
  appName,
}: {
  appId: number;
  appName: string;
}) {
  console.log(`Creating Neon project`);
  const neonProject = await IpcClient.getInstance().createNeonProject({
    name: appName,
    appId: appId,
  });
  console.log(`Neon project created`, neonProject);
  await IpcClient.getInstance().setAppEnvVars({
    appId: appId,
    envVars: [
      {
        key: `POSTGRES_URL`,
        value: neonProject.connectionString,
      },
      {
        key: `PAYLOAD_SECRET`,
        value: uuidv4(),
      },
      {
        key: `NEXT_PUBLIC_SERVER_URL`,
        value: `http://localhost:32100`,
      },
      {
        key: `GMAIL_USER`,
        value: `example@gmail.com`,
      },
      {
        key: `GOOGLE_APP_PASSWORD`,
        value: `GENERATE AT https://myaccount.google.com/apppasswords`,
      },
    ],
  });
  console.log(`App env vars set`);
}",0,Clean Code
"const getItemsInFreehandBounds = (
  pathTiles: Coords[],
  scene: any
): ItemReference[] => {
  const items: ItemReference[] = [];
  if (pathTiles.length < 3) return items;
  scene.items.forEach((item: any) => {
    if (isPointInPolygon(item.tile, pathTiles)) {
      items.push({ type: 'ITEM', id: item.id });
    }
  });
  scene.rectangles.forEach((rectangle: any) => {
    const corners = [
      rectangle.from,
      { x: rectangle.to.x, y: rectangle.from.y },
      rectangle.to,
      { x: rectangle.from.x, y: rectangle.to.y }
    ];
    const allCornersInside = corners.every(corner => isPointInPolygon(corner, pathTiles));
    if (allCornersInside) {
      items.push({ type: 'RECTANGLE', id: rectangle.id });
    }
  });
  scene.textBoxes.forEach((textBox: any) => {
    if (isPointInPolygon(textBox.tile, pathTiles)) {
      items.push({ type: 'TEXTBOX', id: textBox.id });
    }
  });
  return items;
};",0,Clean Code
"const getAuthFromAuthHeader = (headers: Record<string, string>) =>
  pipe(
    headers.Authorization,
    O.fromNullable,
    O.map((a) => a.split(` `)),
    O.filter((a) => a.length > 1),
    O.chain((kv) =>
      O.fromNullable(
        (() => {
          switch (kv[0].toLowerCase()) {
            case `bearer`:
              return <HoppRESTAuth>{
                authActive: true,
                authType: `bearer`,
                token: kv[1],
              }
            case `basic`: {
              const [username, password] = pipe(
                O.tryCatch(() => atob(kv[1])),
                O.map(S.split(`:`)),
                O.filter((arr) => arr.length > 0),
                O.map(
                  ([username, password]) =>
                    <[string, string]>[username, password]
                ),
                O.getOrElse(() => [``, ``])
              )
              if (!username) return undefined
              return <HoppRESTAuth>{
                authActive: true,
                authType: `basic`,
                username,
                password: password ?? ``,
              }
            }
            default:
              return undefined
          }
        })()
      )
    )
  )",0,Clean Code
"export const view = ({ action, payload, ctx }: ViewReducerParams) => {
  let newState: State;
  switch (action) {
    case 'SYNC_SCENE':
      newState = syncScene(ctx);
      break;
    case 'CREATE_VIEW':
      newState = createView(payload, ctx);
      break;
    case 'UPDATE_VIEW':
      newState = updateView(payload, ctx);
      break;
    case 'DELETE_VIEW':
      newState = deleteView(ctx);
      break;
    case 'CREATE_VIEWITEM':
      newState = viewItemReducers.createViewItem(payload, ctx);
      break;
    case 'UPDATE_VIEWITEM':
      newState = viewItemReducers.updateViewItem(payload, ctx);
      break;
    case 'DELETE_VIEWITEM':
      newState = viewItemReducers.deleteViewItem(payload, ctx);
      break;
    case 'CREATE_CONNECTOR':
      newState = connectorReducers.createConnector(payload, ctx);
      break;
    case 'UPDATE_CONNECTOR':
      newState = connectorReducers.updateConnector(payload, ctx);
      break;
    case 'SYNC_CONNECTOR':
      newState = connectorReducers.syncConnector(payload, ctx);
      break;
    case 'DELETE_CONNECTOR':
      newState = connectorReducers.deleteConnector(payload, ctx);
      break;
    case 'CREATE_TEXTBOX':
      newState = textBoxReducers.createTextBox(payload, ctx);
      break;
    case 'UPDATE_TEXTBOX':
      newState = textBoxReducers.updateTextBox(payload, ctx);
      break;
    case 'DELETE_TEXTBOX':
      newState = textBoxReducers.deleteTextBox(payload, ctx);
      break;
    case 'CREATE_RECTANGLE':
      newState = rectangleReducers.createRectangle(payload, ctx);
      break;
    case 'UPDATE_RECTANGLE':
      newState = rectangleReducers.updateRectangle(payload, ctx);
      break;
    case 'DELETE_RECTANGLE':
      newState = rectangleReducers.deleteRectangle(payload, ctx);
      break;
    default:
      throw new Error('Invalid action.');
  }
  switch (action) {
    case 'SYNC_SCENE':
    case 'DELETE_VIEW':
      return newState;
    default:
      return updateViewTimestamp({
        state: newState,
        viewId: ctx.viewId
      });
  }
};",0,Clean Code
"export function useRenameBranch() {
  const queryClient = useQueryClient();
  const currentAppId = useAtomValue(selectedAppIdAtom);
  const mutation = useMutation<void, Error, RenameBranchParams>({
    mutationFn: async (params: RenameBranchParams) => {
      if (params.appId === null || params.appId === undefined) {
        throw new Error(`App ID is required to rename a branch.`);
      }
      if (!params.oldBranchName) {
        throw new Error(`Old branch name is required.`);
      }
      if (!params.newBranchName) {
        throw new Error(`New branch name is required.`);
      }
      await IpcClient.getInstance().renameBranch(params);
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: [`currentBranch`, variables.appId],
      });
      queryClient.invalidateQueries({
        queryKey: [`versions`, variables.appId],
      });
    },
    meta: {
      showErrorToast: true,
    },
  });
  const renameBranch = async (params: Omit<RenameBranchParams, `appId`>) => {
    if (!currentAppId) {
      showError(`No application selected.`);
      return;
    }
    return mutation.mutateAsync({ ...params, appId: currentAppId });
  };
  return {
    renameBranch,
    isRenamingBranch: mutation.isPending,
    renameBranchError: mutation.error,
  };
}",0,Clean Code
"async function storeKubeconfigFromBackstage(kubeconfig: string) {
  try {
    const decodedKubeconfig = atob(kubeconfig);
    const parsedKubeconfig = jsyaml.load(decodedKubeconfig) as KubeconfigObject;
    const promises = parsedKubeconfig.contexts.map(
      async (context: { name: string; context: { cluster: string; user: string } }) => {
        const cluster = parsedKubeconfig.clusters.find(
          (c: { name: string }) => c.name === context.context.cluster
        );
        const authInfo = parsedKubeconfig.users.find(
          (u: { name: string }) => u.name === context.context.user
        );
        if (!cluster || !authInfo) {
          console.warn(`Missing cluster or auth info for context ${context.name}`);
          return;
        }
        const newKubeconfig: KubeconfigObject = {
          apiVersion: parsedKubeconfig.apiVersion,
          kind: parsedKubeconfig.kind,
          preferences: parsedKubeconfig.preferences,
          'current-context': context.name,
          contexts: [context],
          clusters: [cluster],
          users: [authInfo],
        };
        const newKubeconfigYaml = jsyaml.dump(newKubeconfig, { lineWidth: -1 });
        const newKubeconfigBase64 = btoa(newKubeconfigYaml);
        await statelessFunctions.findAndReplaceKubeconfig(context.name, newKubeconfigBase64, true);
      }
    );
    console.log('Promises', promises);
    await Promise.all(promises);
  } catch (error) {
    console.error('Error storing kubeconfig from backstage:', error);
  }
}",0,Clean Code
"export function useCheckoutVersion() {
  const queryClient = useQueryClient();
  const setActiveCheckouts = useSetAtom(activeCheckoutCounterAtom);
  const { isPending: isCheckingOutVersion, mutateAsync: checkoutVersion } =
    useMutation<void, Error, CheckoutVersionVariables>({
      mutationFn: async ({ appId, versionId }) => {
        if (appId === null) {
          throw new Error(`App ID is null, cannot checkout version.`);
        }
        const ipcClient = IpcClient.getInstance();
        setActiveCheckouts((prev) => prev + 1);
        try {
          await ipcClient.checkoutVersion({ appId, versionId });
        } finally {
          setActiveCheckouts((prev) => prev - 1);
        }
      },
      onSuccess: (_, variables) => {
        queryClient.invalidateQueries({
          queryKey: [`currentBranch`, variables.appId],
        });
        queryClient.invalidateQueries({
          queryKey: [`versions`, variables.appId],
        });
      },
      meta: { showErrorToast: true },
    });

  return {
    checkoutVersion,
    isCheckingOutVersion,
  };
}",0,Clean Code
"export function useLocalLMSModels() {
  const [models, setModels] = useAtom(lmStudioModelsAtom);
  const [loading, setLoading] = useAtom(lmStudioModelsLoadingAtom);
  const [error, setError] = useAtom(lmStudioModelsErrorAtom);
  const ipcClient = IpcClient.getInstance();
  const loadModels = useCallback(async () => {
    setLoading(true);
    try {
      const modelList = await ipcClient.listLocalLMStudioModels();
      setModels(modelList);
      setError(null);

      return modelList;
    } catch (error) {
      console.error(`Error loading local LMStudio models:`, error);
      setError(error instanceof Error ? error : new Error(String(error)));
      return [];
    } finally {
      setLoading(false);
    }
  }, [ipcClient, setModels, setError, setLoading]);

  return {
    models,
    loading,
    error,
    loadModels,
  };
}",0,Clean Code
"export async function startProxy(
  targetOrigin: string,
  opts: {
    onStarted?: (proxyUrl: string) => void;
  } = {},
) {
  if (!/^https?:\/\//.test(targetOrigin))
    throw new Error(`startProxy: targetOrigin must be absolute http/https URL`);
  const port = await findAvailablePort(50_000, 60_000);
  logger.info(`Found available port`, port);
  const {
    onStarted,
  } = opts;
  const worker = new Worker(
    path.resolve(__dirname, `..`, `..`, `worker`, `proxy_server.js`),
    {
      workerData: {
        targetOrigin,
        port,
      },
    },
  );
  worker.on(`message`, (m) => {
    logger.info(`[proxy]`, m);
    if (typeof m === `string` && m.startsWith(`proxy-server-start url=`)) {
      const url = m.substring(`proxy-server-start url=`.length);
      onStarted?.(url);
    }
  });
  worker.on(`error`, (e) => logger.error(`[proxy] error:`, e));
  worker.on(`exit`, (c) => logger.info(`[proxy] exit`, c));
  return worker;
}",0,Clean Code
"export function useLoadApps() {
  const [apps, setApps] = useAtom(appsListAtom);
  const [, setAppBasePath] = useAtom(appBasePathAtom);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const refreshApps = useCallback(async () => {
    setLoading(true);
    try {
      const ipcClient = IpcClient.getInstance();
      const appListResponse = await ipcClient.listApps();
      setApps(appListResponse.apps);
      setAppBasePath(appListResponse.appBasePath);
      setError(null);
    } catch (error) {
      console.error(`Error refreshing apps:`, error);
      setError(error instanceof Error ? error : new Error(String(error)));
    } finally {
      setLoading(false);
    }
  }, [setApps, setError, setLoading]);

  useEffect(() => {
    refreshApps();
  }, [refreshApps]);
  return { apps, loading, error, refreshApps };
}",0,Clean Code
"async function addListenerWithLimitations(identifier: string): Promise<ProgressResp> {
  const waitCount = 10;
  let count = 0;
  return new Promise((resolve, reject) => {
    const handleResponse = (response: string) => {
      const parsedResponse = JSON.parse(response);
      if (parsedResponse.identifier === identifier) {
        clearTimeout(timeoutId);
        window.desktopApi.removeListener('plugin-manager', handleResponse);
        resolve(parsedResponse);
      } else if (++count >= waitCount) {
        clearTimeout(timeoutId);
        window.desktopApi.removeListener('plugin-manager', handleResponse);
        reject(new Error('Message limit exceeded without a matching response'));
      }
    };
    window.desktopApi.receive('plugin-manager', handleResponse);
    const timeoutId = setTimeout(() => {
      window.desktopApi.removeListener('plugin-manager', handleResponse);
      reject(new Error('Timeout exceeded without a matching response'));
    }, 10000);
  });
}",0,Clean Code
"export const useIsoProjection = ({
  from,
  to,
  originOverride,
  orientation
}: Props): {
  css: React.CSSProperties;
  position: Coords;
  gridSize: Size;
  pxSize: Size;
} => {
  const gridSize = useMemo(() => {
    return {
      width: Math.abs(from.x - to.x) + 1,
      height: Math.abs(from.y - to.y) + 1
    };
  }, [from, to]);
  const origin = useMemo(() => {
    if (originOverride) return originOverride;
    const boundingBox = getBoundingBox([from, to]);
    return boundingBox[3];
  }, [from, to, originOverride]);
  const position = useMemo(() => {
    const pos = getTilePosition({
      tile: origin,
      origin: orientation === 'Y' ? 'TOP' : 'LEFT'
    });
    return pos;
  }, [origin, orientation]);
  const pxSize = useMemo(() => {
    return {
      width: gridSize.width * UNPROJECTED_TILE_SIZE,
      height: gridSize.height * UNPROJECTED_TILE_SIZE
    };
  }, [gridSize]);
  return {
    css: {
      position: 'absolute',
      left: position.x,
      top: position.y,
      width: `${pxSize.width}px`,
      height: `${pxSize.height}px`,
      transform: getIsoProjectionCss(orientation),
      transformOrigin: 'top left'
    },
    position,
    gridSize,
    pxSize
  };
};",0,Clean Code
"async function createNamespace(name) {
  const yaml = `
    apiVersion: v1
    kind: Namespace
    metadata:
      name: ${name}
    `;
  const page = this.page;
  await page.waitForSelector('span:has-text(`Namespaces`)');
  await page.click('span:has-text(`Namespaces`)');
  await page.waitForLoadState('load');
  const pageContent = await this.page.content();
  if (pageContent.includes(name)) {
    throw new Error(`Test failed: Namespace '${ name }' already exists.`);
  }
  await page.getByText('Create', { exact: true }).click();
  await page.waitForLoadState('load');
  const checkedSpan = await page.$('span.Mui-checked');
  if (!checkedSpan) {
    await expect(page.getByText('Use minimal editor')).toBeVisible();
    await page.getByText('Use minimal editor').click();
  }
  await page.waitForLoadState('load');
  await page.waitForSelector('textarea[aria-label=`yaml Code`]', { state: 'visible' });
  await expect(page.getByRole('textbox', { name: 'yaml Code' })).toBeVisible();
  await page.fill('textarea[aria-label=`yaml Code`]', yaml);
  await expect(page.getByRole('button', { name: 'Apply' })).toBeVisible();
  await page.getByRole('button', { name: 'Apply' }).click();
  await page.waitForSelector(`a:has-text('${ name }')`);
  await expect(page.locator(`a:has-text('${ name }')`)).toBeVisible();
}",0,Clean Code
"export function registerNodeHandlers() {
  ipcMain.handle(`nodejs-status`, async (): Promise<NodeSystemInfo> => {
    logger.log(
      `handling ipc: nodejs-status for platform:`,
      platform(),
      `and arch:`,
      arch(),
    );
    const [nodeVersion, pnpmVersion] = await Promise.all([
      runShellCommand(`node --version`),
      runShellCommand(
        `pnpm --version || (corepack enable pnpm && pnpm --version) || (npm install -g pnpm@latest-10 && pnpm --version)`,
      ),
    ]);
    let nodeDownloadUrl = `https://nodejs.org/dist/v22.14.0/node-v22.14.0.pkg`;
    if (platform() == `win32`) {
      if (arch() === `arm64` || arch() === `arm`) {
        nodeDownloadUrl =
          `https://nodejs.org/dist/v22.14.0/node-v22.14.0-arm64.msi`;
      } else {
        nodeDownloadUrl =
          `https://nodejs.org/dist/v22.14.0/node-v22.14.0-x64.msi`;
      }
    }
    return { nodeVersion, pnpmVersion, nodeDownloadUrl };
  });

  ipcMain.handle(`reload-env-path`, async (): Promise<void> => {
    logger.debug(`Reloading env path, previously:`, process.env.PATH);
    if (platform() === `win32`) {
      const newPath = execSync(`cmd /c echo %PATH%`, {
        encoding: `utf8`,
      }).trim();
      process.env.PATH = newPath;
    } else {
      fixPath();
    }
    logger.debug(`Reloaded env path, now:`, process.env.PATH);
  });
}",0,Clean Code
"async function getModels() {
  if (proxyUrl) {
    try {
      const response = await fetch(`${proxyUrl}/model/info`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });
      if (!response.ok) {
        throw new HttpException(
          `Failed to fetch models from proxy: ${response.statusText}`,
          HttpStatus.BAD_GATEWAY,
        );
      }
      const proxyModels = await response.json();
      const models: BytebotAgentModel[] = proxyModels.data.map(
        (model: any) => ({
          provider: 'proxy',
          name: model.litellm_params.model,
          title: model.model_name,
          contextWindow: 128000,
        }),
      );
      return models;
    } catch (error) {
      if (error instanceof HttpException) {
        throw error;
      }
      throw new HttpException(
        `Error fetching models: ${error.message}`,
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
  return models;
}",0,Clean Code
"useEffect(() => {
  loadModels();
  loadCurrentModel();
  checkFirstRun();
  const progressUnlisten = listen<DownloadProgress>(
    `model-download-progress`,
    (event) => {
      setDownloadProgress(
        (prev) => new Map(prev.set(event.payload.model_id, event.payload)),
      );
    },
  );
  const completeUnlisten = listen<string>(
    `model-download-complete`,
    (event) => {
      const modelId = event.payload;
      setDownloadingModels((prev) => {
        const next = new Set(prev);
        next.delete(modelId);
        return next;
      });
      setDownloadProgress((prev) => {
        const next = new Map(prev);
        next.delete(modelId);
        return next;
      });
      loadModels();
    },
  );
  const extractionStartedUnlisten = listen<string>(
    `model-extraction-started`,
    (event) => {
      const modelId = event.payload;
      setExtractingModels((prev) => new Set(prev.add(modelId)));
    },
  );
  const extractionCompletedUnlisten = listen<string>(
    `model-extraction-completed`,
    (event) => {
      const modelId = event.payload;
      setExtractingModels((prev) => {
        const next = new Set(prev);
        next.delete(modelId);
        return next;
      });
      loadModels();
    },
  );
  const extractionFailedUnlisten = listen<{
    model_id: string;
    error: string;
  }>(`model-extraction-failed`, (event) => {
    const modelId = event.payload.model_id;
    setExtractingModels((prev) => {
      const next = new Set(prev);
      next.delete(modelId);
      return next;
    });
    setError(`Failed to extract model: ${event.payload.error}`);
  });
  return () => {
    progressUnlisten.then((fn) => fn());
    completeUnlisten.then((fn) => fn());
    extractionStartedUnlisten.then((fn) => fn());
    extractionCompletedUnlisten.then((fn) => fn());
    extractionFailedUnlisten.then((fn) => fn());
  };
}, []);",0,Clean Code
"function mapUpdateHandle(raw: Update): UpdateHandle {
  return {
    version: (raw as any).version ?? ``,
    notes: (raw as any).notes,
    date: (raw as any).date,
    async downloadAndInstall(onProgress?: (e: UpdateProgressEvent) => void) {
      await (raw as any).downloadAndInstall((evt: any) => {
        if (!onProgress) return;
        const mapped: UpdateProgressEvent = {
          event: evt?.event,
        };
        if (evt?.event === `Started`) {
          mapped.total = evt?.data?.contentLength ?? 0;
          mapped.downloaded = 0;
        } else if (evt?.event === `Progress`) {
          mapped.downloaded = evt?.data?.chunkLength ?? 0;
        }
        onProgress(mapped);
      });
    },
    download: (raw as any).download
      ? async () => {
          await (raw as any).download();
        }
      : undefined,
    install: (raw as any).install
      ? async () => {
          await (raw as any).install();
        }
      : undefined,
  };
}",0,Clean Code
"ctx.onmessage = (event: MessageEvent<TrafficWorkerRequestMessage>) => {
  const message = event.data;
  switch (message.type) {
    case `init`: {
      config = { ...message.config };
      sampler = new TrafficDataSampler(config);
      currentRangeMinutes = message.config.defaultRangeMinutes;
      broadcastSnapshot(`init`);
      break;
    }
    case `append`: {
      const timestamp = message.payload.timestamp ?? Date.now();
      const dataPoint: ITrafficDataPoint = {
        up: message.payload.up || 0,
        down: message.payload.down || 0,
        timestamp,
        name: formatTrafficName(timestamp),
      };

      lastTimestamp = timestamp;
      sampler.addDataPoint(dataPoint);
      scheduleSnapshot(`append-throttle`);
      break;
    }
    case `clear`: {
      sampler.clear();
      lastTimestamp = undefined;
      broadcastSnapshot(`clear`);
      break;
    }
    case `setRange`: {
      if (currentRangeMinutes !== message.minutes) {
        currentRangeMinutes = message.minutes;
        broadcastSnapshot(`range-change`);
      }
      break;
    }
    case `requestSnapshot`: {
      broadcastSnapshot(`request`);
      break;
    }
    default:
      break;
  }
};",0,Clean Code
"export function registerUploadHandlers() {
  handle(`upload-to-signed-url`, async (_, params: UploadToSignedUrlParams) => {
    const { url, contentType, data } = params;
    logger.debug(`IPC: upload-to-signed-url called`);
    if (!url || typeof url !== `string` || !url.startsWith(`https://`)) {
      throw new Error(`Invalid signed URL provided`);
    }
    if (!contentType || typeof contentType !== `string`) {
      throw new Error(`Invalid content type provided`);
    }
    const response = await fetch(url, {
      method: `PUT`,
      headers: {
        'Content-Type': contentType,
      },
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      throw new Error(
        `Upload failed with status ${response.status}: ${response.statusText}`,
      );
    }
    logger.debug(`Successfully uploaded data to signed URL`);
  });
  logger.debug(`Registered upload IPC handlers`);
}",0,Clean Code
"export function useLoadApp(appId: number | null) {
  const [, setApp] = useAtom(currentAppAtom);
  const {
    data: appData,
    isLoading: loading,
    error,
    refetch: refreshApp,
  } = useQuery<App | null, Error>({
    queryKey: [`app`, appId],
    queryFn: async () => {
      if (appId === null) {
        return null;
      }
      const ipcClient = IpcClient.getInstance();
      return ipcClient.getApp(appId);
    },
    enabled: appId !== null,
  });
  useEffect(() => {
    if (appId === null) {
      setApp(null);
    } else if (appData !== undefined) {
      setApp(appData);
    }
  }, [appId, appData, setApp]);
  return { app: appData, loading, error, refreshApp };
}",0,Clean Code
"export function useDeleteCustomModel({
  onSuccess,
  onError,
}: {
  onSuccess?: () => void;
  onError?: (error: Error) => void;
}) {
  const queryClient = useQueryClient();
  const mutation = useMutation<void, Error, DeleteCustomModelParams>({
    mutationFn: async (params: DeleteCustomModelParams) => {
      if (!params.providerId || !params.modelApiName) {
        throw new Error(
          `Provider ID and Model API Name are required for deletion.`,
        );
      }
      const ipcClient = IpcClient.getInstance();
      await ipcClient.deleteCustomModel(params);
    },
    onSuccess: (data, params: DeleteCustomModelParams) => {
      queryClient.invalidateQueries({
        queryKey: [`language-models`, params.providerId],
      });
      queryClient.invalidateQueries({ queryKey: [`languageModels`] });
      onSuccess?.();
    },
    onError: (error: Error) => {
      console.error(`Error deleting custom model:`, error);
      onError?.(error);
    },
    meta: {
      showErrorToast: true,
    },
  });
  return mutation;
}",0,Clean Code
"async (
  _,
  { name, appId }: CreateNeonProjectParams,
): Promise<NeonProject> => {
  const neonClient = await getNeonClient();
  logger.info(`Creating Neon project: ${name} for app ${appId}`);
  try {
    const orgId = await getNeonOrganizationId();
    const response = await retryOnLocked(
      () =>
        neonClient.createProject({
          project: {
            name: name,
            org_id: orgId,
          },
        }),
      `Create project ${name} for app ${appId}`,
    );
    if (!response.data.project) {
      throw new Error(
        `Failed to create project: No project data returned.`,
      );
    }
    const project = response.data.project;
    const developmentBranch = response.data.branch;
    const previewBranchResponse = await retryOnLocked(
      () =>
        neonClient.createProjectBranch(project.id, {
          endpoints: [{ type: EndpointType.ReadOnly }],
          branch: {
            name: `preview`,
            parent_id: developmentBranch.id,
          },
        }),
      `Create preview branch for project ${project.id}`,
    );
    if (
      !previewBranchResponse.data.branch ||
      !previewBranchResponse.data.connection_uris
    ) {
      throw new Error(
        `Failed to create preview branch: No branch data returned.`,
      );
    }
    const previewBranch = previewBranchResponse.data.branch;
    await db
      .update(apps)
      .set({
        neonProjectId: project.id,
        neonDevelopmentBranchId: developmentBranch.id,
        neonPreviewBranchId: previewBranch.id,
      })
      .where(eq(apps.id, appId));
    logger.info(
      `Successfully created Neon project: ${project.id} and development branch: ${developmentBranch.id} for app ${appId}`,
    );
    return {
      id: project.id,
      name: project.name,
      connectionString: response.data.connection_uris[0].connection_uri,
      branchId: developmentBranch.id,
    };
  } catch (error: any) {
    const errorMessage = getNeonErrorMessage(error);
    const message = `Failed to create Neon project for app ${appId}: ${errorMessage}`;
    logger.error(message);
    throw new Error(message);
  }
}",0,Clean Code
"async function listBackups(): Promise<BackupInfo[]> {
  try {
    const entries = await fs.readdir(this.backupBasePath, {
      withFileTypes: true,
    });
    const backups: BackupInfo[] = [];
    logger.debug(`Found ${entries.length} entries in backup directory`);
    for (const entry of entries) {
      if (entry.isDirectory()) {
        const metadataPath = path.join(
          this.backupBasePath,
          entry.name,
          `backup.json`,
        );
        try {
          const metadataContent = await fs.readFile(metadataPath, `utf8`);
          const metadata: BackupMetadata = JSON.parse(metadataContent);
          backups.push({
            name: entry.name,
            ...metadata,
          });
        } catch (error) {
          logger.warn(`Invalid backup found: ${entry.name}`, error);
        }
      }
    }
    logger.info(`Found ${backups.length} valid backups`);
    return backups.sort(
      (a, b) =>
        new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime(),
    );
  } catch (error) {
    logger.error(`Failed to list backups:`, error);
    return [];
  }
}",0,Clean Code
"export async function fetchTaskCounts(): Promise<Record<string, number>> {
  try {
    const allTasksResult = await fetchTasks();
    const statusGroups = {
      ALL: Object.values(TaskStatus),
      ACTIVE: [TaskStatus.PENDING, TaskStatus.RUNNING, TaskStatus.NEEDS_HELP, TaskStatus.NEEDS_REVIEW],
      COMPLETED: [TaskStatus.COMPLETED],
      CANCELLED_FAILED: [TaskStatus.CANCELLED, TaskStatus.FAILED],
    };
    const counts: Record<string, number> = {
      ALL: allTasksResult.total,
      ACTIVE: 0,
      COMPLETED: 0,
      CANCELLED_FAILED: 0,
    };
    const groupPromises = Object.entries(statusGroups).map(async ([groupKey, statuses]) => {
      if (groupKey === 'ALL') {
        return { groupKey, count: allTasksResult.total };
      }
      const result = await fetchTasks({ statuses, limit: 1 });
      return { groupKey, count: result.total };
    });
    const groupCounts = await Promise.all(groupPromises);
    groupCounts.forEach(({ groupKey, count }) => {
      counts[groupKey] = count;
    });
    return counts;
  } catch (error) {
    console.error(`Failed to fetch task counts:`, error);
    return {
      ALL: 0,
      ACTIVE: 0,
      COMPLETED: 0,
      CANCELLED_FAILED: 0,
    };
  }
}",0,Clean Code
"async (
  _event,
  { chatId, packages }: { chatId: number; packages: string[] },
): Promise<void> => {
  const foundMessages = await db.query.messages.findMany({
    where: eq(messages.chatId, chatId),
  });
  const chat = await db.query.chats.findFirst({
    where: eq(chats.id, chatId),
  });
  if (!chat) {
    throw new Error(`Chat ${chatId} not found`);
  }
  const app = await db.query.apps.findFirst({
    where: eq(apps.id, chat.appId),
  });
  if (!app) {
    throw new Error(`App for chat ${chatId} not found`);
  }
  const message = [...foundMessages]
    .reverse()
    .find((m) =>
      m.content.includes(
        `<dyad-add-dependency packages='${ packages.join(` `) }'>`,
      ),
    );
  if (!message) {
    throw new Error(
      `Message with packages ${packages.join(`, `)} not found`,
    );
  }
  executeAddDependency({
    packages,
    message,
    appPath: getDyadAppPath(app.path),
  });
}",0,Clean Code
"export const parseHotkey = (keyEvent: KeyboardEvent) => {
  const nativeEvent = keyEvent.nativeEvent;
  const key = nativeEvent.code;
  let temp = key.toUpperCase();
  if (temp.startsWith(`ARROW`)) {
    temp = temp.slice(5);
  } else if (temp.startsWith(`DIGIT`)) {
    temp = temp.slice(5);
  } else if (temp.startsWith(`KEY`)) {
    temp = temp.slice(3);
  } else if (temp.endsWith(`LEFT`)) {
    temp = temp.slice(0, -4);
  } else if (temp.endsWith(`RIGHT`)) {
    temp = temp.slice(0, -5);
  }
  debugLog(temp, mapKeyCombination(temp));
  switch (temp) {
    case `CONTROL`:
      return `CTRL`;
    case `META`:
      return `CMD`;
    case ` `:
      return `SPACE`;
    default:
      return KEY_MAP[temp] || temp;
  }
};",0,Clean Code
"export function getAppUrl(): string {
  let url = '';
  let backendPort = 4466;
  let useLocalhost = false;
  if (isElectron()) {
    if (window?.headlampBackendPort) {
      backendPort = window.headlampBackendPort;
    }
    useLocalhost = true;
  }
  if (isDevMode()) {
    useLocalhost = true;
  }
  if (isDockerDesktop()) {
    backendPort = 64446;
    useLocalhost = true;
  }
  if (useLocalhost) {
    url = `http://localhost:${backendPort}`;
  } else {
    url = window.location.origin;
  }
  const baseUrl = getBaseUrl();
  url += baseUrl ? baseUrl + '/' : '/';
  return url;
}",0,Clean Code
"export const preloadLanguage = async (
  vergeConfig?: IVergeConfig | null,
  loadConfig: () => Promise<IVergeConfig | null> = preloadConfig,
) => {
  const cachedLanguage = getCachedLanguage();
  if (cachedLanguage) {
    return cachedLanguage;
  }
  let resolvedConfig = vergeConfig;
  if (resolvedConfig === undefined) {
    try {
      resolvedConfig = await loadConfig();
    } catch (error) {
      console.warn(
        `[preload.ts] Failed to read language from Verge config:`,
        error,
      );
      resolvedConfig = null;
    }
  }
  const languageFromConfig = resolvedConfig?.language;
  if (languageFromConfig) {
    const resolved = resolveLanguage(languageFromConfig);
    cacheLanguage(resolved);
    return resolved;
  }
  const browserLanguage = resolveLanguage(
    typeof navigator !== `undefined` ? navigator.language : undefined,
  );
  cacheLanguage(browserLanguage);
  return browserLanguage;
};",0,Clean Code
"async function initialize(): Promise<void> {
  logger.info(`Initializing backup system...`);
  this.userDataPath = app.getPath(`userData`);
  this.backupBasePath = path.join(this.userDataPath, `backups`);
  logger.info(
    `Backup system paths - UserData: ${this.userDataPath}, Backups: ${this.backupBasePath}`,
  );
  const currentVersion = app.getVersion();
  const lastVersion = await this.getLastRunVersion();
  if (lastVersion === null) {
    logger.info(`No previous version found, skipping backup`);
    return;
  }
  if (lastVersion === currentVersion) {
    logger.info(
      `No version upgrade detected. Current version: ${currentVersion}`,
    );
    return;
  }
  await fs.mkdir(this.backupBasePath, { recursive: true });
  logger.debug(`Backup directory created/verified`);
  logger.info(`Version upgrade detected: ${lastVersion} → ${currentVersion}`);
  await this.createBackup(`upgrade_from_${lastVersion}`);
  await this.saveCurrentVersion(currentVersion);
  await this.cleanupOldBackups();
  logger.info(`Backup system initialized successfully`);
}",0,Clean Code
"return new Promise<void>((resolve) => {
  const timeout = setTimeout(() => {
    console.warn(
      `Timeout waiting for process (PID: ${process.pid}) to close. Force killing may be needed.`,
    );
    resolve();
  }, 5000);
  process.on(`close`, (code, signal) => {
    clearTimeout(timeout);
    console.log(
      `Received 'close' event for process (PID: ${process.pid}) with code ${code}, signal ${signal}.`,
    );
    resolve();
  });
  process.on(`error`, (err) => {
    clearTimeout(timeout);
    console.error(
      `Error during stop sequence for process (PID: ${process.pid}): ${err.message}`,
    );
    resolve();
  });
  if (process.pid) {
    console.log(
      `Attempting to tree-kill process tree starting at PID ${process.pid}.`,
    );
    treeKill(process.pid, `SIGTERM`, (err: Error | undefined) => {
      if (err) {
        console.warn(
          `tree-kill error for PID ${process.pid}: ${err.message}`,
        );
      } else {
        console.log(
          `tree-kill signal sent successfully to PID ${process.pid}.`,
        );
      }
    });
  } else {
    console.warn(`Cannot tree-kill process: PID is undefined.`);
  }
});",0,Clean Code
"export function useCurrentBranch(appId: number | null) {
  const {
    data: branchInfo,
    isLoading,
    refetch: refetchBranchInfo,
  } = useQuery<BranchResult, Error>({
    queryKey: [`currentBranch`, appId],
    queryFn: async (): Promise<BranchResult> => {
      if (appId === null) {
        throw new Error(`appId is null, cannot fetch current branch.`);
      }
      const ipcClient = IpcClient.getInstance();
      return ipcClient.getCurrentBranch(appId);
    },
    enabled: appId !== null,
    meta: { showErrorToast: true },
  });

  return {
    branchInfo,
    isLoading,
    refetchBranchInfo,
  };
}",0,Clean Code
"export const updateViewItem = (
  { id, ...updates }: { id: string } & Partial<ViewItem>,
  { viewId, state }: ViewReducerContext
): State => {
  const newState = produce(state, (draft) => {
    const view = getItemByIdOrThrow(draft.model.views, viewId);
    const { items } = view.value;
    if (!items) return;
    const viewItem = getItemByIdOrThrow(items, id);
    const newItem = { ...viewItem.value, ...updates };
    items[viewItem.index] = newItem;
    if (updates.tile) {
      const connectorsToUpdate = getConnectorsByViewItem(
        viewItem.value.id,
        view.value.connectors ?? []
      );
      const updatedConnectors = connectorsToUpdate.reduce((acc, connector) => {
        return reducers.view({
          action: 'UPDATE_CONNECTOR',
          payload: connector,
          ctx: { viewId, state: acc }
        });
      }, draft);
      draft.model.views[view.index].connectors =
        updatedConnectors.model.views[view.index].connectors;

      draft.scene.connectors = updatedConnectors.scene.connectors;
    }
  });
  const newView = getItemByIdOrThrow(newState.model.views, viewId);
  const issues = validateView(newView.value, { model: newState.model });
  if (issues.length > 0) {
    throw new Error(issues[0].message);
  }
  return newState;
};",0,Clean Code
"export function useSettings() {
  const posthog = usePostHog();
  const [settings, setSettingsAtom] = useAtom(userSettingsAtom);
  const [envVars, setEnvVarsAtom] = useAtom(envVarsAtom);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const appVersion = useAppVersion();
  const loadInitialData = useCallback(async () => {
    setLoading(true);
    try {
      const ipcClient = IpcClient.getInstance();
      const [userSettings, fetchedEnvVars] = await Promise.all([
        ipcClient.getUserSettings(),
        ipcClient.getEnvVars(),
      ]);
      processSettingsForTelemetry(userSettings);
      if (!isInitialLoad && appVersion) {
        posthog.capture(`app:initial-load`, {
          isPro: Boolean(userSettings.providerSettings?.auto?.apiKey?.value),
          appVersion,
        });
        isInitialLoad = true;
      }
      setSettingsAtom(userSettings);
      setEnvVarsAtom(fetchedEnvVars);
      setError(null);
    } catch (error) {
      console.error(`Error loading initial data:`, error);
      setError(error instanceof Error ? error : new Error(String(error)));
    } finally {
      setLoading(false);
    }
  }, [setSettingsAtom, setEnvVarsAtom, appVersion]);
  useEffect(() => {
    loadInitialData();
  }, [loadInitialData]);
  const updateSettings = async (newSettings: Partial<UserSettings>) => {
    setLoading(true);
    try {
      const ipcClient = IpcClient.getInstance();
      const updatedSettings = await ipcClient.setUserSettings(newSettings);
      setSettingsAtom(updatedSettings);
      processSettingsForTelemetry(updatedSettings);
      setError(null);
      return updatedSettings;
    } catch (error) {
      console.error(`Error updating settings:`, error);
      setError(error instanceof Error ? error : new Error(String(error)));
      throw error;
    } finally {
      setLoading(false);
    }
  };
  return {
    settings,
    envVars,
    loading,
    error,
    updateSettings,
    refreshSettings: () => {
      return loadInitialData();
    },
  };
}",0,Clean Code
"const newConnector = produce(connector, (draft) => {
  const anchor = getItemByIdOrThrow(connector.anchors, item.id);
  const itemAtTile = getItemAtTile({ tile, scene });
  switch (itemAtTile?.type) {
    case 'ITEM':
      draft.anchors[anchor.index] = {
        ...anchor.value,
        ref: {
          item: itemAtTile.id
        }
      };
      break;
    case 'CONNECTOR_ANCHOR':
      draft.anchors[anchor.index] = {
        ...anchor.value,
        ref: {
          anchor: itemAtTile.id
        }
      };
      break;
    default:
      draft.anchors[anchor.index] = {
        ...anchor.value,
        ref: {
          tile
        }
      };
      break;
  }
});",0,Clean Code
"export const useView = () => {
  const uiStateActions = useUiStateStore((state) => {
    return state.actions;
  });
  const sceneActions = useSceneStore((state) => {
    return state.actions;
  });
  const changeView = useCallback(
    (viewId: string, model: Model) => {
      const newState = reducers.view({
        action: 'SYNC_SCENE',
        payload: undefined,
        ctx: { viewId, state: { model, scene: INITIAL_SCENE_STATE } }
      });
      sceneActions.set(newState.scene);
      uiStateActions.setView(viewId);
    },
    [uiStateActions, sceneActions]
  );
  return {
    changeView
  };
};",0,Clean Code
"export const useDeleteProviderMutation = (appId: AppId) => {
  const queryClient = useQueryClient();
  const { t } = useTranslation();
  return useMutation({
    mutationFn: async (providerId: string) => {
      await providersApi.delete(providerId, appId);
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: [`providers`, appId] });
      try {
        await providersApi.updateTrayMenu();
      } catch (trayError) {
        console.error(
          `Failed to update tray menu after deleting provider`,
          trayError,
        );
      }
      toast.success(
        t(`notifications.deleteSuccess`, {
          defaultValue: `供应商已删除`,
        }),
      );
    },
    onError: (error: Error) => {
      toast.error(
        t(`notifications.deleteFailed`, {
          defaultValue: `删除供应商失败: {{error}}`,
          error: error.message,
        }),
      );
    },
  });
};",0,Clean Code
"mousemove: ({ uiState, scene }) => {
  if (
    uiState.mode.type !== 'RECTANGLE.TRANSFORM' ||
    !hasMovedTile(uiState.mouse)
  )
    return;
  if (uiState.mode.selectedAnchor) {
    const rectangle = getItemByIdOrThrow(
      scene.rectangles,
      uiState.mode.id
    ).value;
    const rectangleBounds = getBoundingBox([rectangle.to, rectangle.from]);
    const namedBounds = convertBoundsToNamedAnchors(rectangleBounds);
    if (
      uiState.mode.selectedAnchor === 'BOTTOM_LEFT' ||
      uiState.mode.selectedAnchor === 'TOP_RIGHT'
    ) {
      const nextBounds = getBoundingBox([
        uiState.mode.selectedAnchor === 'BOTTOM_LEFT'
          ? namedBounds.TOP_RIGHT
          : namedBounds.BOTTOM_LEFT,
        uiState.mouse.position.tile
      ]);
      const nextNamedBounds = convertBoundsToNamedAnchors(nextBounds);
      scene.updateRectangle(uiState.mode.id, {
        from: nextNamedBounds.TOP_RIGHT,
        to: nextNamedBounds.BOTTOM_LEFT
      });
    } else if (
      uiState.mode.selectedAnchor === 'BOTTOM_RIGHT' ||
      uiState.mode.selectedAnchor === 'TOP_LEFT'
    ) {
      const nextBounds = getBoundingBox([
        uiState.mode.selectedAnchor === 'BOTTOM_RIGHT'
          ? namedBounds.TOP_LEFT
          : namedBounds.BOTTOM_RIGHT,
        uiState.mouse.position.tile
      ]);
      const nextNamedBounds = convertBoundsToNamedAnchors(nextBounds);
      scene.updateRectangle(uiState.mode.id, {
        from: nextNamedBounds.TOP_LEFT,
        to: nextNamedBounds.BOTTOM_RIGHT
      });
    }
  }
}",0,Clean Code
"function convertJsonSchemaToGoogleSchema(schema: any): any {
  if (!schema) return {};
  const result: any = {
    type: jsonSchemaTypeToGoogleType(schema.type),
  };
  if (schema.description) {
    result.description = schema.description;
  }
  if (schema.type === 'string' && schema.enum && Array.isArray(schema.enum)) {
    result.enum = schema.enum;
  }
  if (schema.nullable) {
    result.nullable = true;
  }
  if (schema.type === 'array' && schema.items) {
    result.items = convertJsonSchemaToGoogleSchema(schema.items);
  }
  if (schema.type === 'object' && schema.properties) {
    result.properties = {};
    for (const [key, value] of Object.entries(schema.properties)) {
      result.properties[key] = convertJsonSchemaToGoogleSchema(value);
    }
    if (schema.required) {
      result.required = schema.required;
    }
  }
  return result;
}",0,Clean Code
"export function registerDependencyHandlers() {
  handle(
    `chat:add-dep`,
    async (
      _event,
      { chatId, packages }: { chatId: number; packages: string[] },
    ): Promise<void> => {
      const foundMessages = await db.query.messages.findMany({
        where: eq(messages.chatId, chatId),
      });
      const chat = await db.query.chats.findFirst({
        where: eq(chats.id, chatId),
      });
      if (!chat) {
        throw new Error(`Chat ${chatId} not found`);
      }
      const app = await db.query.apps.findFirst({
        where: eq(apps.id, chat.appId),
      });
      if (!app) {
        throw new Error(`App for chat ${chatId} not found`);
      }
      const message = [...foundMessages]
        .reverse()
        .find((m) =>
          m.content.includes(
            `<dyad-add-dependency packages='${packages.join(` `)}'>`,
          ),
        );

      if (!message) {
        throw new Error(
          `Message with packages ${packages.join(`, `)} not found`,
        );
      }
      executeAddDependency({
        packages,
        message,
        appPath: getDyadAppPath(app.path),
      });
    },
  );
}",0,Clean Code
"async (event: DragEndEvent) => {
  const { active, over } = event;
  if (!over || active.id === over.id) {
    return;
  }
  const oldIndex = sortedProviders.findIndex(
    (provider) => provider.id === active.id,
  );
  const newIndex = sortedProviders.findIndex(
    (provider) => provider.id === over.id,
  );
  if (oldIndex === -1 || newIndex === -1) {
    return;
  }
  const reordered = arrayMove(sortedProviders, oldIndex, newIndex);
  const updates = reordered.map((provider, index) => ({
    id: provider.id,
    sortIndex: index,
  }));
  try {
    await providersApi.updateSortOrder(updates, appId);
    await queryClient.invalidateQueries({
      queryKey: [`providers`, appId],
    });
    try {
      await providersApi.updateTrayMenu();
    } catch (trayError) {
      console.error(`Failed to update tray menu after sort`, trayError);
    }
    toast.success(
      t(`provider.sortUpdated`, {
        defaultValue: `排序已更新`,
      }),
    );
  } catch (error) {
    console.error(`Failed to update provider sort order`, error);
    toast.error(
      t(`provider.sortUpdateFailed`, {
        defaultValue: `排序更新失败`,
      }),
    );
  }
}",0,Clean Code
"const migrationOutput = await new Promise<string>((resolve, reject) => {
  logger.info(`Running migrate:create for app ${appId} at ${appPath}`);

  const process = spawn(`npm run migrate:create -- --skip-empty`, {
    cwd: appPath,
    shell: true,
    stdio: `pipe`,
  });
  let stdout = ``;
  let stderr = ``;
  process.stdout?.on(`data`, (data) => {
    const output = data.toString();
    stdout += output;
    logger.info(`migrate:create stdout: ${output}`);
    if (output.includes(`created or renamed from another`)) {
      process.stdin.write(`\r\n`);
      logger.info(
        `App ${appId} (PID: ${process.pid}) wrote enter to stdin to automatically respond to drizzle migrate input`,
      );
    }
  });
  process.stderr?.on(`data`, (data) => {
    const output = data.toString();
    stderr += output;
    logger.warn(`migrate:create stderr: ${output}`);
  });
  process.on(`close`, (code) => {
    const combinedOutput =
      stdout + (stderr ? `\n\nErrors/Warnings:\n${stderr}` : ``);
    if (code === 0) {
      if (stdout.includes(`Migration created at`)) {
        logger.info(
          `migrate:create completed successfully for app ${appId}`,
        );
        resolve(combinedOutput);
      } else {
        logger.error(
          `migrate:create completed successfully for app ${appId} but no migration was created`,
        );
        reject(
          new Error(
            `No migration was created because no changes were found.`,
          ),
        );
      }
    } else {
      logger.error(
        `migrate:create failed for app ${appId} with exit code ${code}`,
      );
      const errorMessage = `Migration creation failed (exit code ${code})\n\n${combinedOutput}`;
      reject(new Error(errorMessage));
    }
  });
  process.on(`error`, (err) => {
    logger.error(`Failed to spawn migrate:create for app ${appId}:`, err);
    const errorMessage = `Failed to run migration command: ${err.message}\n\nOutput:\n${stdout}\n\nErrors:\n${stderr}`;
    reject(new Error(errorMessage));
  });
});",0,Clean Code
"useEffect(() => {
  const screenshots = extractScreenshots(messages);
  setAllScreenshots(screenshots);
  if (screenshots.length > 0 && !currentScreenshot) {
    setTimeout(() => {
      const initialScreenshot = getScreenshotForScrollPosition(
        screenshots,
        messages,
        scrollContainerRef.current
      );
      if (initialScreenshot) {
        setCurrentScreenshot(initialScreenshot);
      } else {
        setCurrentScreenshot(screenshots[screenshots.length - 1]);
      }
    }, 100);
  } else if (screenshots.length === 0) {
    setCurrentScreenshot(null);
  } else if (screenshots.length > 0 && currentScreenshot) {
    setTimeout(() => {
      if (scrollContainerRef.current) {
        const event = new Event('scroll');
        scrollContainerRef.current.dispatchEvent(event);
      }
    }, 300);
  }
}, [messages, scrollContainerRef]);",0,Clean Code
"async function handleCron() {
  const now = new Date();
  const scheduledTasks = await this.tasksService.findScheduledTasks();
  for (const scheduledTask of scheduledTasks) {
    if (scheduledTask.scheduledFor && scheduledTask.scheduledFor < now) {
      this.logger.debug(
        `Task ID: ${scheduledTask.id} is scheduled for ${scheduledTask.scheduledFor}, queuing it`,
      );
      await this.tasksService.update(scheduledTask.id, {
        queuedAt: now,
      });
    }
  }
  if (this.agentProcessor.isRunning()) {
    return;
  }
  const task = await this.tasksService.findNextTask();
  if (task) {
    if (task.files.length > 0) {
      this.logger.debug(
        `Task ID: ${task.id} has files, writing them to the desktop`,
      );
      for (const file of task.files) {
        await writeFile({
          path: `/home/user/Desktop/${file.name}`,
          content: file.data,
        });
      }
    }
    await this.tasksService.update(task.id, {
      status: TaskStatus.RUNNING,
      executedAt: new Date(),
    });
    this.logger.debug(`Processing task ID: ${task.id}`);
    this.agentProcessor.processTask(task.id);
  }
}",0,Clean Code
"return (
    channel: string,
    fn: (event: IpcMainInvokeEvent, ...args: any[]) => Promise<any>,
  ) => {
    ipcMain.handle(
      channel,
      async (event: IpcMainInvokeEvent, ...args: any[]) => {
        logger.log(`IPC: ${channel} called with args: ${JSON.stringify(args)}`);
        try {
          const result = await fn(event, ...args);
          logger.log(
            `IPC: ${channel} returned: ${JSON.stringify(result)?.slice(0, 100)}...`,
          );
          return result;
        } catch (error) {
          logger.error(
            `Error in ${fn.name}: args: ${JSON.stringify(args)}`,
            error,
          );
          throw new Error(`[${channel}] ${error}`);
        }
      },
    );
  };",0,Clean Code
"return new Promise<void>((resolve, reject) => {
  logger.info(`Running: ${command}`);
  const process = spawn(command, {
    cwd,
    shell: true,
    stdio: `pipe`,
    env,
  });
  let stdout = ``;
  let stderr = ``;
  process.stdout?.on(`data`, (data) => {
    const output = data.toString();
    stdout += output;
    logger.info(output);
  });
  process.stderr?.on(`data`, (data) => {
    const output = data.toString();
    stderr += output;
    logger.error(output);
  });
  process.on(`close`, (code) => {
    if (code === 0) {
      logger.info(successMessage);
      resolve();
    } else {
      logger.error(`${errorPrefix}, exit code ${code}`);
      const errorMessage = `${errorPrefix} (exit code ${code})\n\nSTDOUT:\n${stdout}\n\nSTDERR:\n${stderr}`;
      reject(new Error(errorMessage));
    }
  });
  process.on(`error`, (err) => {
    logger.error(`Failed to spawn command: ${command}`, err);
    const errorMessage = `Failed to spawn command: ${err.message}\n\nSTDOUT:\n${stdout}\n\nSTDERR:\n${stderr}`;
    reject(new Error(errorMessage));
  });
});",0,Clean Code
"async function proxy(req: NextRequest, path: string[]): Promise<Response> {
  const BASE_URL = process.env.BYTEBOT_AGENT_BASE_URL!;
  const subPath = path.length ? path.join(`/`) : ``;
  const url = `${BASE_URL}/${subPath}${req.nextUrl.search}`;
  const cookies = req.headers.get(`cookie`);
  const init: RequestInit = {
    method: req.method,
    headers: {
      'Content-Type': `application/json`,
      ...(cookies && { Cookie: cookies }),
    },
    body:
      req.method === `GET` || req.method === `HEAD`
        ? undefined
        : await req.text(),
  };
  const res = await fetch(url, init);
  const body = await res.text();
  const setCookieHeaders = res.headers.getSetCookie?.() || [];
  const responseHeaders = new Headers({
    'Content-Type': `application/json`,
  });
  setCookieHeaders.forEach((cookie) => {
    responseHeaders.append(`Set-Cookie`, cookie);
  });
  return new Response(body, {
    status: res.status,
    headers: responseHeaders,
  });
}",0,Clean Code
"export async function executeAddDependency({
  packages,
  message,
  appPath,
}: {
  packages: string[];
  message: Message;
  appPath: string;
}) {
  const packageStr = packages.join(` `);
  const { stdout, stderr } = await execPromise(
    `(pnpm add ${packageStr}) || (npm install --legacy-peer-deps ${packageStr})`,
    {
      cwd: appPath,
    },
  );
  const installResults = stdout + (stderr ? `\n${stderr}` : ``);
  const updatedContent = message.content.replace(
    new RegExp(
      `<dyad-add-dependency packages='${packages.join(
        ` `,
      )}'>[^<]*</dyad-add-dependency>`,
      `g`,
    ),
    `<dyad-add-dependency packages='${packages.join(
      ` `,
    )}'>${installResults}</dyad-add-dependency>`,
  );
  await db
    .update(messages)
    .set({ content: updatedContent })
    .where(eq(messages.id, message.id));
}",0,Clean Code
"export function makeGraphLookup<N extends GraphNode, E extends GraphEdge>(
  nodes: N[],
  edges: E[]
): GraphLookup<N, E> {
  const nodeMap = new Map<string, N>();
  nodes.forEach(n => {
    nodeMap.set(n.id, n);
  });
  const outgoingEdges = new Map<string, E[]>();
  const incomingEdges = new Map<string, E[]>();
  edges.forEach(edge => {
    const s = outgoingEdges.get(edge.source) ?? [];
    s.push(edge);
    outgoingEdges.set(edge.source, s);
    const t = incomingEdges.get(edge.target) ?? [];
    t.push(edge);
    incomingEdges.set(edge.target, t);
  });
  return {
    getOutgoingEdges(nodeId) {
      return outgoingEdges.get(nodeId);
    },
    getIncomingEdges(nodeId) {
      return incomingEdges.get(nodeId);
    },
    getNode(nodeId) {
      return nodeMap.get(nodeId);
    },
  };
}",0,Clean Code
"export const useGraphViewport = () => {
  const [zoomMode, setZoomMode] = useLocalStorageState<zoomMode>('map-zoom-mode', '100%');
  const reactFlowWidth = useStore(it => it.width);
  const reactFlowHeight = useStore(it => it.height);
  const aspectRatio = useStore(it => it.width / it.height);
  const flow = useReactFlow();
  const updateViewport = useCallback(
    ({
      nodes = flow.getNodes(),
      mode = zoomMode,
    }: {
      nodes?: Node[];
      mode?: zoomMode;
    }) => {
      if (mode !== zoomMode) {
        setZoomMode(() => mode);
      }
      const bounds = getNodesBounds(nodes);
      if (mode === 'fit') {
        const viewport = getViewportForBounds(
          {
            x: bounds.x - viewportPaddingPx,
            y: bounds.y - viewportPaddingPx,
            width: bounds.width + viewportPaddingPx * 2,
            height: bounds.height + viewportPaddingPx * 2,
          },
          reactFlowWidth,
          reactFlowHeight,
          minZoom,
          maxZoom,
          0
        );w
        flow.setViewport(viewport);
        return;
      }
      if (mode === '100%') {
        const topLeftOrigin = { x: viewportPaddingPx, y: viewportPaddingPx };
        const centerOrigin = {
          x: reactFlowWidth / 2 - bounds.width / 2,
          y: reactFlowHeight / 2 - bounds.height / 2,
        };
        const xFits = bounds.width + viewportPaddingPx * 2 <= reactFlowWidth;
        const yFits = bounds.height + viewportPaddingPx * 2 <= reactFlowHeight;
        const defaultZoomViewport = {
          x: xFits ? centerOrigin.x : topLeftOrigin.x,
          y: yFits ? centerOrigin.y : topLeftOrigin.y,
          zoom: 1,
        };
        flow.setViewport(defaultZoomViewport);
        return;
      }
      console.error('Unknown zoom mode', mode);
    },
    [flow, zoomMode, reactFlowWidth, reactFlowHeight]
  );
  return useMemo(() => ({ updateViewport, aspectRatio }), [updateViewport, aspectRatio]);
};",0,Clean Code
"useEffect(() => {
    if (!themeReady || overlayRemovedRef.current) return;
    let fadeTimer: number | null = null;
    let retryTimer: number | null = null;
    let attempts = 0;
    const maxAttempts = 50;
    let stopped = false;
    const tryRemoveOverlay = () => {
      if (stopped || overlayRemovedRef.current) return;
      const overlay = document.getElementById(`initial-loading-overlay`);
      if (overlay) {
        overlayRemovedRef.current = true;
        overlay.style.opacity = `0`;
        overlay.style.pointerEvents = `none`;

        fadeTimer = window.setTimeout(() => {
          try {
            overlay.remove();
          } catch (error) {
            console.warn(`[加载遮罩] 移除失败:`, error);
          }
        }, 300);
        return;
      }
      if (attempts < maxAttempts) {
        attempts += 1;
        retryTimer = window.setTimeout(tryRemoveOverlay, 100);
      } else {
        console.warn(`[加载遮罩] 未找到元素`);
      }
    };
    tryRemoveOverlay();
    return () => {
      stopped = true;
      if (fadeTimer) window.clearTimeout(fadeTimer);
      if (retryTimer) window.clearTimeout(retryTimer);
    };
  }, [themeReady]);",0,Clean Code
"export async function fetchApiTemplates(): Promise<Template[]> {
  if (apiTemplatesCache) {
    return apiTemplatesCache;
  }
  if (apiTemplatesFetchPromise) {
    return apiTemplatesFetchPromise;
  }
  apiTemplatesFetchPromise = (async (): Promise<Template[]> => {
    try {
      const response = await fetch(`https://api.dyad.sh/v1/templates`);
      if (!response.ok) {
        throw new Error(
          `Failed to fetch templates: ${response.status} ${response.statusText}`,
        );
      }
      const apiTemplates: ApiTemplate[] = await response.json();
      const convertedTemplates = apiTemplates.map(convertApiTemplate);
      apiTemplatesCache = convertedTemplates;
      return convertedTemplates;
    } catch (error) {
      logger.error(`Failed to fetch API templates:`, error);
      apiTemplatesFetchPromise = null;
      return [];
    }
  })();

  return apiTemplatesFetchPromise;
}",0,Clean Code
"export async function simpleSpawn({
  command,
  cwd,
  successMessage,
  errorPrefix,
  env,
}: {
  command: string;
  cwd: string;
  successMessage: string;
  errorPrefix: string;
  env?: Record<string, string>;
}): Promise<void> {
  return new Promise<void>((resolve, reject) => {
    logger.info(`Running: ${command}`);
    const process = spawn(command, {
      cwd,
      shell: true,
      stdio: `pipe`,
      env,
    });
    let stdout = ``;
    let stderr = ``;
    process.stdout?.on(`data`, (data) => {
      const output = data.toString();
      stdout += output;
      logger.info(output);
    });
    process.stderr?.on(`data`, (data) => {
      const output = data.toString();
      stderr += output;
      logger.error(output);
    });
    process.on(`close`, (code) => {
      if (code === 0) {
        logger.info(successMessage);
        resolve();
      } else {
        logger.error(`${errorPrefix}, exit code ${code}`);
        const errorMessage = `${errorPrefix} (exit code ${code})\n\nSTDOUT:\n${stdout}\n\nSTDERR:\n${stderr}`;
        reject(new Error(errorMessage));
      }
    });
    process.on(`error`, (err) => {
      logger.error(`Failed to spawn command: ${command}`, err);
      const errorMessage = `Failed to spawn command: ${err.message}\n\nSTDOUT:\n${stdout}\n\nSTDERR:\n${stderr}`;
      reject(new Error(errorMessage));
    });
  });
}",0,Clean Code
"export function runShellCommand(command: string): Promise<string | null> {
  logger.log(`Running command: ${command}`);
  return new Promise((resolve) => {
    let output = ``;
    const process = spawn(command, {
      shell: true,
      stdio: [`ignore`, `pipe`, `pipe`],
    });
    process.stdout?.on(`data`, (data) => {
      output += data.toString();
    });
    process.stderr?.on(`data`, (data) => {
      logger.warn(`Stderr from '${command}': ${data.toString().trim()}`);
    });
    process.on(`error`, (error) => {
      logger.error(`Error executing command '${command}':`, error.message);
      resolve(null);
    });
    process.on(`close`, (code) => {
      if (code === 0) {
        logger.debug(
          `Command '${command}' succeeded with code ${code}: ${output.trim()}`,
        );
        resolve(output.trim());
      } else {
        logger.error(`Command '${command}' failed with code ${code}`);
        resolve(null);
      }
    });
  });
}",0,Clean Code
"export const formatModelSize = (sizeMb: number | null | undefined): string => {
  if (!sizeMb || !Number.isFinite(sizeMb) || sizeMb <= 0) {
    return `Unknown size`;
  }
  if (sizeMb >= 1024) {
    const sizeGb = sizeMb / 1024;
    const formatter = new Intl.NumberFormat(undefined, {
      minimumFractionDigits: sizeGb >= 10 ? 0 : 1,
      maximumFractionDigits: sizeGb >= 10 ? 0 : 1,
    });
    return `${formatter.format(sizeGb)} GB`;
  }
  const formatter = new Intl.NumberFormat(undefined, {
    minimumFractionDigits: sizeMb >= 100 ? 0 : 1,
    maximumFractionDigits: sizeMb >= 100 ? 0 : 1,
  });
  return `${formatter.format(sizeMb)} MB`;
};",0,Clean Code
"export const useAddProviderMutation = (appId: AppId) => {
  const queryClient = useQueryClient();
  const { t } = useTranslation();
  return useMutation({
    mutationFn: async (providerInput: Omit<Provider, `id`>) => {
      const newProvider: Provider = {
        ...providerInput,
        id: crypto.randomUUID(),
        createdAt: Date.now(),
      };
      await providersApi.add(newProvider, appId);
      return newProvider;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: [`providers`, appId] });
      try {
        await providersApi.updateTrayMenu();
      } catch (trayError) {
        console.error(
          `Failed to update tray menu after adding provider`,
          trayError,
        );
      }

      toast.success(
        t(`notifications.providerAdded`, {
          defaultValue: `供应商已添加`,
        }),
      );
    },
    onError: (error: Error) => {
      toast.error(
        t(`notifications.addFailed`, {
          defaultValue: `添加供应商失败: {{error}}`,
          error: error.message,
        }),
      );
    },
  });
};",0,Clean Code
"export const deleteViewItem = (
  id: string,
  { state, viewId }: ViewReducerContext
): State => {
  const newState = produce(state, (draft) => {
    const view = getItemByIdOrThrow(draft.model.views, viewId);
    const viewItem = getItemByIdOrThrow(view.value.items, id);
    draft.model.views[view.index].items.splice(viewItem.index, 1);
    const connectorsToDelete = getConnectorsByViewItem(
      viewItem.value.id,
      view.value.connectors ?? []
    );
    if (connectorsToDelete.length > 0 && draft.model.views[view.index].connectors) {
      draft.model.views[view.index].connectors =
        draft.model.views[view.index].connectors?.filter(
          connector => !connectorsToDelete.some(c => c.id === connector.id)
        );
      connectorsToDelete.forEach(connector => {
        delete draft.scene.connectors[connector.id];
      });
    }
  });

  return newState;
};",0,Clean Code
"export const useI18n = () => {
  const { i18n, t } = useTranslation();
  const { patchVerge } = useVerge();
  const [isLoading, setIsLoading] = useState(false);
  const switchLanguage = useCallback(
    async (language: string) => {
      const targetLanguage = resolveLanguage(language);
      if (!supportedLanguages.includes(targetLanguage)) {
        console.warn(`Unsupported language: ${language}`);
        return;
      }
      if (i18n.language === targetLanguage) {
        return;
      }
      setIsLoading(true);
      try {
        await changeLanguage(targetLanguage);

        if (patchVerge) {
          await patchVerge({ language: targetLanguage });
        }
      } catch (error) {
        console.error(`Failed to change language:`, error);
      } finally {
        setIsLoading(false);
      }
    },
    [i18n.language, patchVerge],
  );
  return {
    currentLanguage: i18n.language,
    supportedLanguages,
    switchLanguage,
    isLoading,
    t,
  };
};",0,Clean Code
"export const useListen = () => {
  const unlistenFns = useRef<UnlistenFn[]>([]);
  const addListener = async <T>(
    eventName: string,
    handler: EventCallback<T>,
  ) => {
    const unlisten = await listen(eventName, handler);
    unlistenFns.current.push(unlisten);
    return unlisten;
  };
  const removeAllListeners = () => {
    const errors: Error[] = [];
    unlistenFns.current.forEach((unlisten) => {
      try {
        unlisten();
      } catch (error) {
        errors.push(error instanceof Error ? error : new Error(String(error)));
      }
    });
    if (errors.length > 0) {
      console.warn(
        `[useListen] 清理监听器时发生 ${errors.length} 个错误`,
        errors,
      );
    }
    unlistenFns.current.length = 0;
  };
  const setupCloseListener = async function () {
    await event.once(`tauri://close-requested`, async () => {
      removeAllListeners();
    });
  };

  return {
    addListener,
    removeAllListeners,
    setupCloseListener,
  };
};",0,Clean Code
"mousemove: ({ uiState, scene }) => {
  if (uiState.mode.type !== 'DRAG_ITEMS' || !uiState.mouse.mousedown) return;
  if (uiState.mode.isInitialMovement) {
    const delta = CoordsUtils.subtract(
      uiState.mouse.position.tile,
      uiState.mouse.mousedown.tile
    );
    dragItems(uiState.mode.items, uiState.mouse.position.tile, delta, scene);
    uiState.actions.setMode(
      produce(uiState.mode, (draft) => {
        draft.isInitialMovement = false;
      })
    );
    return;
  }
  if (!hasMovedTile(uiState.mouse) || !uiState.mouse.delta?.tile) return;
  const delta = uiState.mouse.delta.tile;
  dragItems(uiState.mode.items, uiState.mouse.position.tile, delta, scene);
}",0,Clean Code
"useEffect(() => {
    const unlisteners: Array<() => void> = [];
    let disposed = false;
    const register = (
      maybeUnlisten: void | (() => void) | Promise<void | (() => void)>,
    ) => {
      if (!maybeUnlisten) return;

      if (typeof maybeUnlisten === `function`) {
        unlisteners.push(maybeUnlisten);
        return;
      }
      maybeUnlisten
        .then((unlisten) => {
          if (!unlisten) return;
          if (disposed) {
            unlisten();
          } else {
            unlisteners.push(unlisten);
          }
        })
        .catch((error) => console.error(`[事件监听] 注册失败`, error));
    };
    register(
      addListener(`verge://refresh-clash-config`, async () => {
        mutate(`getProxies`);
        mutate(`getVersion`);
        mutate(`getClashConfig`);
        mutate(`getProxyProviders`);
      }),
    );
    register(
      addListener(`verge://refresh-verge-config`, () => {
        mutate(`getVergeConfig`);
        mutate(`getSystemProxy`);
        mutate(`getAutotemProxy`);
        mutate(`getRunningMode`);
        mutate(`isServiceAvailable`);
      }),
    );
    register(
      addListener(`verge://notice-message`, ({ payload }) =>
        handleNotice(payload as [string, string]),
      ),
    );
    const appWindow = getCurrentWebviewWindow();
    register(
      (async () => {
        const [hideUnlisten, showUnlisten] = await Promise.all([
          listen(`verge://hide-window`, () => appWindow.hide()),
          listen(`verge://show-window`, () => appWindow.show()),
        ]);
        return () => {
          hideUnlisten();
          showUnlisten();
        };
      })(),
    );
    return () => {
      disposed = true;
      const errors: Error[] = [];
      unlisteners.forEach((unlisten) => {
        try {
          unlisten();
        } catch (error) {
          errors.push(
            error instanceof Error ? error : new Error(String(error)),
          );
        }
      });
      if (errors.length > 0) {
        console.error(
          `[事件监听] 清理过程中发生 ${errors.length} 个错误:`,
          errors,
        );
      }
      unlisteners.length = 0;
    };
  }, [addListener, handleNotice]);",0,Clean Code
"export function useCountTokens() {
  const [result, setResult] = useAtom(tokenCountResultAtom);
  const [loading, setLoading] = useAtom(tokenCountLoadingAtom);
  const [error, setError] = useAtom(tokenCountErrorAtom);
  const countTokens = useCallback(
    async (chatId: number, input: string) => {
      setLoading(true);
      setError(null);
      try {
        const ipcClient = IpcClient.getInstance();
        const tokenResult = await ipcClient.countTokens({ chatId, input });
        setResult(tokenResult);
        return tokenResult;
      } catch (error) {
        console.error(`Error counting tokens:`, error);
        setError(error instanceof Error ? error : new Error(String(error)));
        throw error;
      } finally {
        setLoading(false);
      }
    },
    [setLoading, setError, setResult],
  );
  return {
    countTokens,
    result,
    loading,
    error,
  };
}",0,Clean Code
"export function registerProHandlers() {
  handle(`get-user-budget`, async (): Promise<UserBudgetInfo | null> => {
    if (IS_TEST_BUILD) {
      return null;
    }
    logger.info(`Attempting to fetch user budget information.`);
    const settings = readSettings();
    const apiKey = settings.providerSettings?.auto?.apiKey?.value;
    if (!apiKey) {
      logger.error(`LLM Gateway API key (Dyad Pro) is not configured.`);
      return null;
    }
    const url = `https://llm-gateway.dyad.sh/user/info`;
    const headers = {
      'Content-Type': `application/json`,
      Authorization: `Bearer ${apiKey}`,
    };
    try {
      const response = await fetch(url, {
        method: `GET`,
        headers: headers,
      });
      if (!response.ok) {
        const errorBody = await response.text();
        logger.error(
          `Failed to fetch user budget. Status: ${response.status}. Body: ${errorBody}`,
        );
        return null;
      }
      const data = await response.json();
      const userInfoData = data[`user_info`];
      logger.info(`Successfully fetched user budget information.`);
      return UserBudgetInfoSchema.parse({
        usedCredits: userInfoData[`spend`] * CONVERSION_RATIO,
        totalCredits: userInfoData[`max_budget`] * CONVERSION_RATIO,
        budgetResetDate: new Date(userInfoData[`budget_reset_at`]),
      });
    } catch (error: any) {
      logger.error(`Error fetching user budget: ${error.message}`, error);
      return null;
    }
  });
}",0,Clean Code
"export function formatSkillError(
  errorString: string,
  t: TFunction,
  defaultTitle: string = `skills.installFailed`,
): { title: string; description: string } {
  const parsedError = parseSkillError(errorString);
  if (!parsedError) {
    return {
      title: t(defaultTitle),
      description: errorString || t(`common.error`),
    };
  }
  const { code, context, suggestion } = parsedError;
  const errorKey = getErrorI18nKey(code);
  let description = t(errorKey, context);
  if (suggestion) {
    const suggestionKey = getSuggestionI18nKey(suggestion);
    const suggestionText = t(suggestionKey);
    description += `\n\n${suggestionText}`;
  }
  return {
    title: t(defaultTitle),
    description,
  };
}",0,Clean Code
"export function filterGraph(nodes: GraphNode[], edges: GraphEdge[], filters: GraphFilter[]) {
  if (filters.length === 0) {
    return { nodes, edges };
  }
  const filteredNodes: GraphNode[] = [];
  const filteredEdges: GraphEdge[] = [];
  const visitedNodes = new Set();
  const visitedEdges = new Set();
  const graphLookup = makeGraphLookup(nodes, edges);
  function pushRelatedNodes(node: GraphNode) {
    if (visitedNodes.has(node.id)) return;
    visitedNodes.add(node.id);
    filteredNodes.push(node);
    graphLookup.getOutgoingEdges(node.id)?.forEach(edge => {
      const targetNode = graphLookup.getNode(edge.target);
      if (targetNode && !visitedNodes.has(targetNode.id)) {
        if (!visitedEdges.has(edge.id)) {
          visitedEdges.add(edge.id);
          filteredEdges.push(edge);
        }
        pushRelatedNodes(targetNode);
      }
    });
    graphLookup.getIncomingEdges(node.id)?.forEach(edge => {
      const sourceNode = graphLookup.getNode(edge.source);
      if (sourceNode && !visitedNodes.has(sourceNode.id)) {
        if (!visitedEdges.has(edge.id)) {
          visitedEdges.add(edge.id);
          filteredEdges.push(edge);
        }
        pushRelatedNodes(sourceNode);
      }
    });
  }
  nodes.forEach(node => {
    let keep = true;
    filters.forEach(filter => {
      if (filter.type === 'hasErrors') {
        keep &&=
          'kubeObject' in node &&
          node.kubeObject !== undefined &&
          getStatus(node.kubeObject) !== 'success';
      }
      if (filter.type === 'namespace' && filter.namespaces.size > 0) {
        keep &&=
          'kubeObject' in node &&
          node.kubeObject !== undefined &&
          !!node.kubeObject.metadata?.namespace &&
          filter.namespaces.has(node.kubeObject?.metadata?.namespace);
      }
    });
    if (keep) {
      pushRelatedNodes(node);
    }
  });
  return {
    edges: filteredEdges,
    nodes: filteredNodes,
  };
}",0,Clean Code
"function pushRelatedNodes(node: GraphNode) {
    if (visitedNodes.has(node.id)) return;
    visitedNodes.add(node.id);
    filteredNodes.push(node);

    graphLookup.getOutgoingEdges(node.id)?.forEach(edge => {
      const targetNode = graphLookup.getNode(edge.target);
      if (targetNode && !visitedNodes.has(targetNode.id)) {
        if (!visitedEdges.has(edge.id)) {
          visitedEdges.add(edge.id);
          filteredEdges.push(edge);
        }
        pushRelatedNodes(targetNode);
      }
    });

    graphLookup.getIncomingEdges(node.id)?.forEach(edge => {
      const sourceNode = graphLookup.getNode(edge.source);
      if (sourceNode && !visitedNodes.has(sourceNode.id)) {
        if (!visitedEdges.has(edge.id)) {
          visitedEdges.add(edge.id);
          filteredEdges.push(edge);
        }
        pushRelatedNodes(sourceNode);
      }
    });
  }",0,Clean Code
"mousedown: ({ uiState }) => {
  if (uiState.mode.type !== 'FREEHAND_LASSO') return;
  if (uiState.mode.selection) {
    const clickTile = uiState.mouse.position.tile;
    const isWithinSelection = isPointInPolygon(
      clickTile,
      uiState.mode.selection.pathTiles
    );
    if (isWithinSelection) {
      uiState.actions.setMode(
        produce(uiState.mode, (draft) => {
          if (draft.type === 'FREEHAND_LASSO') {
            draft.isDragging = true;
          }
        })
      );
      return;
    }
    uiState.actions.setMode(
      produce(uiState.mode, (draft) => {
        if (draft.type === 'FREEHAND_LASSO') {
          draft.path = [uiState.mouse.position.screen];
          draft.selection = null;
          draft.isDragging = false;
        }
      })
    );
    return;
  }
  uiState.actions.setMode(
    produce(uiState.mode, (draft) => {
      if (draft.type === 'FREEHAND_LASSO') {
        draft.path = [uiState.mouse.position.screen];
        draft.selection = null;
        draft.isDragging = false;
      }
    })
  );
}",0,Clean Code
"export function registerAppEnvVarsHandlers() {
  ipcMain.handle(
    `get-app-env-vars`,
    async (event, { appId }: GetAppEnvVarsParams) => {
      try {
        const app = await db.query.apps.findFirst({
          where: eq(apps.id, appId),
        });
        if (!app) {
          throw new Error(`App not found`);
        }
        const appPath = getDyadAppPath(app.path);
        const envFilePath = path.join(appPath, ENV_FILE_NAME);
        try {
          await fs.promises.access(envFilePath);
        } catch {
          return [];
        }
        const content = await fs.promises.readFile(envFilePath, `utf8`);
        const envVars = parseEnvFile(content);
        return envVars;
      } catch (error) {
        console.error(`Error getting app environment variables:`, error);
        throw new Error(
          `Failed to get environment variables: ${error instanceof Error ? error.message : `Unknown error`}`,
        );
      }
    },
  );
  ipcMain.handle(
    `set-app-env-vars`,
    async (event, { appId, envVars }: SetAppEnvVarsParams) => {
      try {
        const app = await db.query.apps.findFirst({
          where: eq(apps.id, appId),
        });
        if (!app) {
          throw new Error(`App not found`);
        }
        const appPath = getDyadAppPath(app.path);
        const envFilePath = path.join(appPath, ENV_FILE_NAME);
        const content = serializeEnvFile(envVars);
        await fs.promises.writeFile(envFilePath, content, `utf8`);
      } catch (error) {
        console.error(`Error setting app environment variables:`, error);
        throw new Error(
          `Failed to set environment variables: ${error instanceof Error ? error.message : `Unknown error`}`,
        );
      }
    },
  );
}",0,Clean Code
"function makeDeployment(params: {
  name: string;
  namespace?: string;
  replicas?: number;
  readyReplicas?: number;
  labels?: Record<string, string>;
  cluster?: string;
}) {
  const {
    name,
    namespace = 'default',
    replicas = 1,
    readyReplicas = 1,
    labels = {},
    cluster,
  } = params;
  return new Deployment(
    {
      apiVersion: 'apps/v1',
      kind: 'Deployment',
      metadata: { name, namespace, uid: uid(name), labels },
      spec: { replicas, template: { spec: { containers: [] as any, nodeName: '' } } } as any,
      status: { readyReplicas } as any,
    } as any,
    cluster
  );
}",0,Clean Code
"handle(`create-chat`, async (_, appId: number): Promise<number> => {
    const app = await db.query.apps.findFirst({
      where: eq(apps.id, appId),
      columns: {
        path: true,
      },
    });
    if (!app) {
      throw new Error(`App not found`);
    }
    let initialCommitHash = null;
    try {
      initialCommitHash = await git.resolveRef({
        fs,
        dir: getDyadAppPath(app.path),
        ref: `main`,
      });
    } catch (error) {
      logger.error(`Error getting git revision:`, error);
    }
    const [chat] = await db
      .insert(chats)
      .values({
        appId,
        initialCommitHash,
      })
      .returning();
    logger.info(
      `Created chat:`,
      chat.id,
      `for app:`,
      appId,
      `with initial commit hash:`,
      initialCommitHash,
    );
    return chat.id;
  });",0,Clean Code
"export const useUpdateProviderMutation = (appId: AppId) => {
  const queryClient = useQueryClient();
  const { t } = useTranslation();
  return useMutation({
    mutationFn: async (provider: Provider) => {
      await providersApi.update(provider, appId);
      return provider;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: [`providers`, appId] });
      toast.success(
        t(`notifications.updateSuccess`, {
          defaultValue: `供应商更新成功`,
        }),
      );
    },
    onError: (error: Error) => {
      toast.error(
        t(`notifications.updateFailed`, {
          defaultValue: `更新供应商失败: {{error}}`,
          error: error.message,
        }),
      );
    },
  });
};",0,Clean Code
"async (event, { appId }: GetAppEnvVarsParams) => {
  try {
    const app = await db.query.apps.findFirst({
      where: eq(apps.id, appId),
    });
    if (!app) {
      throw new Error(`App not found`);
    }
    const appPath = getDyadAppPath(app.path);
    const envFilePath = path.join(appPath, ENV_FILE_NAME);
    try {
      await fs.promises.access(envFilePath);
    } catch {
      return [];
    }
    const content = await fs.promises.readFile(envFilePath, `utf8`);
    const envVars = parseEnvFile(content);
    return envVars;
  } catch (error) {
    console.error(`Error getting app environment variables:`, error);
    throw new Error(
      `Failed to get environment variables: ${error instanceof Error ? error.message : `Unknown error`}`,
    );
  }
}",0,Clean Code
"mousemove: ({ uiState, scene }) => {
  if (uiState.mode.type !== 'FREEHAND_LASSO' || !uiState.mouse.mousedown) return;
  if (uiState.mode.isDragging && uiState.mode.selection) {
    uiState.actions.setMode({
      type: 'DRAG_ITEMS',
      showCursor: true,
      items: uiState.mode.selection.items,
      isInitialMovement: true
    });
    return;
  }
  const newScreenPoint = uiState.mouse.position.screen;
  uiState.actions.setMode(
    produce(uiState.mode, (draft) => {
      if (draft.type === 'FREEHAND_LASSO') {
        const lastPoint = draft.path[draft.path.length - 1];
        if (!lastPoint ||
          Math.abs(newScreenPoint.x - lastPoint.x) > 5 ||
          Math.abs(newScreenPoint.y - lastPoint.y) > 5) {
          draft.path.push(newScreenPoint);
        }
      }
    })
  );
}",0,Clean Code
"export async function retryOnLocked<T>(
  operation: () => Promise<T>,
  context: string,
  {
    retryBranchWithChildError = false,
  }: { retryBranchWithChildError?: boolean } = {},
): Promise<T> {
  let lastError: any;
  for (let attempt = 0; attempt <= RETRY_CONFIG.maxRetries; attempt++) {
    try {
      const result = await operation();
      logger.info(`${context}: Success after ${attempt + 1} attempts`);
      return result;
    } catch (error: any) {
      lastError = error;
      if (!isLockedError(error)) {
        if (retryBranchWithChildError && error.response?.status === 422) {
          logger.info(
            `${context}: Branch with child error (attempt ${attempt + 1}/${RETRY_CONFIG.maxRetries + 1})`,
          );
        } else {
          throw error;
        }
      }
      if (attempt === RETRY_CONFIG.maxRetries) {
        logger.error(
          `${context}: Failed after ${RETRY_CONFIG.maxRetries + 1} attempts due to locked error`,
        );
        throw error;
      }
      const baseDelay = RETRY_CONFIG.baseDelay * Math.pow(2, attempt);
      const jitter = baseDelay * RETRY_CONFIG.jitterFactor * Math.random();
      const delay = Math.min(baseDelay + jitter, RETRY_CONFIG.maxDelay);

      logger.warn(
        `${context}: Locked error (attempt ${attempt + 1}/${RETRY_CONFIG.maxRetries + 1}), retrying in ${Math.round(delay)}ms`,
      );
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
  throw lastError;
}",0,Clean Code
"export function killProcess(process: ChildProcess): Promise<void> {
  return new Promise<void>((resolve) => {
    const timeout = setTimeout(() => {
      console.warn(
        `Timeout waiting for process (PID: ${process.pid}) to close. Force killing may be needed.`,
      );
      resolve();
    }, 5000);
    process.on(`close`, (code, signal) => {
      clearTimeout(timeout);
      console.log(
        `Received 'close' event for process (PID: ${process.pid}) with code ${code}, signal ${signal}.`,
      );
      resolve();
    });
    process.on(`error`, (err) => {
      clearTimeout(timeout);
      console.error(
        `Error during stop sequence for process (PID: ${process.pid}): ${err.message}`,
      );
      resolve();
    });
    if (process.pid) {
      console.log(
        `Attempting to tree-kill process tree starting at PID ${process.pid}.`,
      );
      treeKill(process.pid, `SIGTERM`, (err: Error | undefined) => {
        if (err) {
          console.warn(
            `tree-kill error for PID ${process.pid}: ${err.message}`,
          );
        } else {
          console.log(
            `tree-kill signal sent successfully to PID ${process.pid}.`,
          );
        }
      });
    } else {
      console.warn(`Cannot tree-kill process: PID is undefined.`);
    }
  });
}",0,Clean Code
"function applyUpdate<
  ObjectInterface extends KubeObjectInterface,
  ObjectClass extends typeof KubeObject<ObjectInterface>
>(
  list: KubeList<KubeObject<ObjectInterface>>,
  update: KubeListUpdateEvent<ObjectInterface>,
  itemClass: ObjectClass,
  cluster: string
): KubeList<KubeObject<ObjectInterface>> {
  if (
    list.metadata.resourceVersion &&
    update.object.metadata.resourceVersion &&
    parseInt(update.object.metadata.resourceVersion) <= parseInt(list.metadata.resourceVersion)
  ) {
    return list;
  }
  const newItems = [...list.items];
  const index = newItems.findIndex(item => item.metadata.uid === update.object.metadata.uid);
  switch (update.type) {
    case 'ADDED':
    case 'MODIFIED':
      if (index !== -1) {
        newItems[index] = new itemClass(update.object, cluster);
      } else {
        newItems.push(new itemClass(update.object, cluster));
      }
      break;
    case 'DELETED':
      if (index !== -1) {
        newItems.splice(index, 1);
      }
      break;
    case 'ERROR':
      console.error('Error in update', update);
      break;
    default:
      console.error('Unknown update type', update);
  }
  return {
    ...list,
    metadata: {
      resourceVersion: update.object.metadata.resourceVersion!,
    },
    items: newItems,
  };
}",0,Clean Code
"export const fixModel = (model: Model): Model => {
  const issues = validateModel(model);
  return issues.reduce((acc, issue) => {
    if (issue.type === 'INVALID_MODEL_TO_ICON_REF') {
      return produce(acc, (draft) => {
        const { index: itemIndex } = getItemByIdOrThrow(
          draft.items,
          issue.params.modelItem
        );

        draft.items[itemIndex].icon = undefined;
      });
    }
    if (issue.type === 'CONNECTOR_TOO_FEW_ANCHORS') {
      return produce(acc, (draft) => {
        const view = getItemByIdOrThrow(draft.views, issue.params.view);

        const connector = getItemByIdOrThrow(
          view.value.connectors ?? [],
          issue.params.connector
        );

        draft.views[view.index].connectors?.splice(connector.index, 1);
      });
    }
    if (issue.type === 'INVALID_ANCHOR_TO_ANCHOR_REF') {
      return produce(acc, (draft) => {
        const view = getItemByIdOrThrow(draft.views, issue.params.view);

        const connector = getItemByIdOrThrow(
          view.value.connectors ?? [],
          issue.params.connector
        );

        const anchor = getItemByIdOrThrow(
          connector.value.anchors,
          issue.params.srcAnchor
        );

        connector.value.anchors.splice(anchor.index, 1);
      });
    }
    return acc;
  }, model);
};",0,Clean Code
"export function registerIpcHandlers() {
  registerAppHandlers();
  registerChatHandlers();
  registerChatStreamHandlers();
  registerSettingsHandlers();
  registerShellHandlers();
  registerDependencyHandlers();
  registerGithubHandlers();
  registerVercelHandlers();
  registerNodeHandlers();
  registerProblemsHandlers();
  registerProposalHandlers();
  registerDebugHandlers();
  registerSupabaseHandlers();
  registerNeonHandlers();
  registerLocalModelHandlers();
  registerTokenCountHandlers();
  registerWindowHandlers();
  registerUploadHandlers();
  registerVersionHandlers();
  registerLanguageModelHandlers();
  registerReleaseNoteHandlers();
  registerImportHandlers();
  registerSessionHandlers();
  registerProHandlers();
  registerContextPathsHandlers();
  registerAppUpgradeHandlers();
  registerCapacitorHandlers();
  registerAppEnvVarsHandlers();
  registerTemplateHandlers();
  registerPortalHandlers();
}",0,Clean Code
"mouseup: ({ uiState, scene }) => {
  if (uiState.mode.type !== 'FREEHAND_LASSO') return;
  if (uiState.mode.path.length >= 3 && !uiState.mode.selection) {
    const rendererSize = uiState.rendererEl?.getBoundingClientRect();
    if (!rendererSize) return;
    const pathTiles = uiState.mode.path.map((screenPoint) => {
      return screenToIso({
        mouse: screenPoint,
        zoom: uiState.zoom,
        scroll: uiState.scroll,
        rendererSize: {
          width: rendererSize.width,
          height: rendererSize.height
        }
      });
    });
    const items = getItemsInFreehandBounds(pathTiles, scene);
    uiState.actions.setMode(
      produce(uiState.mode, (draft) => {
        if (draft.type === 'FREEHAND_LASSO') {
          draft.selection = {
            pathTiles,
            items
          };
          draft.isDragging = false;
        }
      })
    );
  } else {
    uiState.actions.setMode(
      produce(uiState.mode, (draft) => {
        if (draft.type === 'FREEHAND_LASSO') {
          draft.isDragging = false;
        }
      })
    );
  }
}",0,Clean Code
"const registerSharedPoller = (
  key: string,
  interval: number,
  callback: () => void,
  options: { refreshWhenHidden: boolean; refreshWhenOffline: boolean },
) => {
  let entry = sharedPollers.get(key);
  if (!entry) {
    entry = {
      subscribers: 0,
      timer: null,
      interval,
      callback,
      refreshWhenHidden: options.refreshWhenHidden,
      refreshWhenOffline: options.refreshWhenOffline,
    };
    sharedPollers.set(key, entry);
  }
  entry.subscribers += 1;
  entry.callback = callback;
  entry.interval = Math.min(entry.interval, interval);
  entry.refreshWhenHidden =
    entry.refreshWhenHidden || options.refreshWhenHidden;
  entry.refreshWhenOffline =
    entry.refreshWhenOffline || options.refreshWhenOffline;
  ensureTimer(key, entry);
  return () => {
    const current = sharedPollers.get(key);
    if (!current) return;
    current.subscribers -= 1;
    if (current.subscribers <= 0) {
      if (current.timer !== null) {
        clearInterval(current.timer);
      }
      sharedPollers.delete(key);
    }
  };
};",0,Clean Code
"export const useLoadingOverlay = (themeReady: boolean) => {
  const overlayRemovedRef = useRef(false);
  useEffect(() => {
    if (!themeReady || overlayRemovedRef.current) return;
    let fadeTimer: number | null = null;
    let retryTimer: number | null = null;
    let attempts = 0;
    const maxAttempts = 50;
    let stopped = false;
    const tryRemoveOverlay = () => {
      if (stopped || overlayRemovedRef.current) return;
      const overlay = document.getElementById(`initial-loading-overlay`);
      if (overlay) {
        overlayRemovedRef.current = true;
        overlay.style.opacity = `0`;
        overlay.style.pointerEvents = `none`;
        fadeTimer = window.setTimeout(() => {
          try {
            overlay.remove();
          } catch (error) {
            console.warn(`[加载遮罩] 移除失败:`, error);
          }
        }, 300);
        return;
      }
      if (attempts < maxAttempts) {
        attempts += 1;
        retryTimer = window.setTimeout(tryRemoveOverlay, 100);
      } else {
        console.warn(`[加载遮罩] 未找到元素`);
      }
    };
    tryRemoveOverlay();
    return () => {
      stopped = true;
      if (fadeTimer) window.clearTimeout(fadeTimer);
      if (retryTimer) window.clearTimeout(retryTimer);
    };
  }, [themeReady]);
};",0,Clean Code
"export function parseSmartMcpJson(jsonText: string): {
  id?: string;
  config: any;
  formattedConfig: string;
} {
  let trimmed = jsonText.trim();
  if (!trimmed) {
    return { config: {}, formattedConfig: `` };
  }
  if (trimmed.startsWith('`') && !trimmed.startsWith(`{`)) {
    trimmed = `{${trimmed}}`;
  }
  const parsed = JSON.parse(trimmed);
  const keys = Object.keys(parsed);
  if (
    keys.length === 1 &&
    parsed[keys[0]] &&
    typeof parsed[keys[0]] === `object` &&
    !Array.isArray(parsed[keys[0]])
  ) {
    const id = keys[0];
    const config = parsed[id];
    return {
      id,
      config,
      formattedConfig: JSON.stringify(config, null, 2),
    };
  }
  return {
    config: parsed,
    formattedConfig: JSON.stringify(parsed, null, 2),
  };
}",0,Clean Code
"export function useSettingsMetadata(): UseSettingsMetadataResult {
  const [isPortable, setIsPortable] = useState(false);
  const [requiresRestart, setRequiresRestart] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  useEffect(() => {
    let active = true;
    setIsLoading(true);
    const load = async () => {
      try {
        const portable = await settingsApi.isPortable();
        if (!active) return;
        setIsPortable(portable);
      } catch (error) {
        console.error(`[useSettingsMetadata] Failed to load metadata`, error);
      } finally {
        if (active) {
          setIsLoading(false);
        }
      }
    };
    void load();
    return () => {
      active = false;
    };
  }, []);
  const acknowledgeRestart = useCallback(() => {
    setRequiresRestart(false);
  }, []);
  return {
    isPortable,
    requiresRestart,
    isLoading,
    acknowledgeRestart,
    setRequiresRestart,
  };
}",0,Clean Code
